{
  "exported": "2026-02-10T00:49:16.382Z",
  "count": 927,
  "patterns": [
    {
      "id": "b3d2583f8631ca03",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "78309ffbaa7cbdb8",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "852f250a97308ca5",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "68751a28a2faa2b4",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a449853639a5a5a5",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1ab97e99b5b17698",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f838885fa3511706",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4dae5041b319aea4",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f956e0703a5488f6",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8d087558b62b9234",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "dc3052bf7d92600d",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c6c5b774e0aeb9ce",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1f93a44713df2941",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "53a6d86bb9ad0ede",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8f8c1b610d8dbefb",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d0055ee27169eb80",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c724c534394e9bdb",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2d5d67a4c2698a8c",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c62f51076fbc7283",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5fb29052de4a021b",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "270f69b3585bc330",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e3cba39e57433b30",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c0337b8074f3649d",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "34424c3af91b79e0",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f550008c61b2e5ec",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "eae2b82b992cb641",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "71bee55a5ebbae65",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bf5a8912de49ad53",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7a65afd8c1c7badb",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5e0b99778b5b930b",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1c1a740065b95075",
      "name": "linked-list-refined-ts",
      "code": "function LinkedList() { this.head = null; this.length = 0; }\nLinkedList.prototype.push = function(val) {\n  this.head = { val: val, next: this.head };\n  this.length++;\n};\nLinkedList.prototype.pop = function() {\n  if (!this.head) return undefined;\n  const val = this.head.val;\n  this.head = this.head.next;\n  this.length--;\n  return val;\n};\nLinkedList.prototype.has = function(val) {\n  let n = this.head;\n  while (n) { if (n.val === val) return true; n = n.next; }\n  return false;\n};\nLinkedList.prototype.toArray = function() {\n  const r = [], n = this.head;\n  while (n) { r.push(n.val); n = n.next; }\n  return r;\n};",
      "testCode": "var linkedList = new LinkedList();\nlinkedList.push(1);\nlinkedList.pop();\nlinkedList.has(1);\nlinkedList.toArray();\nif (!linkedList) throw new Error(\"instance is falsy\");",
      "language": "typescript",
      "description": "Singly linked list (refined) (TypeScript variant)",
      "tags": [
        "data-structure",
        "linked-list",
        "auto-refined",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "4b733b4a680d6a3b",
      "name": "linked-list-refined",
      "code": "function LinkedList() { this.head = null; this.length = 0; }\nLinkedList.prototype.push = function(val) {\n  this.head = { val: val, next: this.head };\n  this.length++;\n};\nLinkedList.prototype.pop = function() {\n  if (!this.head) return undefined;\n  const val = this.head.val;\n  this.head = this.head.next;\n  this.length--;\n  return val;\n};\nLinkedList.prototype.has = function(val) {\n  let n = this.head;\n  while (n) { if (n.val === val) return true; n = n.next; }\n  return false;\n};\nLinkedList.prototype.toArray = function() {\n  const r = [], n = this.head;\n  while (n) { r.push(n.val); n = n.next; }\n  return r;\n};",
      "testCode": "var linkedList = new LinkedList();\nlinkedList.push(1);\nlinkedList.pop();\nlinkedList.has(1);\nlinkedList.toArray();\nif (!linkedList) throw new Error(\"instance is falsy\");",
      "language": "javascript",
      "description": "Singly linked list (refined)",
      "tags": [
        "data-structure",
        "linked-list",
        "auto-refined"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "f464e042cb45e807",
      "name": "share-test-py",
      "code": "def share_test():\n    return 1",
      "testCode": "assert share_test() == 1",
      "language": "python",
      "description": "Test share (Python variant)",
      "tags": [
        "test",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6a316d8fd187a7a8",
      "name": "share-test-ts",
      "code": "function shareTest() { return 1; }",
      "testCode": "if (shareTest() !== 1) throw new Error(\"fail\");",
      "language": "typescript",
      "description": "Test share (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "527ae7a7b77c9106",
      "name": "sync-test-py",
      "code": "def sync_test(n):\n    return n",
      "testCode": "assert sync_test(1) == 1",
      "language": "python",
      "description": "Identity (Python variant)",
      "tags": [
        "test",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3d27d9b7adf58846",
      "name": "sync-test-ts",
      "code": "function syncTest(n: any) { return n; }",
      "testCode": "if (syncTest(1) !== 1) throw new Error(\"fail\");",
      "language": "typescript",
      "description": "Identity (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "95e30847894ae7b5",
      "name": "share-test",
      "code": "function shareTest() { return 1; }",
      "testCode": "if (shareTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Test share",
      "tags": [
        "test"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "be8e8e12fbc35086",
      "name": "sync-test",
      "code": "function syncTest(n) { return n; }",
      "testCode": "if (syncTest(1) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Identity",
      "tags": [
        "test"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "45559d0b219b642c",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "cb111f61bccae2dc",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "414f3d933ddfab9e",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b05183500f7e5585",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "32559155568d699d",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "124087ed43c10631",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3f7e9564fe8edb20",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e252c6f6e207f06a",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d073e98a337a6d36",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "125f9cb08231fa4b",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "43aea09f0674b4c1",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "044a7801aeab9a3c",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e8775ed429eb2139",
      "name": "add-ts",
      "code": "function   add(a: any, b: any){\nlet result=a+b;\nreturn result\n}",
      "testCode": "if (add(1, 1) === undefined) throw new Error(\"returned undefined\");\nif (add(0, 1) === undefined) throw new Error(\"returned undefined\");\nif (add(\"\", 1) === undefined) throw new Error(\"returned undefined\");\nif (add(1, 0) === undefined) throw new Error(\"returned undefined\");\nif (add(1, \"\") === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "add",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3c244983bbbd4bd2",
      "name": "beta-ts",
      "code": "function beta() {\n  return 'beta function result here';\n}",
      "testCode": "if (beta() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "beta",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c29469a8992da654",
      "name": "alpha-ts",
      "code": "function alpha() {\n  return 'alpha function result';\n}",
      "testCode": "if (alpha() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "alpha",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "68c90c90b5fea080",
      "name": "f-ts",
      "code": "function f() { if (true) { return 1; } return 0; }",
      "testCode": "if (f() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "f",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b4d6818ee73a195a",
      "name": "readStdin-ts",
      "code": "function readStdin() {\n  if (process.stdin.isTTY) return '';\n  try {\n    return fs.readFileSync(0, 'utf-8');\n  } catch {\n    return '';\n  }\n}",
      "testCode": "if (readStdin() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — src/cli.js (TypeScript variant)",
      "tags": [
        "readStdin",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "7ac364075662116f",
      "name": "extract-repo-name-ts",
      "code": "function extractRepoName(url: any) {\n  if (!url) return 'unknown';\n  const match = url.match(/\\/([^/]+?)(?:\\.git)?$/);\n  return match ? match[1] : 'unknown';\n}\n\nmodule.exports = { extractRepoName };\n",
      "testCode": "if (extractRepoName('https://github.com/user/repo') !== 'repo') throw new Error('Should extract repo');\nif (extractRepoName('https://github.com/user/repo.git') !== 'repo') throw new Error('Should strip .git');\nif (extractRepoName('git@github.com:user/my-lib.git') !== 'my-lib') throw new Error('Should handle SSH');\nif (extractRepoName(null) !== 'unknown') throw new Error('Null should return unknown');\nif (extractRepoName('') !== 'unknown') throw new Error('Empty should return unknown');\nif (extractRepoName('https://github.com/org/cool-project') !== 'cool-project') throw new Error('Should handle hyphens');\n",
      "language": "typescript",
      "description": "Extract repository name from Git URL (HTTPS or SSH), stripping .git suffix (TypeScript variant)",
      "tags": [
        "git",
        "url",
        "parser",
        "utility",
        "github",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "213df6f6e6adae41",
      "name": "dependency-injection-ts",
      "code": "class DIContainer {\n  constructor() { this._reg = new Map(); this._sing = new Map(); }\n  register(name, factory, opts) {\n    this._reg.set(name, { factory: factory, singleton: !!(opts && opts.singleton) });\n    this._sing.delete(name); return this;\n  }\n  resolve(name) {\n    if (!this._reg.has(name)) throw new Error(name + ' not registered');\n    let e = this._reg.get(name);\n    if (e.singleton) { if (!this._sing.has(name)) this._sing.set(name, e.factory(this)); return this._sing.get(name); }\n    return e.factory(this);\n  }\n  has(name) { return this._reg.has(name); }\n}",
      "testCode": "var c = new DIContainer();\nc.register('config', function(){ return { port: 3000 }; }, { singleton: true });\nc.register('logger', function(){ return { log: function(){} }; });\nvar cfg1 = c.resolve('config');\nvar cfg2 = c.resolve('config');\nif (cfg1 !== cfg2) throw new Error('singleton should return same instance');\nvar l1 = c.resolve('logger');\nvar l2 = c.resolve('logger');\nif (l1 === l2) throw new Error('non-singleton should return new instance');\nif (!c.has('config') || c.has('missing')) throw new Error('has check');\ntry { c.resolve('missing'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "typescript",
      "description": "Dependency injection container with singleton support and factory resolution (TypeScript variant)",
      "tags": [
        "di",
        "dependency-injection",
        "container",
        "ioc",
        "design-pattern",
        "factory",
        "singleton",
        "variant",
        "typescript"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "c2a7f6227961c4c2",
      "name": "stream-pipeline-ts",
      "code": "class StreamPipeline {\n  constructor() { this.transforms = []; }\n  pipe(transformFn) { this.transforms.push(transformFn); return this; }\n  async process(input) {\n    let result = input;\n    for (let i = 0; i < this.transforms.length; i++) {\n      result = await Promise.resolve(this.transforms[i](result));\n    }\n    return result;\n  }\n  get length() { return this.transforms.length; }\n  reset() { this.transforms = []; return this; }\n}",
      "testCode": "var p = new StreamPipeline();\np.pipe(function(x){return x*2}).pipe(function(x){return x+1}).pipe(function(x){return String(x)});\nvar r = await p.process(5);\nif (r !== '11') throw new Error('chain result: ' + r);\nvar p2 = new StreamPipeline();\np2.pipe(async function(x){return x.toUpperCase()}).pipe(function(x){return x+'!'});\nvar r2 = await p2.process('hello');\nif (r2 !== 'HELLO!') throw new Error('async transform');\nif (p.length !== 3) throw new Error('length');\nvar p3 = new StreamPipeline();\nif (await p3.process(42) !== 42) throw new Error('empty pipeline');",
      "language": "typescript",
      "description": "Chainable transform pipeline with sync and async function support (TypeScript variant)",
      "tags": [
        "stream",
        "pipeline",
        "transform",
        "chain",
        "async",
        "io",
        "functional",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "88f4c53a54fbcdcc",
      "name": "request-validator-ts",
      "code": "class RequestValidator {\n  constructor(schema) { this.schema = schema; }\n  validate(data) {\n    let errors = [];\n    for (let f of Object.keys(this.schema)) { let r = this.schema[f], v = data[f];\n      if (r.required && (v == null || v === '')) { errors.push(f+' is required'); continue; }\n      if (v == null) continue;\n      if (r.type && typeof v !== r.type) errors.push(f+' must be type '+r.type);\n      if (r.min != null && v < r.min) errors.push(f+' must be >= '+r.min);\n      if (r.max != null && v > r.max) errors.push(f+' must be <= '+r.max);\n      if (r.pattern && !r.pattern.test(String(v))) errors.push(f+' format invalid');\n      if (r.enum && !r.enum.includes(v)) errors.push(f+' must be one of: '+r.enum.join(', '));\n    }\n    return { valid: errors.length === 0, errors: errors };\n  }\n}",
      "testCode": "var v = new RequestValidator({\n  name: { type: 'string', required: true },\n  age: { type: 'number', min: 0, max: 150 },\n  role: { enum: ['admin', 'user'] }\n});\nvar r1 = v.validate({ name: 'Alice', age: 30, role: 'admin' });\nif (!r1.valid) throw new Error('valid data failed');\nvar r2 = v.validate({});\nif (r2.valid || r2.errors.length === 0) throw new Error('missing required passed');\nvar r3 = v.validate({ name: 'Bob', age: -1 });\nif (r3.valid) throw new Error('below min passed');\nvar r4 = v.validate({ name: 'X', role: 'superadmin' });\nif (r4.valid) throw new Error('invalid enum passed');",
      "language": "typescript",
      "description": "Schema-based request validator with type, range, pattern, and enum checks (TypeScript variant)",
      "tags": [
        "validation",
        "schema",
        "request",
        "form",
        "input",
        "sanitize",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e27e77d1631f9186",
      "name": "worker-pool-ts",
      "code": "class WorkerPool {\n  constructor(size) { this.size = size; this.current = 0; this.active = 0; this.completed = 0; this.failed = 0; this._off = false; }\n  async exec(task) {\n    if (this._off) throw new Error('Pool is shut down');\n    let w = this.current; this.current = (this.current + 1) % this.size; this.active++;\n    try { let r = await Promise.resolve(task(w)); this.completed++; return r; }\n    catch (e) { this.failed++; throw e; } finally { this.active--; }\n  }\n  stats() { return { size: this.size, active: this.active, completed: this.completed, failed: this.failed }; }\n  shutdown() { this._off = true; }\n}",
      "testCode": "var pool = new WorkerPool(2);\nvar results = [];\nawait pool.exec(function(w) { results.push('a' + w); });\nawait pool.exec(function(w) { results.push('b' + w); });\nawait pool.exec(function(w) { results.push('c' + w); });\nif (results[0] !== 'a0') throw new Error('first worker');\nif (results[1] !== 'b1') throw new Error('round-robin');\nif (results[2] !== 'c0') throw new Error('wrap around');\nif (pool.stats().completed !== 3) throw new Error('completed count');\npool.shutdown();\ntry { await pool.exec(function(){}); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "typescript",
      "description": "Worker pool with round-robin dispatch, stats tracking, and graceful shutdown (TypeScript variant)",
      "tags": [
        "concurrency",
        "pool",
        "worker",
        "async",
        "round-robin",
        "task-queue",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "0f6c355f5b0bba1d",
      "name": "middleware-chain-ts",
      "code": "class MiddlewareChain {\n  constructor() { this._middlewares = []; }\n  use(fn) {\n    this._middlewares.push(fn);\n    return this;\n  }\n  execute(context) {\n    let index = 0;\n    const next = () => {\n      if (index >= this._middlewares.length) return Promise.resolve();\n      const fn = this._middlewares[index++];\n      return Promise.resolve(fn(context, next));\n    };\n    return next();\n  }\n}",
      "testCode": "const chain = new MiddlewareChain();\nconst order = [];\nchain.use(async (ctx, next) => { order.push('a'); ctx.a = 1; await next(); order.push('a2'); });\nchain.use(async (ctx, next) => { order.push('b'); ctx.b = 2; await next(); });\nconst ctx = {};\nawait chain.execute(ctx);\nif (ctx.a !== 1 || ctx.b !== 2) throw new Error('middleware should modify context');\nif (order.join(',') !== 'a,b,a2') throw new Error('should execute in onion order: ' + order);\nconst empty = new MiddlewareChain();\nawait empty.execute({});",
      "language": "typescript",
      "description": "Express-style middleware chain with async next() calling and context passing (TypeScript variant)",
      "tags": [
        "middleware",
        "chain",
        "pipeline",
        "design-pattern",
        "express",
        "compose",
        "variant",
        "typescript"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "0ba8fcb1b3f667b3",
      "name": "promise-queue-ts",
      "code": "class PromiseQueue {\n  constructor(concurrency = 1) {\n    this._c = concurrency; this._q = []; this._p = 0;\n  }\n  add(fn) {\n    return new Promise((resolve, reject) => {\n      this._q.push({ fn, resolve, reject }); this._run();\n    });\n  }\n  _run() {\n    while (this._p < this._c && this._q.length) {\n      const t = this._q.shift(); this._p++;\n      Promise.resolve(t.fn()).then(\n        v => { this._p--; t.resolve(v); this._run(); },\n        e => { this._p--; t.reject(e); this._run(); }\n      );\n    }\n  }\n  size() { return this._q.length; }\n  pending() { return this._p; }\n}",
      "testCode": "const q = new PromiseQueue(2);\nconst order = [];\nconst task = (id, ms) => () => new Promise(r => setTimeout(() => { order.push(id); r(id); }, ms));\nconst p1 = q.add(task('a', 50));\nconst p2 = q.add(task('b', 30));\nconst p3 = q.add(task('c', 10));\nif (q.pending() !== 2) throw new Error('should have 2 pending');\nif (q.size() !== 1) throw new Error('should have 1 queued');\nconst results = await Promise.all([p1, p2, p3]);\nif (results.join(',') !== 'a,b,c') throw new Error('should resolve with correct values');",
      "language": "typescript",
      "description": "Concurrency-limited promise queue that processes async tasks with bounded parallelism (TypeScript variant)",
      "tags": [
        "queue",
        "promise",
        "concurrency",
        "async",
        "task-queue",
        "parallel",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "acadfb486a434e8d",
      "name": "semaphore-ts",
      "code": "class Semaphore {\n  constructor(permits) {\n    this._permits = permits;\n    this._max = permits;\n    this._queue = [];\n  }\n  acquire() {\n    if (this._permits > 0) {\n      this._permits--;\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this._queue.push(resolve));\n  }\n  release() {\n    if (this._queue.length > 0) {\n      this._queue.shift()();\n    } else if (this._permits < this._max) {\n      this._permits++;\n    }\n  }\n  available() {\n    return this._permits;\n  }\n}",
      "testCode": "const sem = new Semaphore(2);\nif (sem.available() !== 2) throw new Error('should start with 2 permits');\nawait sem.acquire();\nif (sem.available() !== 1) throw new Error('should have 1 after acquire');\nawait sem.acquire();\nif (sem.available() !== 0) throw new Error('should have 0 after 2 acquires');\nlet acquired = false;\nconst pending = sem.acquire().then(() => { acquired = true; });\nsem.release();\nawait pending;\nif (!acquired) throw new Error('should acquire after release');",
      "language": "typescript",
      "description": "Counting semaphore with async acquire and bounded permits (TypeScript variant)",
      "tags": [
        "semaphore",
        "concurrency",
        "async",
        "locking",
        "permits",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "517d4b9a42bfa6a0",
      "name": "rate-limiter-ts",
      "code": "class RateLimiter {\n  constructor(maxTokens, refillRate) {\n    this.max = maxTokens;\n    this.tokens = maxTokens;\n    this.rate = refillRate;\n    this.last = Date.now();\n  }\n  _refill() {\n    const now = Date.now();\n    this.tokens = Math.min(this.max, this.tokens + (now - this.last) / 1000 * this.rate);\n    this.last = now;\n  }\n  consume(tokens = 1) {\n    this._refill();\n    if (this.tokens >= tokens) { this.tokens -= tokens; return true; }\n    return false;\n  }\n  remainingTokens() {\n    this._refill();\n    return Math.floor(this.tokens);\n  }\n}",
      "testCode": "const limiter = new RateLimiter(5, 1);\nif (!limiter.consume(1)) throw new Error('should consume 1 token');\nif (!limiter.consume(4)) throw new Error('should consume remaining 4 tokens');\nif (limiter.consume(1)) throw new Error('should reject when exhausted');\nif (limiter.remainingTokens() !== 0) throw new Error('should have 0 remaining');\nconst l2 = new RateLimiter(3, 10);\nif (!l2.consume(2)) throw new Error('should consume 2 of 3');",
      "language": "typescript",
      "description": "Token bucket rate limiter with configurable max tokens and refill rate per second (TypeScript variant)",
      "tags": [
        "rate-limit",
        "throttle",
        "token-bucket",
        "concurrency",
        "rate-limiter",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "6cd4eeb2a4356912",
      "name": "retry-with-backoff-ts",
      "code": "async function retryWithBackoff(fn: Function, options: Record<string, any>) {\n  const { maxRetries = 3, baseDelay = 100, maxDelay = 5000, jitter = true } = options;\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        let delay = Math.min(baseDelay * Math.pow(2, i), maxDelay);\n        if (jitter) delay *= 0.5 + Math.random() * 0.5;\n        await new Promise(r => setTimeout(r, delay));\n      }\n    }\n  }\n  throw lastError;\n}",
      "testCode": "let count = 0;\nconst flaky = async () => { count++; if (count < 3) throw new Error('not yet'); return 'done'; };\nconst result = await retryWithBackoff(flaky, { maxRetries: 3, baseDelay: 10 });\nif (result !== 'done') throw new Error('should return successful result');\nif (count !== 3) throw new Error('should have retried until success');\nlet threw = false;\ntry { await retryWithBackoff(() => { throw new Error('always'); }, { maxRetries: 2, baseDelay: 10 }); }\ncatch(e) { threw = true; if (e.message !== 'always') throw new Error('should throw last error'); }\nif (!threw) throw new Error('should throw after retries exhausted');",
      "language": "typescript",
      "description": "Async retry with exponential backoff, jitter, configurable max retries and delay bounds (TypeScript variant)",
      "tags": [
        "retry",
        "backoff",
        "exponential",
        "resilience",
        "async",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "f9894f74c15b0581",
      "name": "priority-queue-refined",
      "code": "function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  let i = this.heap.length - 1;\n  while (i > 0) {\n    const p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    let t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return;\n  const top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    let i = 0, n = this.heap.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      let t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};",
      "testCode": "var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');",
      "language": "javascript",
      "description": "Priority queue using min-heap (refined)",
      "tags": [
        "data-structure",
        "priority-queue",
        "heap",
        "auto-refined"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "f94127251c877d81",
      "name": "min-heap-refined",
      "code": "function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  let i = this.data.length - 1;\n  while (i > 0) {\n    const p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    let t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return;\n  const min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    let i = 0, n = this.data.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      let t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };",
      "testCode": "var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');",
      "language": "javascript",
      "description": "Min-heap with insert and extractMin (refined)",
      "tags": [
        "data-structure",
        "heap",
        "priority-queue",
        "auto-refined"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "4f39259c1aaaa8e3",
      "name": "extract-repo-name",
      "code": "function extractRepoName(url) {\n  if (!url) return 'unknown';\n  const match = url.match(/\\/([^/]+?)(?:\\.git)?$/);\n  return match ? match[1] : 'unknown';\n}\n\nmodule.exports = { extractRepoName };\n",
      "testCode": "if (extractRepoName('https://github.com/user/repo') !== 'repo') throw new Error('Should extract repo');\nif (extractRepoName('https://github.com/user/repo.git') !== 'repo') throw new Error('Should strip .git');\nif (extractRepoName('git@github.com:user/my-lib.git') !== 'my-lib') throw new Error('Should handle SSH');\nif (extractRepoName(null) !== 'unknown') throw new Error('Null should return unknown');\nif (extractRepoName('') !== 'unknown') throw new Error('Empty should return unknown');\nif (extractRepoName('https://github.com/org/cool-project') !== 'cool-project') throw new Error('Should handle hyphens');\n",
      "language": "javascript",
      "description": "Extract repository name from Git URL (HTTPS or SSH), stripping .git suffix",
      "tags": [
        "git",
        "url",
        "parser",
        "utility",
        "github"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "9313944c6a8b5f48",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "12f4f93bf44c6b2d",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7e830b949dcb9b72",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1d284e49d31663d6",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9a78a6d1fc86ff35",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e47b0ceccb61091a",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "46e9c50048428dea",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "562fb2bdebcf7de3",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "244df292db6ce21c",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e511e582b6de998c",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "701d922b51c897b2",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3c92aa46e4d321f0",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "524ab2b9c93832bf",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a2a9cf2079718063",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "836d213aab4fca2f",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6554b4aa8d1f494e",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f493ff019afba312",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "55e50943cab588de",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b31e20805e6dd319",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1a3b591bc828ffe4",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ce309b269ccdc8ec",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "774e57a826cf7099",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a1449615ff12fa24",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "04d35451841a6f77",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "298e9bf4c6035431",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "63b1624e03c39bce",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2d43cb25fe870923",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "62fd95298a6d392e",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "90551d87eba306a0",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7ab61befde545221",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e3acd5c703773951",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2d7fbf9f3783c13a",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a13de2c54fb22925",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "817154ffbddac450",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8f6ab131390f407d",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "764c0a6aba4350cb",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "04c8d673c32cb511",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0891afc5fdb7e37b",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c6259255c40711d4",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3cc201823bca959f",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bdd25f3ed1d652cb",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f30b7f250880b9d3",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bfa7e349658fbcb7",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "86a656160a09ab35",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "978be47c894d8d43",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "48c2a8184f27f035",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0d7dfe3123820b88",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c02af5f685644bdf",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c2981d726d5a56be",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e8e030c472fd660b",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "884addc368593139",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d3fd63cc42ce2b94",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f863d9c7e482386c",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3cfc7f6385a408f7",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b5b37db03d3aa1ec",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3fd0baa74217bb95",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "87ee3195ae150ce9",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c60a58e7c4bde48d",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b91e807f6ae99393",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "cff9110b93a88790",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "31b711fefeccb59c",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "045ee24b9b5a444c",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ac9ed1fceb192cdc",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9e8edabd6ff3d7f9",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2e92b5588aa66eb6",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a016efeeade87201",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9c9ab25331470988",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "cba768913126916b",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "595fd05e1e0af449",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d452f3fcdfe66959",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ac2b34ac93ae4d18",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "43f809ca44410fde",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "256b7d94ecb0c81c",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e42ecddbda0a5479",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c22cd08f6144c0c4",
      "name": "from-trait-rust",
      "code": "#[derive(Debug, PartialEq)]\npub struct Celsius(f64);\n\n#[derive(Debug, PartialEq)]\npub struct Fahrenheit(f64);\n\nimpl From<Celsius> for Fahrenheit {\n    fn from(c: Celsius) -> Self {\n        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)\n    }\n}\n\nimpl From<Fahrenheit> for Celsius {\n    fn from(f: Fahrenheit) -> Self {\n        Celsius((f.0 - 32.0) * 5.0 / 9.0)\n    }\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_temperature_conversion() {\n    let boiling = Celsius(100.0);\n    let f: Fahrenheit = boiling.into();\n    assert_eq!(f.0, 212.0);\n\n    let freezing = Fahrenheit(32.0);\n    let c: Celsius = freezing.into();\n    assert_eq!(c.0, 0.0);\n}",
      "language": "rust",
      "description": "Type-safe temperature conversion using From trait",
      "tags": [
        "trait",
        "from",
        "conversion",
        "rust-native"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "ccafe4e29caccde5",
      "name": "option-utils-rust",
      "code": "pub fn first_some<T>(options: &[Option<T>]) -> Option<&T> {\n    options.iter().find_map(|o| o.as_ref())\n}\n\npub fn zip_options<A, B>(a: Option<A>, b: Option<B>) -> Option<(A, B)> {\n    match (a, b) {\n        (Some(a), Some(b)) => Some((a, b)),\n        _ => None,\n    }\n}\n\npub fn unwrap_or_compute<T, F: FnOnce() -> T>(opt: Option<T>, f: F) -> T {\n    match opt {\n        Some(v) => v,\n        None => f(),\n    }\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_option_utils() {\n    let opts: Vec<Option<i32>> = vec![None, Some(2), Some(3)];\n    assert_eq!(first_some(&opts), Some(&2));\n\n    assert_eq!(zip_options(Some(1), Some(\"a\")), Some((1, \"a\")));\n    assert_eq!(zip_options(Some(1), None::<&str>), None);\n\n    assert_eq!(unwrap_or_compute(Some(5), || 10), 5);\n    assert_eq!(unwrap_or_compute(None, || 10), 10);\n}",
      "language": "rust",
      "description": "Option utility functions — first_some, zip, unwrap_or_compute",
      "tags": [
        "option",
        "utility",
        "functional",
        "rust-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "fec3a3860cc33841",
      "name": "trait-strategy-rust",
      "code": "pub trait Sorter {\n    fn sort(&self, data: &mut [i32]);\n}\n\npub struct BubbleSort;\npub struct InsertionSort;\n\nimpl Sorter for BubbleSort {\n    fn sort(&self, data: &mut [i32]) {\n        let n = data.len();\n        for i in 0..n {\n            for j in 0..n - 1 - i {\n                if data[j] > data[j + 1] {\n                    data.swap(j, j + 1);\n                }\n            }\n        }\n    }\n}\n\nimpl Sorter for InsertionSort {\n    fn sort(&self, data: &mut [i32]) {\n        for i in 1..data.len() {\n            let key = data[i];\n            let mut j = i;\n            while j > 0 && data[j - 1] > key {\n                data[j] = data[j - 1];\n                j -= 1;\n            }\n            data[j] = key;\n        }\n    }\n}\n\npub fn sort_with(data: &mut [i32], strategy: &dyn Sorter) {\n    strategy.sort(data);\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_strategy_pattern() {\n    let mut data = vec![3, 1, 4, 1, 5];\n    sort_with(&mut data, &BubbleSort);\n    assert_eq!(data, vec![1, 1, 3, 4, 5]);\n\n    let mut data2 = vec![5, 4, 3, 2, 1];\n    sort_with(&mut data2, &InsertionSort);\n    assert_eq!(data2, vec![1, 2, 3, 4, 5]);\n}",
      "language": "rust",
      "description": "Strategy pattern using traits and dynamic dispatch",
      "tags": [
        "trait",
        "design-pattern",
        "strategy",
        "rust-native"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "a9f19e145f2d5f67",
      "name": "stack-rust",
      "code": "pub struct Stack<T> {\n    items: Vec<T>,\n}\n\nimpl<T> Stack<T> {\n    pub fn new() -> Self {\n        Stack { items: Vec::new() }\n    }\n\n    pub fn push(&mut self, item: T) {\n        self.items.push(item);\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        self.items.pop()\n    }\n\n    pub fn peek(&self) -> Option<&T> {\n        self.items.last()\n    }\n\n    pub fn len(&self) -> usize {\n        self.items.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_stack() {\n    let mut s = Stack::new();\n    s.push(1);\n    s.push(2);\n    assert_eq!(s.len(), 2);\n    assert_eq!(s.pop(), Some(2));\n    assert_eq!(s.peek(), Some(&1));\n    s.pop();\n    assert_eq!(s.pop(), None);\n    assert!(s.is_empty());\n}",
      "language": "rust",
      "description": "Generic stack backed by Vec",
      "tags": [
        "data-structure",
        "stack",
        "generics",
        "rust-native"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "e8fd7d4966c0e274",
      "name": "memoize-go",
      "code": "package main\n\nimport \"sync\"\n\nfunc Memoize[K comparable, V any](fn func(K) V) func(K) V {\n\tcache := make(map[K]V)\n\tvar mu sync.RWMutex\n\n\treturn func(key K) V {\n\t\tmu.RLock()\n\t\tif v, ok := cache[key]; ok {\n\t\t\tmu.RUnlock()\n\t\t\treturn v\n\t\t}\n\t\tmu.RUnlock()\n\n\t\tv := fn(key)\n\t\tmu.Lock()\n\t\tcache[key] = v\n\t\tmu.Unlock()\n\t\treturn v\n\t}\n}",
      "testCode": "package main\n\nimport \"testing\"\n\nfunc TestMemoize(t *testing.T) {\n\tcalls := 0\n\tfib := Memoize(func(n int) int {\n\t\tcalls++\n\t\tif n <= 1 { return n }\n\t\treturn n // simplified\n\t})\n\tfib(5)\n\tfib(5)\n\tif calls != 1 { t.Errorf(\"expected 1 call, got %d\", calls) }\n}",
      "language": "go",
      "description": "Thread-safe memoization with generics and RWMutex",
      "tags": [
        "memoize",
        "cache",
        "concurrency",
        "go-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "a990b4a2d44ac1e9",
      "name": "linked-list-go",
      "code": "package main\n\ntype Node[T any] struct {\n\tValue T\n\tNext  *Node[T]\n}\n\ntype LinkedList[T any] struct {\n\tHead *Node[T]\n\tSize int\n}\n\nfunc (ll *LinkedList[T]) Prepend(value T) {\n\tll.Head = &Node[T]{Value: value, Next: ll.Head}\n\tll.Size++\n}\n\nfunc (ll *LinkedList[T]) ToSlice() []T {\n\tresult := make([]T, 0, ll.Size)\n\tcurrent := ll.Head\n\tfor current != nil {\n\t\tresult = append(result, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn result\n}\n\nfunc (ll *LinkedList[T]) Reverse() {\n\tvar prev *Node[T]\n\tcurrent := ll.Head\n\tfor current != nil {\n\t\tnext := current.Next\n\t\tcurrent.Next = prev\n\t\tprev = current\n\t\tcurrent = next\n\t}\n\tll.Head = prev\n}",
      "testCode": "package main\n\nimport \"testing\"\n\nfunc TestLinkedList(t *testing.T) {\n\tll := &LinkedList[int]{}\n\tll.Prepend(3)\n\tll.Prepend(2)\n\tll.Prepend(1)\n\ts := ll.ToSlice()\n\tif len(s) != 3 || s[0] != 1 || s[2] != 3 { t.Error(\"prepend/toSlice failed\") }\n\tll.Reverse()\n\ts = ll.ToSlice()\n\tif s[0] != 3 || s[2] != 1 { t.Error(\"reverse failed\") }\n}",
      "language": "go",
      "description": "Generic singly linked list with reverse",
      "tags": [
        "data-structure",
        "linked-list",
        "generics",
        "go-native"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "4921be2394ffe719",
      "name": "map-filter-reduce-go",
      "code": "package main\n\nfunc Map[T any, R any](slice []T, fn func(T) R) []R {\n\tresult := make([]R, len(slice))\n\tfor i, v := range slice {\n\t\tresult[i] = fn(v)\n\t}\n\treturn result\n}\n\nfunc Filter[T any](slice []T, predicate func(T) bool) []T {\n\tresult := make([]T, 0)\n\tfor _, v := range slice {\n\t\tif predicate(v) {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc Reduce[T any, R any](slice []T, initial R, fn func(R, T) R) R {\n\tacc := initial\n\tfor _, v := range slice {\n\t\tacc = fn(acc, v)\n\t}\n\treturn acc\n}",
      "testCode": "package main\n\nimport \"testing\"\n\nfunc TestMapFilterReduce(t *testing.T) {\n\tdoubled := Map([]int{1,2,3}, func(n int) int { return n * 2 })\n\tif doubled[0] != 2 || doubled[1] != 4 || doubled[2] != 6 { t.Error(\"map failed\") }\n\n\tevens := Filter([]int{1,2,3,4,5}, func(n int) bool { return n%2 == 0 })\n\tif len(evens) != 2 { t.Errorf(\"expected 2 evens, got %d\", len(evens)) }\n\n\tsum := Reduce([]int{1,2,3,4}, 0, func(acc, n int) int { return acc + n })\n\tif sum != 10 { t.Errorf(\"expected 10, got %d\", sum) }\n}",
      "language": "go",
      "description": "Generic map, filter, reduce for Go slices",
      "tags": [
        "functional",
        "generics",
        "slice",
        "go-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "9becd1def6000fcf",
      "name": "result-type-go",
      "code": "package main\n\ntype Result[T any] struct {\n\tValue T\n\tErr   error\n}\n\nfunc Ok[T any](value T) Result[T] {\n\treturn Result[T]{Value: value}\n}\n\nfunc Err[T any](err error) Result[T] {\n\treturn Result[T]{Err: err}\n}\n\nfunc (r Result[T]) IsOk() bool {\n\treturn r.Err == nil\n}\n\nfunc (r Result[T]) Unwrap() T {\n\tif r.Err != nil {\n\t\tpanic(r.Err)\n\t}\n\treturn r.Value\n}\n\nfunc (r Result[T]) UnwrapOr(fallback T) T {\n\tif r.Err != nil {\n\t\treturn fallback\n\t}\n\treturn r.Value\n}",
      "testCode": "package main\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestResult(t *testing.T) {\n\tok := Ok(42)\n\tif !ok.IsOk() { t.Error(\"expected ok\") }\n\tif ok.Unwrap() != 42 { t.Error(\"expected 42\") }\n\n\tfail := Err[int](errors.New(\"oops\"))\n\tif fail.IsOk() { t.Error(\"expected err\") }\n\tif fail.UnwrapOr(0) != 0 { t.Error(\"expected fallback 0\") }\n}",
      "language": "go",
      "description": "Rust-inspired Result type using Go generics",
      "tags": [
        "result",
        "error-handling",
        "generics",
        "go-native"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "c35afe6bd37161fc",
      "name": "worker-pool-go",
      "code": "package main\n\nimport \"sync\"\n\nfunc WorkerPool[T any, R any](workers int, jobs []T, fn func(T) R) []R {\n\tvar wg sync.WaitGroup\n\tresults := make([]R, len(jobs))\n\tch := make(chan int, len(jobs))\n\n\tfor i := range jobs {\n\t\tch <- i\n\t}\n\tclose(ch)\n\n\tfor w := 0; w < workers; w++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor idx := range ch {\n\t\t\t\tresults[idx] = fn(jobs[idx])\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Wait()\n\treturn results\n}",
      "testCode": "package main\n\nimport \"testing\"\n\nfunc TestWorkerPool(t *testing.T) {\n\tjobs := []int{1, 2, 3, 4, 5}\n\tresults := WorkerPool(3, jobs, func(n int) int { return n * 2 })\n\texpected := []int{2, 4, 6, 8, 10}\n\tfor i, v := range results {\n\t\tif v != expected[i] { t.Errorf(\"index %d: got %d, want %d\", i, v, expected[i]) }\n\t}\n}",
      "language": "go",
      "description": "Generic worker pool with goroutines and channels",
      "tags": [
        "concurrency",
        "goroutine",
        "worker-pool",
        "go-native"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "c24c5335aa0823c0",
      "name": "stack-go",
      "code": "package main\n\ntype Stack[T any] struct {\n\titems []T\n}\n\nfunc NewStack[T any]() *Stack[T] {\n\treturn &Stack[T]{items: make([]T, 0)}\n}\n\nfunc (s *Stack[T]) Push(item T) {\n\ts.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tif len(s.items) == 0 {\n\t\tvar zero T\n\t\treturn zero, false\n\t}\n\titem := s.items[len(s.items)-1]\n\ts.items = s.items[:len(s.items)-1]\n\treturn item, true\n}\n\nfunc (s *Stack[T]) Peek() (T, bool) {\n\tif len(s.items) == 0 {\n\t\tvar zero T\n\t\treturn zero, false\n\t}\n\treturn s.items[len(s.items)-1], true\n}\n\nfunc (s *Stack[T]) Len() int {\n\treturn len(s.items)\n}",
      "testCode": "package main\n\nimport \"testing\"\n\nfunc TestStack(t *testing.T) {\n\ts := NewStack[int]()\n\ts.Push(1)\n\ts.Push(2)\n\tif s.Len() != 2 { t.Errorf(\"expected len 2, got %d\", s.Len()) }\n\tv, ok := s.Pop()\n\tif !ok || v != 2 { t.Errorf(\"expected 2, got %d\", v) }\n\tv, ok = s.Peek()\n\tif !ok || v != 1 { t.Errorf(\"expected peek 1, got %d\", v) }\n\ts.Pop()\n\t_, ok = s.Pop()\n\tif ok { t.Error(\"expected false on empty pop\") }\n}",
      "language": "go",
      "description": "Generic stack using Go generics",
      "tags": [
        "data-structure",
        "stack",
        "generics",
        "go-native"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "3786126898c86733",
      "name": "type-guard-py",
      "code": "from typing import TypeGuard, Any, Union\n\ndef is_str_list(val: Any) -> TypeGuard[list[str]]:\n    return isinstance(val, list) and all(isinstance(x, str) for x in val)\n\ndef is_int(val: Any) -> TypeGuard[int]:\n    return isinstance(val, int) and not isinstance(val, bool)\n\ndef safe_cast(val: Any, target_type: type, default=None):\n    try:\n        return target_type(val)\n    except (ValueError, TypeError):\n        return default",
      "testCode": "assert is_str_list([\"a\", \"b\"]) == True\nassert is_str_list([1, 2]) == False\nassert is_str_list(\"not a list\") == False\nassert is_int(42) == True\nassert is_int(True) == False\nassert safe_cast(\"123\", int) == 123\nassert safe_cast(\"abc\", int, 0) == 0",
      "language": "python",
      "description": "Type guards and safe casting utilities",
      "tags": [
        "typing",
        "guard",
        "validation",
        "python-native"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "55a0ee08620b843f",
      "name": "generator-pipeline-py",
      "code": "def chunked(iterable, size):\n    chunk = []\n    for item in iterable:\n        chunk.append(item)\n        if len(chunk) == size:\n            yield chunk\n            chunk = []\n    if chunk:\n        yield chunk\n\ndef batched_map(iterable, fn, batch_size=100):\n    for batch in chunked(iterable, batch_size):\n        yield from (fn(item) for item in batch)",
      "testCode": "assert list(chunked([1,2,3,4,5], 2)) == [[1,2], [3,4], [5]]\nassert list(chunked([], 3)) == []\nassert list(batched_map([1,2,3], lambda x: x*2, 2)) == [2, 4, 6]",
      "language": "python",
      "description": "Generator-based chunking and batch processing pipeline",
      "tags": [
        "generator",
        "pipeline",
        "batch",
        "python-native"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0f32d3a4661c1657",
      "name": "context-manager-py",
      "code": "from contextlib import contextmanager\nimport time\n\n@contextmanager\ndef timer(label=\"elapsed\"):\n    start = time.perf_counter()\n    yield lambda: time.perf_counter() - start\n    elapsed = time.perf_counter() - start\n    print(f\"{label}: {elapsed:.4f}s\")",
      "testCode": "with timer(\"test\") as get_elapsed:\n    total = sum(range(1000))\n    assert get_elapsed() >= 0\nassert total == 499500",
      "language": "python",
      "description": "Context manager timer using contextlib",
      "tags": [
        "context-manager",
        "timer",
        "utility",
        "python-native"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7d9fc72ad3a90ffe",
      "name": "dataclass-builder-py",
      "code": "from dataclasses import dataclass, field, asdict\nfrom typing import List, Optional\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n    tags: List[str] = field(default_factory=list)\n    secret: Optional[str] = None\n\n    def to_dict(self):\n        return asdict(self)\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})",
      "testCode": "c = Config(host=\"0.0.0.0\", port=3000, tags=[\"api\"])\nassert c.host == \"0.0.0.0\"\nassert c.port == 3000\nd = c.to_dict()\nassert d[\"host\"] == \"0.0.0.0\"\nc2 = Config.from_dict({\"host\": \"prod\", \"port\": 443, \"extra\": \"ignored\"})\nassert c2.host == \"prod\"\nassert c2.debug == False",
      "language": "python",
      "description": "Dataclass with serialization and builder pattern",
      "tags": [
        "dataclass",
        "config",
        "builder",
        "python-native"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "e831e8a958e6a755",
      "name": "retry-decorator-py",
      "code": "import time\nimport functools\n\ndef retry(max_attempts=3, delay=1.0, backoff=2.0, exceptions=(Exception,)):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            current_delay = delay\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n            raise last_exception\n        return wrapper\n    return decorator",
      "testCode": "call_count = 0\n@retry(max_attempts=3, delay=0.01)\ndef flaky():\n    global call_count\n    call_count += 1\n    if call_count < 3:\n        raise ValueError(\"not yet\")\n    return \"ok\"\nassert flaky() == \"ok\"\nassert call_count == 3",
      "language": "python",
      "description": "Retry decorator with exponential backoff",
      "tags": [
        "decorator",
        "retry",
        "resilience",
        "python-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "cca83d1e4076937b",
      "name": "flatten-py",
      "code": "def flatten(lst, depth=-1):\n    result = []\n    for item in lst:\n        if isinstance(item, list) and depth != 0:\n            result.extend(flatten(item, depth - 1))\n        else:\n            result.append(item)\n    return result",
      "testCode": "assert flatten([1, [2, [3, [4]]]]) == [1, 2, 3, 4]\nassert flatten([1, [2, [3]]], depth=1) == [1, 2, [3]]\nassert flatten([]) == []\nassert flatten([[1], [2], [3]]) == [1, 2, 3]",
      "language": "python",
      "description": "Flatten nested lists with optional depth limit",
      "tags": [
        "list",
        "flatten",
        "utility",
        "python-native"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b1cf6468e93b0d80",
      "name": "merge-sort-py",
      "code": "def merge_sort(arr: list) -> list:\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return _merge(left, right)\n\ndef _merge(left: list, right: list) -> list:\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
      "testCode": "assert merge_sort([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5]\nassert merge_sort([]) == []\nassert merge_sort([1]) == [1]\nassert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]",
      "language": "python",
      "description": "Merge sort — stable O(n log n)",
      "tags": [
        "sort",
        "algorithm",
        "merge-sort",
        "python-native"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "662651367a407f84",
      "name": "defaultdict-counter-py",
      "code": "from collections import defaultdict\n\ndef word_frequency(text: str) -> dict:\n    freq = defaultdict(int)\n    for word in text.lower().split():\n        freq[word] += 1\n    return dict(sorted(freq.items(), key=lambda x: -x[1]))",
      "testCode": "result = word_frequency(\"the cat sat on the mat\")\nassert result[\"the\"] == 2\nassert result[\"cat\"] == 1\nassert list(result.keys())[0] == \"the\"",
      "language": "python",
      "description": "Word frequency counter using defaultdict",
      "tags": [
        "string",
        "counter",
        "frequency",
        "python-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "4e10c2a3f9915d83",
      "name": "lru-cache-py",
      "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
      "testCode": "cache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\nassert cache.get(3) == 3",
      "language": "python",
      "description": "LRU cache using OrderedDict — O(1) get/put",
      "tags": [
        "cache",
        "data-structure",
        "lru",
        "python-native"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "87aab8ca939bd2a5",
      "name": "stack",
      "code": "function Stack() {\n  this.items = [];\n}\nStack.prototype.push = function(item) { this.items.push(item); };\nStack.prototype.pop = function() { return this.items.pop(); };\nStack.prototype.peek = function() { return this.items[this.items.length - 1]; };\nStack.prototype.isEmpty = function() { return this.items.length === 0; };\nStack.prototype.size = function() { return this.items.length; };",
      "testCode": "var s = new Stack();\ns.push(1); s.push(2); s.push(3);\nif (s.peek() !== 3) throw new Error('peek');\nif (s.pop() !== 3) throw new Error('pop');\nif (s.size() !== 2) throw new Error('size');\nif (s.isEmpty()) throw new Error('not empty');",
      "language": "javascript",
      "description": "Stack with push, pop, peek operations",
      "tags": [
        "data-structure",
        "stack"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ed1f0488dfe07559",
      "name": "drop",
      "code": "function drop(arr, n) {\n  return arr.slice(n);\n}",
      "testCode": "if (JSON.stringify(drop([1,2,3,4], 2)) !== '[3,4]') throw new Error('basic');\nif (drop([], 5).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Drop first n elements from array",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f1f7fbada8585b56",
      "name": "lru-cache",
      "code": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}",
      "testCode": "const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");",
      "language": "javascript",
      "description": "LRU Cache using Map for O(1) get/set with eviction",
      "tags": [
        "data-structure",
        "cache",
        "lru",
        "map",
        "eviction"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "2be8d0ea0ffde6bf",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1d35aa67ced7c1a2",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "736d3b98696188f9",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a2e47ff48d624802",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d4b959d17b2a4261",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5e9685fbd9dacc90",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7b8ee359f1136943",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e4e2f2d64ce1ae59",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6b6abaf0743e2fca",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7658fb1f30f77833",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2d5627417dbbc299",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4003825818bc8576",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "db876dadf9960c37",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4ca93e2a2509ad8f",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8116fbb0cdee61ac",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e54fb38cb1320da2",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d62593e9606800b6",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "54267fdd23f5db0b",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8a9bd5632841a29b",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0d42eb543cb0d2c5",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1321bf1d6467399f",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "76b07b05d918d658",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4b8e072f42447a34",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1d933a9d05c440de",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4fa2ac6949d0fab3",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3f4063ff76e40b7c",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9aa04bdbe31d8a32",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d45fa7e1710912ed",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "caf221e82ce889c3",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "071ecb6c36044ca4",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5669ae4667cb06dc",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "403d45b32e91d078",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9866d95e3976a342",
      "name": "colors-refined",
      "code": "/**\n * Zero-dependency ANSI color helpers for CLI output.\n *\n * Colors are automatically disabled when:\n * - stdout is not a TTY (piped/redirected)\n * - NO_COLOR env var is set (https://no-color.org)\n * - --no-color flag is passed\n */\n\nconst enabled = process.stdout.isTTY && !process.env.NO_COLOR && !process.argv.includes('--no-color');\n\nconst codes = {\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underline: '\\x1b[4m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n  gray: '\\x1b[90m',\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n  bgBlue: '\\x1b[44m',\n};\n\nfunction wrap(code, text) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}\n\nconst c = {\n  bold: (t) => wrap(codes.bold, t),\n  dim: (t) => wrap(codes.dim, t),\n  red: (t) => wrap(codes.red, t),\n  green: (t) => wrap(codes.green, t),\n  yellow: (t) => wrap(codes.yellow, t),\n  blue: (t) => wrap(codes.blue, t),\n  magenta: (t) => wrap(codes.magenta, t),\n  cyan: (t) => wrap(codes.cyan, t),\n  white: (t) => wrap(codes.white, t),\n  gray: (t) => wrap(codes.gray, t),\n  boldGreen: (t) => wrap(codes.bold + codes.green, t),\n  boldRed: (t) => wrap(codes.bold + codes.red, t),\n  boldYellow: (t) => wrap(codes.bold + codes.yellow, t),\n  boldCyan: (t) => wrap(codes.bold + codes.cyan, t),\n  boldMagenta: (t) => wrap(codes.bold + codes.magenta, t),\n  boldBlue: (t) => wrap(codes.bold + codes.blue, t),\n};\n\n/**\n * Color a coherency score based on its value:\n *   >= 0.8  green (excellent)\n *   >= 0.6  yellow (decent)\n *   < 0.6   red (low)\n */\nfunction colorScore(score) {\n  if (score === null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}\n\n/**\n * Color a decision (PULL/EVOLVE/GENERATE).\n */\nfunction colorDecision(decision) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}\n\n/**\n * Color an accepted/rejected status.\n */\nfunction colorStatus(accepted) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}\n\n/**\n * Color a diff line.\n */\nfunction colorDiff(type, line) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}\n\n/**\n * Color a source tag (PAT/HIS).\n */\nfunction colorSource(source) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}\n\nmodule.exports = { c, colorScore, colorDecision, colorStatus, colorDiff, colorSource, enabled };\n",
      "testCode": "if (wrap(1, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(0, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(\"\", \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \" \") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"a\") === undefined) throw new Error(\"returned undefined\");",
      "language": "javascript",
      "description": "Harvested from . — src/cli/colors.js (12 functions) (refined)",
      "tags": [
        "enabled",
        "codes",
        "wrap",
        "c",
        "colorScore",
        "javascript",
        "harvested",
        "auto-refined",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "0390c0240724d5ee",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "22ca5d678f5b5dd9",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3d2757fe605fd5ea",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "48d6156aa5e8a57a",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "847102264621b390",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1c64f38b9d3707c4",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3ac1d71ae93a8394",
      "name": "ctx-test-fn-py",
      "code": "def ctx_test():\n    return 1",
      "testCode": "assert ctx_test() == 1",
      "language": "python",
      "description": " (Python variant)",
      "tags": [
        "test",
        "context",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "60a1afc7dfe45ae2",
      "name": "ctx-test-fn-ts",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "test",
        "context",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "64be490f8fee84cb",
      "name": "ctx-test-fn",
      "code": "function ctxTest() { return 1; }",
      "testCode": "if (ctxTest() !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test",
        "context"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c47e7a1dc05f41f1",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "64e3797ccb380e96",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "249df964f7aba1b4",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9cf8c99f215f34fe",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c7fdf2dbbea49372",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "eb11a9257b6efb21",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6915d1786ef36575",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c730b9612ffea2a9",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0747466d266ed3e5",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "873e1d3512f3a3c9",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4cb6a769cd97a66e",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ccfb2f676914d7d6",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8ce5d136797221b4",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "749304d0ce23e86c",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ee7654cda3aabb7f",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2f674f10a3ded7b9",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ec5ab4b8c233e0a4",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "17240eea97152b6f",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a65d3256722a2732",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9f579fbf2742709a",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "07cb9117b1187ce2",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "09866e8a8935d314",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "585648889addd8ef",
      "name": "rep-test-pattern-py",
      "code": "def rep_test():\n    return 99",
      "testCode": "assert rep_test() == 99",
      "language": "python",
      "description": " (Python variant)",
      "tags": [
        "test",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bc204f050a1eaa9f",
      "name": "rep-test-pattern-ts",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ba52587fffdc3f81",
      "name": "rep-weight-test-py",
      "code": "def weight_test():\n    return 100",
      "testCode": "assert weight_test() == 100",
      "language": "python",
      "description": " (Python variant)",
      "tags": [
        "test",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "066976bed33b44a1",
      "name": "rep-weight-test-ts",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "24eaf73c7e72a8db",
      "name": "rep-weight-test",
      "code": "function weightTest() { return 100; }",
      "testCode": "if (weightTest() !== 100) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "62ab141a8b8164c1",
      "name": "rep-test-pattern",
      "code": "function repTest() { return 99; }",
      "testCode": "if (repTest() !== 99) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "22736cca8dab72ea",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "89c8dff6a0378f07",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4a8a2730d874f565",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3436b94115c95e51",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "82cd191ac9c6544e",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e8b4f0a9335e07e8",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "a7d6de1494554e51",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ef66be36ec930483",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2f7528b8829c8dbe",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "69d1b36876a1adfc",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2c8bd03d4176f1be",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "50b12d9d21f1ed50",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "55c33d12cc3b5ead",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0c588da3666f0fb5",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2cecc0ec2024ff9e",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "943f0578c5e2b00c",
      "name": "vote-test-pattern-py",
      "code": "def vote_test():\n    return 42",
      "testCode": "assert vote_test() == 42",
      "language": "python",
      "description": " (Python variant)",
      "tags": [
        "test",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "231756d15dd096c3",
      "name": "vote-test-pattern-ts",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "19162dd8520b03fa",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d2c02b0a5ff19cf6",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8bcf9ef878797296",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0fd4bec1d5f1f9fb",
      "name": "vote-test-pattern",
      "code": "function voteTest() { return 42; }",
      "testCode": "if (voteTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "190e2982684a33c9",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9f2ad2b0a796055a",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4b51c0f56a9db470",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "48491773293d1e66",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e3610c2f0daae8c0",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d88eea7e06d7b335",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2ece3e1f09dc671f",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d4fe42c6ca369182",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bdf2afc01a29a86d",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d5f1acab820da4aa",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7517d5c2ff182e15",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "bebb8a4baa6dd132",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0ef40c69e76d5158",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "25893f07708ac542",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8adf68d861c02a27",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "7f5d341fe696418c",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2ff0375a7cd2090d",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "99708221f3da6693",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "256d230298dadd12",
      "name": "hover-test-fn-ts",
      "code": "function hoverTestFn(n: any) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "typescript",
      "description": "Increment (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d6d50129736fa000",
      "name": "def-test-ts",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "test",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3a41a279a60f2206",
      "name": "def-test",
      "code": "function defTest() { return 42; }",
      "testCode": "if (defTest() !== 42) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c30a1b2878ddab6c",
      "name": "hover-test-fn",
      "code": "function hoverTestFn(n) { return n + 1; }",
      "testCode": "if (hoverTestFn(0) !== 1) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Increment",
      "tags": [
        "test"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0ccb31bdecc26bbe",
      "name": "pub-sub",
      "code": "class PubSub {\n  constructor() { this._subs = new Map(); }\n  subscribe(topic, handler) {\n    if (!this._subs.has(topic)) this._subs.set(topic, new Set());\n    this._subs.get(topic).add(handler); var self = this;\n    return function() { var h = self._subs.get(topic); if(h){h.delete(handler);if(!h.size)self._subs.delete(topic)} };\n  }\n  publish(topic, data) {\n    for (var e of this._subs) { var p=e[0], h=e[1];\n      if (p===topic||p==='*'||(p.includes('*')&&new RegExp('^'+p.split('*').join('.*')+'$').test(topic)))\n        h.forEach(function(fn){fn(data,topic)});\n    }\n  }\n  topics() { return Array.from(this._subs.keys()); }\n}",
      "testCode": "var ps = new PubSub();\nvar msgs = [];\nvar unsub = ps.subscribe('chat', function(d){ msgs.push(d); });\nps.publish('chat', 'hello');\nps.publish('chat', 'world');\nif (msgs.length !== 2 || msgs[0] !== 'hello') throw new Error('basic pub/sub');\nunsub();\nps.publish('chat', 'gone');\nif (msgs.length !== 2) throw new Error('unsubscribe failed');\nvar wild = [];\nps.subscribe('*', function(d){ wild.push(d); });\nps.publish('anything', 'test');\nif (wild.length !== 1) throw new Error('wildcard');\nif (!ps.topics().includes('*')) throw new Error('topics list');",
      "language": "javascript",
      "description": "Publish-subscribe system with wildcard topic matching and unsubscribe support",
      "tags": [
        "pub-sub",
        "pubsub",
        "event",
        "design-pattern",
        "message",
        "wildcard",
        "topic"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "4a3e8c40df7adfa7",
      "name": "bloom-filter",
      "code": "class BloomFilter {\n  constructor(size, hashCount) { this.size = size; this.hashCount = hashCount; this.bits = new Uint8Array(size); this.count = 0; }\n  _hashes(item) {\n    var s = String(item), idx = [];\n    for (var i = 0; i < this.hashCount; i++) {\n      var h = 0; for (var j = 0; j < s.length; j++) h = ((h << 5) - h + s.charCodeAt(j) * (i+1)) | 0;\n      idx.push(Math.abs(h) % this.size);\n    } return idx;\n  }\n  add(item) { var b = this.bits; this._hashes(item).forEach(function(i){b[i]=1}); this.count++; }\n  mightContain(item) { var b = this.bits; return this._hashes(item).every(function(i){return b[i]===1}); }\n  falsePositiveRate() {\n    var s = 0; for (var i = 0; i < this.size; i++) if (this.bits[i]) s++;\n    return Math.pow(s / this.size, this.hashCount);\n  }\n}",
      "testCode": "var bf = new BloomFilter(1000, 3);\nbf.add('hello'); bf.add('world');\nif (!bf.mightContain('hello')) throw new Error('added item missing');\nif (!bf.mightContain('world')) throw new Error('second item missing');\nvar fp = 0;\nfor (var i = 0; i < 100; i++) { if (bf.mightContain('test' + i)) fp++; }\nif (fp > 20) throw new Error('too many false positives: ' + fp);\nvar rate = bf.falsePositiveRate();\nif (typeof rate !== 'number' || rate < 0 || rate > 1) throw new Error('rate out of bounds');",
      "language": "javascript",
      "description": "Bloom filter with configurable size and hash count for probabilistic membership testing",
      "tags": [
        "bloom-filter",
        "data-structure",
        "probabilistic",
        "set",
        "hash",
        "membership"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "8211dab28543bfd5",
      "name": "dependency-injection",
      "code": "class DIContainer {\n  constructor() { this._reg = new Map(); this._sing = new Map(); }\n  register(name, factory, opts) {\n    this._reg.set(name, { factory: factory, singleton: !!(opts && opts.singleton) });\n    this._sing.delete(name); return this;\n  }\n  resolve(name) {\n    if (!this._reg.has(name)) throw new Error(name + ' not registered');\n    var e = this._reg.get(name);\n    if (e.singleton) { if (!this._sing.has(name)) this._sing.set(name, e.factory(this)); return this._sing.get(name); }\n    return e.factory(this);\n  }\n  has(name) { return this._reg.has(name); }\n}",
      "testCode": "var c = new DIContainer();\nc.register('config', function(){ return { port: 3000 }; }, { singleton: true });\nc.register('logger', function(){ return { log: function(){} }; });\nvar cfg1 = c.resolve('config');\nvar cfg2 = c.resolve('config');\nif (cfg1 !== cfg2) throw new Error('singleton should return same instance');\nvar l1 = c.resolve('logger');\nvar l2 = c.resolve('logger');\nif (l1 === l2) throw new Error('non-singleton should return new instance');\nif (!c.has('config') || c.has('missing')) throw new Error('has check');\ntry { c.resolve('missing'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "javascript",
      "description": "Dependency injection container with singleton support and factory resolution",
      "tags": [
        "di",
        "dependency-injection",
        "container",
        "ioc",
        "design-pattern",
        "factory",
        "singleton"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "06f080376bac94e2",
      "name": "stream-pipeline",
      "code": "class StreamPipeline {\n  constructor() { this.transforms = []; }\n  pipe(transformFn) { this.transforms.push(transformFn); return this; }\n  async process(input) {\n    var result = input;\n    for (var i = 0; i < this.transforms.length; i++) {\n      result = await Promise.resolve(this.transforms[i](result));\n    }\n    return result;\n  }\n  get length() { return this.transforms.length; }\n  reset() { this.transforms = []; return this; }\n}",
      "testCode": "var p = new StreamPipeline();\np.pipe(function(x){return x*2}).pipe(function(x){return x+1}).pipe(function(x){return String(x)});\nvar r = await p.process(5);\nif (r !== '11') throw new Error('chain result: ' + r);\nvar p2 = new StreamPipeline();\np2.pipe(async function(x){return x.toUpperCase()}).pipe(function(x){return x+'!'});\nvar r2 = await p2.process('hello');\nif (r2 !== 'HELLO!') throw new Error('async transform');\nif (p.length !== 3) throw new Error('length');\nvar p3 = new StreamPipeline();\nif (await p3.process(42) !== 42) throw new Error('empty pipeline');",
      "language": "javascript",
      "description": "Chainable transform pipeline with sync and async function support",
      "tags": [
        "stream",
        "pipeline",
        "transform",
        "chain",
        "async",
        "io",
        "functional"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "6f49a0e57895bb95",
      "name": "request-validator",
      "code": "class RequestValidator {\n  constructor(schema) { this.schema = schema; }\n  validate(data) {\n    var errors = [];\n    for (var f of Object.keys(this.schema)) { var r = this.schema[f], v = data[f];\n      if (r.required && (v == null || v === '')) { errors.push(f+' is required'); continue; }\n      if (v == null) continue;\n      if (r.type && typeof v !== r.type) errors.push(f+' must be type '+r.type);\n      if (r.min != null && v < r.min) errors.push(f+' must be >= '+r.min);\n      if (r.max != null && v > r.max) errors.push(f+' must be <= '+r.max);\n      if (r.pattern && !r.pattern.test(String(v))) errors.push(f+' format invalid');\n      if (r.enum && !r.enum.includes(v)) errors.push(f+' must be one of: '+r.enum.join(', '));\n    }\n    return { valid: errors.length === 0, errors: errors };\n  }\n}",
      "testCode": "var v = new RequestValidator({\n  name: { type: 'string', required: true },\n  age: { type: 'number', min: 0, max: 150 },\n  role: { enum: ['admin', 'user'] }\n});\nvar r1 = v.validate({ name: 'Alice', age: 30, role: 'admin' });\nif (!r1.valid) throw new Error('valid data failed');\nvar r2 = v.validate({});\nif (r2.valid || r2.errors.length === 0) throw new Error('missing required passed');\nvar r3 = v.validate({ name: 'Bob', age: -1 });\nif (r3.valid) throw new Error('below min passed');\nvar r4 = v.validate({ name: 'X', role: 'superadmin' });\nif (r4.valid) throw new Error('invalid enum passed');",
      "language": "javascript",
      "description": "Schema-based request validator with type, range, pattern, and enum checks",
      "tags": [
        "validation",
        "schema",
        "request",
        "form",
        "input",
        "sanitize"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "9af25ae3ee5f0c11",
      "name": "worker-pool",
      "code": "class WorkerPool {\n  constructor(size) { this.size = size; this.current = 0; this.active = 0; this.completed = 0; this.failed = 0; this._off = false; }\n  async exec(task) {\n    if (this._off) throw new Error('Pool is shut down');\n    var w = this.current; this.current = (this.current + 1) % this.size; this.active++;\n    try { var r = await Promise.resolve(task(w)); this.completed++; return r; }\n    catch (e) { this.failed++; throw e; } finally { this.active--; }\n  }\n  stats() { return { size: this.size, active: this.active, completed: this.completed, failed: this.failed }; }\n  shutdown() { this._off = true; }\n}",
      "testCode": "var pool = new WorkerPool(2);\nvar results = [];\nawait pool.exec(function(w) { results.push('a' + w); });\nawait pool.exec(function(w) { results.push('b' + w); });\nawait pool.exec(function(w) { results.push('c' + w); });\nif (results[0] !== 'a0') throw new Error('first worker');\nif (results[1] !== 'b1') throw new Error('round-robin');\nif (results[2] !== 'c0') throw new Error('wrap around');\nif (pool.stats().completed !== 3) throw new Error('completed count');\npool.shutdown();\ntry { await pool.exec(function(){}); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "javascript",
      "description": "Worker pool with round-robin dispatch, stats tracking, and graceful shutdown",
      "tags": [
        "concurrency",
        "pool",
        "worker",
        "async",
        "round-robin",
        "task-queue"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "006ab172fdec43f7",
      "name": "middleware-chain",
      "code": "class MiddlewareChain {\n  constructor() { this._middlewares = []; }\n  use(fn) {\n    this._middlewares.push(fn);\n    return this;\n  }\n  execute(context) {\n    let index = 0;\n    const next = () => {\n      if (index >= this._middlewares.length) return Promise.resolve();\n      const fn = this._middlewares[index++];\n      return Promise.resolve(fn(context, next));\n    };\n    return next();\n  }\n}",
      "testCode": "const chain = new MiddlewareChain();\nconst order = [];\nchain.use(async (ctx, next) => { order.push('a'); ctx.a = 1; await next(); order.push('a2'); });\nchain.use(async (ctx, next) => { order.push('b'); ctx.b = 2; await next(); });\nconst ctx = {};\nawait chain.execute(ctx);\nif (ctx.a !== 1 || ctx.b !== 2) throw new Error('middleware should modify context');\nif (order.join(',') !== 'a,b,a2') throw new Error('should execute in onion order: ' + order);\nconst empty = new MiddlewareChain();\nawait empty.execute({});",
      "language": "javascript",
      "description": "Express-style middleware chain with async next() calling and context passing",
      "tags": [
        "middleware",
        "chain",
        "pipeline",
        "design-pattern",
        "express",
        "compose"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e85013c9c2dd1657",
      "name": "promise-queue",
      "code": "class PromiseQueue {\n  constructor(concurrency = 1) {\n    this._c = concurrency; this._q = []; this._p = 0;\n  }\n  add(fn) {\n    return new Promise((resolve, reject) => {\n      this._q.push({ fn, resolve, reject }); this._run();\n    });\n  }\n  _run() {\n    while (this._p < this._c && this._q.length) {\n      const t = this._q.shift(); this._p++;\n      Promise.resolve(t.fn()).then(\n        v => { this._p--; t.resolve(v); this._run(); },\n        e => { this._p--; t.reject(e); this._run(); }\n      );\n    }\n  }\n  size() { return this._q.length; }\n  pending() { return this._p; }\n}",
      "testCode": "const q = new PromiseQueue(2);\nconst order = [];\nconst task = (id, ms) => () => new Promise(r => setTimeout(() => { order.push(id); r(id); }, ms));\nconst p1 = q.add(task('a', 50));\nconst p2 = q.add(task('b', 30));\nconst p3 = q.add(task('c', 10));\nif (q.pending() !== 2) throw new Error('should have 2 pending');\nif (q.size() !== 1) throw new Error('should have 1 queued');\nconst results = await Promise.all([p1, p2, p3]);\nif (results.join(',') !== 'a,b,c') throw new Error('should resolve with correct values');",
      "language": "javascript",
      "description": "Concurrency-limited promise queue that processes async tasks with bounded parallelism",
      "tags": [
        "queue",
        "promise",
        "concurrency",
        "async",
        "task-queue",
        "parallel"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "4ba31da82c95bcdd",
      "name": "semaphore",
      "code": "class Semaphore {\n  constructor(permits) {\n    this._permits = permits;\n    this._max = permits;\n    this._queue = [];\n  }\n  acquire() {\n    if (this._permits > 0) {\n      this._permits--;\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this._queue.push(resolve));\n  }\n  release() {\n    if (this._queue.length > 0) {\n      this._queue.shift()();\n    } else if (this._permits < this._max) {\n      this._permits++;\n    }\n  }\n  available() {\n    return this._permits;\n  }\n}",
      "testCode": "const sem = new Semaphore(2);\nif (sem.available() !== 2) throw new Error('should start with 2 permits');\nawait sem.acquire();\nif (sem.available() !== 1) throw new Error('should have 1 after acquire');\nawait sem.acquire();\nif (sem.available() !== 0) throw new Error('should have 0 after 2 acquires');\nlet acquired = false;\nconst pending = sem.acquire().then(() => { acquired = true; });\nsem.release();\nawait pending;\nif (!acquired) throw new Error('should acquire after release');",
      "language": "javascript",
      "description": "Counting semaphore with async acquire and bounded permits",
      "tags": [
        "semaphore",
        "concurrency",
        "async",
        "locking",
        "permits"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "2aceaf2f5d64766d",
      "name": "rate-limiter",
      "code": "class RateLimiter {\n  constructor(maxTokens, refillRate) {\n    this.max = maxTokens;\n    this.tokens = maxTokens;\n    this.rate = refillRate;\n    this.last = Date.now();\n  }\n  _refill() {\n    const now = Date.now();\n    this.tokens = Math.min(this.max, this.tokens + (now - this.last) / 1000 * this.rate);\n    this.last = now;\n  }\n  consume(tokens = 1) {\n    this._refill();\n    if (this.tokens >= tokens) { this.tokens -= tokens; return true; }\n    return false;\n  }\n  remainingTokens() {\n    this._refill();\n    return Math.floor(this.tokens);\n  }\n}",
      "testCode": "const limiter = new RateLimiter(5, 1);\nif (!limiter.consume(1)) throw new Error('should consume 1 token');\nif (!limiter.consume(4)) throw new Error('should consume remaining 4 tokens');\nif (limiter.consume(1)) throw new Error('should reject when exhausted');\nif (limiter.remainingTokens() !== 0) throw new Error('should have 0 remaining');\nconst l2 = new RateLimiter(3, 10);\nif (!l2.consume(2)) throw new Error('should consume 2 of 3');",
      "language": "javascript",
      "description": "Token bucket rate limiter with configurable max tokens and refill rate per second",
      "tags": [
        "rate-limit",
        "throttle",
        "token-bucket",
        "concurrency",
        "rate-limiter"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "916509ce042d90fe",
      "name": "convertName-ts",
      "code": "function convertName(name: string, targetLanguage: any) {\n  if (targetLanguage === 'python') {\n    return name.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n      .toLowerCase();\n  }\n  if (targetLanguage === 'go') {\n    return name.charAt(0).toUpperCase() + name.slice(1);\n  }\n  return name;\n}",
      "testCode": "\nif (convertName('getUserData', 'python') !== 'get_user_data') throw new Error('python fail');\nif (convertName('parseJSON', 'python') !== 'parse_json') throw new Error('python2 fail');\nif (convertName('getUser', 'go') !== 'GetUser') throw new Error('go fail');\nif (convertName('test', 'javascript') !== 'test') throw new Error('js fail');\n",
      "language": "typescript",
      "description": "Convert function name to target language naming conventions (snake_case, PascalCase) (TypeScript variant)",
      "tags": [
        "naming",
        "convention",
        "transpiler",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "698941dd0f1d31a9",
      "name": "extractCodeBlock-ts",
      "code": "function extractCodeBlock(response: string, language: any) {\n  if (!response) return null;\n  const langPattern = new RegExp('```(?:' + (language || '\\\\w+') + ')?\\\\s*\\\\n([\\\\s\\\\S]*?)```', 'i');\n  const match = response.match(langPattern);\n  if (match) return match[1].trim();\n  const genericMatch = response.match(/```\\w*\\s*\\n([\\s\\S]*?)```/);\n  if (genericMatch) return genericMatch[1].trim();\n  const trimmed = response.trim();\n  if (trimmed.length > 0 && !trimmed.startsWith('Here') && !trimmed.startsWith('This') &&\n      !trimmed.startsWith('The ') && !trimmed.startsWith('I ')) {\n    return trimmed;\n  }\n  return null;\n}",
      "testCode": "\nconst code = extractCodeBlock('```javascript\\nfunction add(a, b) { return a + b; }\\n```', 'javascript');\nif (code !== 'function add(a, b) { return a + b; }') throw new Error('failed');\nif (extractCodeBlock(null, 'js') !== null) throw new Error('null check failed');\nif (extractCodeBlock('', 'js') !== null) throw new Error('empty check failed');\n",
      "language": "typescript",
      "description": "Extract code from LLM response markdown code blocks (TypeScript variant)",
      "tags": [
        "llm",
        "parser",
        "code-extraction",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b42e87ef195775bf",
      "name": "convertName",
      "code": "function convertName(name, targetLanguage) {\n  if (targetLanguage === 'python') {\n    return name.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n      .toLowerCase();\n  }\n  if (targetLanguage === 'go') {\n    return name.charAt(0).toUpperCase() + name.slice(1);\n  }\n  return name;\n}",
      "testCode": "\nif (convertName('getUserData', 'python') !== 'get_user_data') throw new Error('python fail');\nif (convertName('parseJSON', 'python') !== 'parse_json') throw new Error('python2 fail');\nif (convertName('getUser', 'go') !== 'GetUser') throw new Error('go fail');\nif (convertName('test', 'javascript') !== 'test') throw new Error('js fail');\n",
      "language": "javascript",
      "description": "Convert function name to target language naming conventions (snake_case, PascalCase)",
      "tags": [
        "naming",
        "convention",
        "transpiler",
        "utility"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "492ce97145730738",
      "name": "extractCodeBlock",
      "code": "function extractCodeBlock(response, language) {\n  if (!response) return null;\n  const langPattern = new RegExp('```(?:' + (language || '\\\\w+') + ')?\\\\s*\\\\n([\\\\s\\\\S]*?)```', 'i');\n  const match = response.match(langPattern);\n  if (match) return match[1].trim();\n  const genericMatch = response.match(/```\\w*\\s*\\n([\\s\\S]*?)```/);\n  if (genericMatch) return genericMatch[1].trim();\n  const trimmed = response.trim();\n  if (trimmed.length > 0 && !trimmed.startsWith('Here') && !trimmed.startsWith('This') &&\n      !trimmed.startsWith('The ') && !trimmed.startsWith('I ')) {\n    return trimmed;\n  }\n  return null;\n}",
      "testCode": "\nconst code = extractCodeBlock('```javascript\\nfunction add(a, b) { return a + b; }\\n```', 'javascript');\nif (code !== 'function add(a, b) { return a + b; }') throw new Error('failed');\nif (extractCodeBlock(null, 'js') !== null) throw new Error('null check failed');\nif (extractCodeBlock('', 'js') !== null) throw new Error('empty check failed');\n",
      "language": "javascript",
      "description": "Extract code from LLM response markdown code blocks",
      "tags": [
        "llm",
        "parser",
        "code-extraction",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "9622ffaec95a8b09",
      "name": "hover-test-fn-py",
      "code": "def hover_test_fn(n):\n    return n + 1",
      "testCode": "assert hover_test_fn(0) == 1",
      "language": "python",
      "description": "Increment (Python variant)",
      "tags": [
        "test",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5d999292bbacad8d",
      "name": "def-test-py",
      "code": "def def_test():\n    return 42",
      "testCode": "assert def_test() == 42",
      "language": "python",
      "description": " (Python variant)",
      "tags": [
        "test",
        "variant",
        "python",
        "auto-generated"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "2a6f9f4ebde83127",
      "name": "zip-arrays-v2-ts",
      "code": "function zipArrays(a: any[], b: any[]) {\n  const len = Math.min(a.length, b.length);\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result.push([a[i], b[i]]);\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(zipArrays([1,2],[3,4])) !== '[[1,3],[2,4]]') throw new Error('fail');\nif (zipArrays([],[]).length !== 0) throw new Error('fail');",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "utility",
        "array",
        "zip",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "5ff38b510705f219",
      "name": "zip-arrays-v2",
      "code": "function zipArrays(a, b) {\n  const len = Math.min(a.length, b.length);\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result.push([a[i], b[i]]);\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(zipArrays([1,2],[3,4])) !== '[[1,3],[2,4]]') throw new Error('fail');\nif (zipArrays([],[]).length !== 0) throw new Error('fail');",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility",
        "array",
        "zip"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e06b849850d735dd",
      "name": "demo-clamp-ts",
      "code": "function clamp(val: any, min: number, max: number) { return Math.min(Math.max(val, min), max); }",
      "testCode": "if (clamp(5, 0, 10) !== 5) throw new Error(\"fail\"); if (clamp(-1, 0, 10) !== 0) throw new Error(\"fail\"); if (clamp(15, 0, 10) !== 10) throw new Error(\"fail\");",
      "language": "typescript",
      "description": "Clamp a value between min and max (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "d81956fa156db85c",
      "name": "demo-clamp",
      "code": "function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }",
      "testCode": "if (clamp(5, 0, 10) !== 5) throw new Error(\"fail\"); if (clamp(-1, 0, 10) !== 0) throw new Error(\"fail\"); if (clamp(15, 0, 10) !== 10) throw new Error(\"fail\");",
      "language": "javascript",
      "description": "Clamp a value between min and max",
      "tags": [
        "math",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "0cb3258f372ad926",
      "name": "drop-py",
      "code": "def drop(arr, n):\n    return arr[n:]",
      "testCode": "assert drop([1,2,3,4], 2) == [3,4]\nassert len(drop([], 5)) == 0",
      "language": "python",
      "description": "Drop first n elements from array (Python variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6214bb0dae780dea",
      "name": "take-py",
      "code": "def take(arr, n):\n    return arr[0:n]",
      "testCode": "assert take([1,2,3,4], 2) == [1,2]\nassert len(take([], 5)) == 0\nassert take([1,2], 5) == [1,2]",
      "language": "python",
      "description": "Take first n elements from array (Python variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "743c5ac177df81b3",
      "name": "lerp-py",
      "code": "def lerp(a, b, t):\n    return a + (b - a) * t",
      "testCode": "assert lerp(0, 10, 0.5) == 5\nassert lerp(0, 10, 0) == 0\nassert lerp(0, 10, 1) == 10",
      "language": "python",
      "description": "Linear interpolation between two values (Python variant)",
      "tags": [
        "math",
        "utility",
        "animation",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "aab44350908ae462",
      "name": "last-py",
      "code": "def last(arr):\n    return arr[len(arr) - 1] if len(arr) > 0 else None",
      "testCode": "assert last([1,2,3]) == 3\nassert last([]) == None\nassert last([42]) == 42",
      "language": "python",
      "description": "Get last element of array (Python variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e87f06dce1389a92",
      "name": "priority-queue-refined-ts",
      "code": "function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  let i = this.heap.length - 1;\n  while (i > 0) {\n    const p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    let t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return;\n  const top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    let i = 0, n = this.heap.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      let t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};",
      "testCode": "var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');",
      "language": "typescript",
      "description": "Priority queue using min-heap (refined) (TypeScript variant)",
      "tags": [
        "data-structure",
        "priority-queue",
        "heap",
        "auto-refined",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "8ee09c114d48f15b",
      "name": "min-heap-refined-ts",
      "code": "function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  let i = this.data.length - 1;\n  while (i > 0) {\n    const p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    let t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return;\n  const min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    let i = 0, n = this.data.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      let t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };",
      "testCode": "var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');",
      "language": "typescript",
      "description": "Min-heap with insert and extractMin (refined) (TypeScript variant)",
      "tags": [
        "data-structure",
        "heap",
        "priority-queue",
        "auto-refined",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "15b54f1c5aaf1609",
      "name": "min-heap-ts-refined",
      "code": "function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  let i = this.data.length - 1;\n  while (i > 0) {\n    let p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    let t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return;\n  let min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    let i = 0, n = this.data.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      let t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };",
      "testCode": "var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');",
      "language": "typescript",
      "description": "Min-heap with insert and extractMin (TypeScript variant) (refined)",
      "tags": [
        "data-structure",
        "heap",
        "priority-queue",
        "variant",
        "typescript",
        "auto-refined"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "d527af222b2daef3",
      "name": "priority-queue-ts-refined",
      "code": "function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  let i = this.heap.length - 1;\n  while (i > 0) {\n    let p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    let t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return;\n  let top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    let i = 0, n = this.heap.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      let t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};",
      "testCode": "var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');",
      "language": "typescript",
      "description": "Priority queue using min-heap (TypeScript variant) (refined)",
      "tags": [
        "data-structure",
        "priority-queue",
        "heap",
        "variant",
        "typescript",
        "auto-refined"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "4807aeb76a9008de",
      "name": "chunk-ts",
      "code": "function chunk(arr: any[], size: number) {\n  let result = [];\n  for (let i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(chunk([1,2,3,4,5], 2)) !== '[[1,2],[3,4],[5]]') throw new Error('basic');\nif (JSON.stringify(chunk([], 3)) !== '[]') throw new Error('empty');\nif (JSON.stringify(chunk([1], 5)) !== '[[1]]') throw new Error('small');",
      "language": "typescript",
      "description": "Split array into chunks of given size (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "1886b80f54dc96d5",
      "name": "compact-ts",
      "code": "function compact(arr: any) {\n  return arr.filter(Boolean);\n}",
      "testCode": "var r = compact([0, 1, false, 2, '', 3, null, undefined]);\nif (JSON.stringify(r) !== '[1,2,3]') throw new Error('basic: ' + JSON.stringify(r));\nif (compact([]).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Remove falsy values from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "filter",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c5ae0d0ec340ec51",
      "name": "difference-ts",
      "code": "function difference(a: any, b: any) {\n  let set = new Set(b);\n  return a.filter(function(x) { return !set.has(x); });\n}",
      "testCode": "if (JSON.stringify(difference([1,2,3], [2,3,4])) !== '[1]') throw new Error('basic');\nif (difference([1,2], [1,2]).length !== 0) throw new Error('same');\nif (JSON.stringify(difference([1,2,3], [])) !== '[1,2,3]') throw new Error('empty b');",
      "language": "typescript",
      "description": "Get items in first array not in second (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "set",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "a0d7a7042b569b1f",
      "name": "intersection-ts",
      "code": "function intersection(a: any, b: any) {\n  let set = new Set(b);\n  return a.filter(function(x) { return set.has(x); });\n}",
      "testCode": "if (JSON.stringify(intersection([1,2,3], [2,3,4])) !== '[2,3]') throw new Error('basic');\nif (intersection([1,2], [3,4]).length !== 0) throw new Error('none');",
      "language": "typescript",
      "description": "Get items present in both arrays (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "set",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "e2d725afdc44a4f7",
      "name": "union-ts",
      "code": "function union(a: any, b: any) {\n  return Array.from(new Set(a.concat(b)));\n}",
      "testCode": "var r = union([1,2,3], [2,3,4]);\nif (JSON.stringify(r.sort()) !== '[1,2,3,4]') throw new Error('basic');\nif (union([], []).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Get unique items from both arrays (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "set",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "3b9ecfd439568c3a",
      "name": "zip-ts",
      "code": "function zip() {\n  let arrays = Array.prototype.slice.call(arguments);\n  let len = Math.min.apply(null, arrays.map(function(a) { return a.length; }));\n  let result = [];\n  for (let i = 0; i < len; i++) result.push(arrays.map(function(a) { return a[i]; }));\n  return result;\n}",
      "testCode": "var r = zip([1,2,3], ['a','b','c']);\nif (JSON.stringify(r) !== '[[1,\"a\"],[2,\"b\"],[3,\"c\"]]') throw new Error('basic');\nif (zip([1], [2,3]).length !== 1) throw new Error('unequal');",
      "language": "typescript",
      "description": "Zip multiple arrays into array of tuples (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "6e236cafe8cb7e64",
      "name": "unzip-ts",
      "code": "function unzip(pairs: any[]) {\n  if (!pairs.length) return [];\n  return pairs[0].map(function(_, i) {\n    return pairs.map(function(p) { return p[i]; });\n  });\n}",
      "testCode": "var r = unzip([[1,'a'],[2,'b'],[3,'c']]);\nif (JSON.stringify(r) !== '[[1,2,3],[\"a\",\"b\",\"c\"]]') throw new Error('basic');\nif (unzip([]).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Unzip array of tuples into separate arrays (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "2c14bd856dd6a1f6",
      "name": "range-ts",
      "code": "function range(start: number, end: number, step: any) {\n  step = step || 1;\n  let result = [];\n  if (step > 0) { for (let i = start; i < end; i += step) result.push(i); }\n  else { for (let i = start; i > end; i += step) result.push(i); }\n  return result;\n}",
      "testCode": "if (JSON.stringify(range(0, 5)) !== '[0,1,2,3,4]') throw new Error('basic');\nif (JSON.stringify(range(0, 10, 2)) !== '[0,2,4,6,8]') throw new Error('step');\nif (JSON.stringify(range(5, 0, -1)) !== '[5,4,3,2,1]') throw new Error('neg');",
      "language": "typescript",
      "description": "Generate array of numbers in range (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "generator",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "ce60011ec196c54a",
      "name": "unique-ts",
      "code": "function unique(arr: any) {\n  return Array.from(new Set(arr));\n}",
      "testCode": "if (JSON.stringify(unique([1,2,2,3,3,3])) !== '[1,2,3]') throw new Error('basic');\nif (unique([]).length !== 0) throw new Error('empty');\nif (unique([1]).length !== 1) throw new Error('single');",
      "language": "typescript",
      "description": "Get unique values from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "set",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "cd9cc1aba621b8ed",
      "name": "partition-ts",
      "code": "function partition(arr: any[], fn: Function) {\n  let pass = [], fail = [];\n  for (let i = 0; i < arr.length; i++) {\n    (fn(arr[i]) ? pass : fail).push(arr[i]);\n  }\n  return [pass, fail];\n}",
      "testCode": "var r = partition([1,2,3,4,5], function(n) { return n % 2 === 0; });\nif (JSON.stringify(r[0]) !== '[2,4]') throw new Error('evens');\nif (JSON.stringify(r[1]) !== '[1,3,5]') throw new Error('odds');",
      "language": "typescript",
      "description": "Split array into two based on predicate (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "394ea511d1e44003",
      "name": "take-ts",
      "code": "function take(arr: any, n: any) {\n  return arr.slice(0, n);\n}",
      "testCode": "if (JSON.stringify(take([1,2,3,4], 2)) !== '[1,2]') throw new Error('basic');\nif (take([], 5).length !== 0) throw new Error('empty');\nif (JSON.stringify(take([1,2], 5)) !== '[1,2]') throw new Error('over');",
      "language": "typescript",
      "description": "Take first n elements from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "cc13acb1c5a82848",
      "name": "drop-ts",
      "code": "function drop(arr: any, n: any) {\n  return arr.slice(n);\n}",
      "testCode": "if (JSON.stringify(drop([1,2,3,4], 2)) !== '[3,4]') throw new Error('basic');\nif (drop([], 5).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Drop first n elements from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "ae475872e12ea1d6",
      "name": "last-ts",
      "code": "function last(arr: any[]) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}",
      "testCode": "if (last([1,2,3]) !== 3) throw new Error('basic');\nif (last([]) !== undefined) throw new Error('empty');\nif (last([42]) !== 42) throw new Error('single');",
      "language": "typescript",
      "description": "Get last element of array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b32b8d1a414d8b57",
      "name": "without-ts",
      "code": "function without(arr: any) {\n  let values = Array.prototype.slice.call(arguments, 1);\n  let set = new Set(values);\n  return arr.filter(function(x) { return !set.has(x); });\n}",
      "testCode": "if (JSON.stringify(without([1,2,3,4], 2, 4)) !== '[1,3]') throw new Error('basic');\nif (without([1,1,1], 1).length !== 0) throw new Error('all');",
      "language": "typescript",
      "description": "Remove specified values from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "filter",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "fe40c67e1291cb63",
      "name": "sample-array-ts",
      "code": "function sampleArray(arr: any, n: any) {\n  let shuffled = arr.slice();\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    let tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;\n  }\n  return shuffled.slice(0, n || 1);\n}",
      "testCode": "var s = sampleArray([1,2,3,4,5], 3);\nif (s.length !== 3) throw new Error('length');\nif (!s.every(function(x) { return [1,2,3,4,5].indexOf(x) >= 0; })) throw new Error('items');\nif (sampleArray([], 3).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Get random sample of n items from array (TypeScript variant)",
      "tags": [
        "array",
        "utility",
        "random",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "465912751067c968",
      "name": "defaults-ts",
      "code": "function defaults(obj: any[]) {\n  for (let i = 1; i < arguments.length; i++) {\n    let source = arguments[i];\n    for (let key in source) {\n      if (source.hasOwnProperty(key) && obj[key] === undefined) {\n        obj[key] = source[key];\n      }\n    }\n  }\n  return obj;\n}",
      "testCode": "var r = defaults({a:1}, {a:9, b:2}, {c:3});\nif (r.a !== 1) throw new Error('no override');\nif (r.b !== 2) throw new Error('added b');\nif (r.c !== 3) throw new Error('added c');",
      "language": "typescript",
      "description": "Set default values without overriding existing (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "ff4aca2868d4ee0b",
      "name": "freeze-deep-ts",
      "code": "function freezeDeep(obj: any[]) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function(key) {\n    if (obj[key] && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {\n      freezeDeep(obj[key]);\n    }\n  });\n  return obj;\n}",
      "testCode": "var o = freezeDeep({a:1, b:{c:2}});\nif (!Object.isFrozen(o)) throw new Error('frozen');\nif (!Object.isFrozen(o.b)) throw new Error('deep frozen');",
      "language": "typescript",
      "description": "Recursively freeze object (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "immutable",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e43249a7df03ab17",
      "name": "has-path-ts",
      "code": "function hasPath(obj: Record<string, any>, path: string) {\n  let keys = path.split('.');\n  let current = obj;\n  for (let i = 0; i < keys.length; i++) {\n    if (current == null || !current.hasOwnProperty(keys[i])) return false;\n    current = current[keys[i]];\n  }\n  return true;\n}",
      "testCode": "if (!hasPath({a:{b:{c:1}}}, 'a.b.c')) throw new Error('deep');\nif (hasPath({a:1}, 'a.b')) throw new Error('missing');\nif (hasPath({}, 'x')) throw new Error('empty');",
      "language": "typescript",
      "description": "Check if object has nested path (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "path",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "791e9f0f6c4012bf",
      "name": "clamp-ts",
      "code": "function clamp(val: any, min: number, max: number) {\n  return Math.min(Math.max(val, min), max);\n}",
      "testCode": "if (clamp(5, 0, 10) !== 5) throw new Error('in range');\nif (clamp(-5, 0, 10) !== 0) throw new Error('below');\nif (clamp(15, 0, 10) !== 10) throw new Error('above');",
      "language": "typescript",
      "description": "Clamp number between min and max (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "12fe9275733c1bba",
      "name": "lerp-ts",
      "code": "function lerp(a: any, b: any, t: any) {\n  return a + (b - a) * t;\n}",
      "testCode": "if (lerp(0, 10, 0.5) !== 5) throw new Error('mid');\nif (lerp(0, 10, 0) !== 0) throw new Error('start');\nif (lerp(0, 10, 1) !== 10) throw new Error('end');",
      "language": "typescript",
      "description": "Linear interpolation between two values (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "animation",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "fad95c5b848d499e",
      "name": "fibonacci-ts",
      "code": "function fibonacci(n: any) {\n  if (n <= 1) return n;\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) { let t = b; b = a + b; a = t; }\n  return b;\n}",
      "testCode": "if (fibonacci(0) !== 0) throw new Error('f0');\nif (fibonacci(1) !== 1) throw new Error('f1');\nif (fibonacci(10) !== 55) throw new Error('f10');\nif (fibonacci(20) !== 6765) throw new Error('f20');",
      "language": "typescript",
      "description": "Get nth Fibonacci number iteratively (TypeScript variant)",
      "tags": [
        "math",
        "algorithm",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "525bd85540fb69a7",
      "name": "is-prime-ts",
      "code": "function isPrime(n: any) {\n  if (n < 2) return false;\n  if (n < 4) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}",
      "testCode": "if (!isPrime(2)) throw new Error('2');\nif (!isPrime(17)) throw new Error('17');\nif (isPrime(1)) throw new Error('1');\nif (isPrime(15)) throw new Error('15');",
      "language": "typescript",
      "description": "Check if number is prime (TypeScript variant)",
      "tags": [
        "math",
        "algorithm",
        "validation",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "951969d5dcb33a79",
      "name": "gcd-ts",
      "code": "function gcd(a: any, b: any) {\n  a = Math.abs(a); b = Math.abs(b);\n  while (b) { let t = b; b = a % b; a = t; }\n  return a;\n}",
      "testCode": "if (gcd(12, 8) !== 4) throw new Error('12,8');\nif (gcd(7, 13) !== 1) throw new Error('coprime');\nif (gcd(0, 5) !== 5) throw new Error('zero');",
      "language": "typescript",
      "description": "Greatest common divisor using Euclidean algorithm (TypeScript variant)",
      "tags": [
        "math",
        "algorithm",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f7b16171a5455b21",
      "name": "factorial-ts",
      "code": "function factorial(n: any) {\n  if (n < 0) throw new Error('negative');\n  let result = 1;\n  for (let i = 2; i <= n; i++) result *= i;\n  return result;\n}",
      "testCode": "if (factorial(0) !== 1) throw new Error('0!');\nif (factorial(5) !== 120) throw new Error('5!');\nif (factorial(1) !== 1) throw new Error('1!');\ntry { factorial(-1); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }",
      "language": "typescript",
      "description": "Compute factorial of n (TypeScript variant)",
      "tags": [
        "math",
        "algorithm",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "881c20a6fa45a0b5",
      "name": "random-int-ts",
      "code": "function randomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}",
      "testCode": "for (var i = 0; i < 100; i++) {\n  var r = randomInt(1, 10);\n  if (r < 1 || r > 10) throw new Error('out of range: ' + r);\n  if (!Number.isInteger(r)) throw new Error('not int');\n}",
      "language": "typescript",
      "description": "Random integer between min and max inclusive (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "random",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "da9dd057ab2d7fc4",
      "name": "sum-ts",
      "code": "function sum(arr: any[]) {\n  let total = 0;\n  for (let i = 0; i < arr.length; i++) total += arr[i];\n  return total;\n}",
      "testCode": "if (sum([1,2,3,4]) !== 10) throw new Error('basic');\nif (sum([]) !== 0) throw new Error('empty');\nif (sum([-1, 1]) !== 0) throw new Error('negative');",
      "language": "typescript",
      "description": "Sum array of numbers (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "array",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "fd4add3b185a11b1",
      "name": "median-ts",
      "code": "function median(arr: any[]) {\n  if (!arr.length) return undefined;\n  let sorted = arr.slice().sort(function(a,b) { return a - b; });\n  let mid = sorted.length >>> 1;\n  return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;\n}",
      "testCode": "if (median([3,1,2]) !== 2) throw new Error('odd');\nif (median([4,1,3,2]) !== 2.5) throw new Error('even');\nif (median([5]) !== 5) throw new Error('single');\nif (median([]) !== undefined) throw new Error('empty');",
      "language": "typescript",
      "description": "Calculate median of number array (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "statistics",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "651f5cbe3f7aeb67",
      "name": "sleep-ts",
      "code": "function sleep(ms: any) {\n  return new Promise(function(resolve) { setTimeout(resolve, ms); });\n}",
      "testCode": "if (typeof sleep(1).then !== 'function') throw new Error('not promise');\nvar start = Date.now();\nsleep(10).then(function() {\n  if (Date.now() - start < 5) throw new Error('too fast');\n});",
      "language": "typescript",
      "description": "Promise-based delay function (TypeScript variant)",
      "tags": [
        "async",
        "utility",
        "promise",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "cca96033ce9386a0",
      "name": "deferred-ts",
      "code": "function deferred() {\n  let resolve, reject;\n  let promise = new Promise(function(res, rej) { resolve = res; reject = rej; });\n  return { promise: promise, resolve: resolve, reject: reject };\n}",
      "testCode": "var d = deferred();\nif (typeof d.promise.then !== 'function') throw new Error('promise');\nif (typeof d.resolve !== 'function') throw new Error('resolve');\nif (typeof d.reject !== 'function') throw new Error('reject');\nd.promise.then(function(v) { if (v !== 'ok') throw new Error('value'); });\nd.resolve('ok');",
      "language": "typescript",
      "description": "Create deferred promise with external resolve/reject (TypeScript variant)",
      "tags": [
        "async",
        "utility",
        "promise",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "dc213c293df91177",
      "name": "stack-ts",
      "code": "function Stack() {\n  this.items = [];\n}\nStack.prototype.push = function(item) { this.items.push(item); };\nStack.prototype.pop = function() { return this.items.pop(); };\nStack.prototype.peek = function() { return this.items[this.items.length - 1]; };\nStack.prototype.isEmpty = function() { return this.items.length === 0; };\nStack.prototype.size = function() { return this.items.length; };",
      "testCode": "var s = new Stack();\ns.push(1); s.push(2); s.push(3);\nif (s.peek() !== 3) throw new Error('peek');\nif (s.pop() !== 3) throw new Error('pop');\nif (s.size() !== 2) throw new Error('size');\nif (s.isEmpty()) throw new Error('not empty');",
      "language": "typescript",
      "description": "Stack with push, pop, peek operations (TypeScript variant)",
      "tags": [
        "data-structure",
        "stack",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "f60f31c57f4b5b67",
      "name": "min-heap-ts",
      "code": "function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  let i = this.data.length - 1;\n  while (i > 0) {\n    let p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    let t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return undefined;\n  let min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    let i = 0, n = this.data.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      let t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };",
      "testCode": "var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');",
      "language": "typescript",
      "description": "Min-heap with insert and extractMin (TypeScript variant)",
      "tags": [
        "data-structure",
        "heap",
        "priority-queue",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e7088606fb0dbcb9",
      "name": "linked-list-ts",
      "code": "function LinkedList() { this.head = null; this.length = 0; }\nLinkedList.prototype.push = function(val) {\n  this.head = { val: val, next: this.head };\n  this.length++;\n};\nLinkedList.prototype.pop = function() {\n  if (!this.head) return undefined;\n  let val = this.head.val;\n  this.head = this.head.next;\n  this.length--;\n  return val;\n};\nLinkedList.prototype.has = function(val) {\n  let n = this.head;\n  while (n) { if (n.val === val) return true; n = n.next; }\n  return false;\n};\nLinkedList.prototype.toArray = function() {\n  let r = [], n = this.head;\n  while (n) { r.push(n.val); n = n.next; }\n  return r;\n};",
      "testCode": "var ll = new LinkedList();\nll.push(1); ll.push(2); ll.push(3);\nif (ll.length !== 3) throw new Error('length');\nif (!ll.has(2)) throw new Error('has');\nif (ll.pop() !== 3) throw new Error('pop');\nif (JSON.stringify(ll.toArray()) !== '[2,1]') throw new Error('toArray');",
      "language": "typescript",
      "description": "Singly linked list (TypeScript variant)",
      "tags": [
        "data-structure",
        "linked-list",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "48a11b48aa5efdf2",
      "name": "priority-queue-ts",
      "code": "function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  let i = this.heap.length - 1;\n  while (i > 0) {\n    let p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    let t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return undefined;\n  let top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    let i = 0, n = this.heap.length;\n    while (true) {\n      let m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      let t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};",
      "testCode": "var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');",
      "language": "typescript",
      "description": "Priority queue using min-heap (TypeScript variant)",
      "tags": [
        "data-structure",
        "priority-queue",
        "heap",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "c991fe228fdee2e5",
      "name": "bloom-filter-ts",
      "code": "function BloomFilter(size: number) {\n  this.size = size || 256;\n  this.bits = new Uint8Array(this.size);\n}\nBloomFilter.prototype._hashes = function(val) {\n  let str = String(val), h1 = 0, h2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    h1 = (h1 * 31 + str.charCodeAt(i)) % this.size;\n    h2 = (h2 * 37 + str.charCodeAt(i)) % this.size;\n  }\n  return [h1, h2, (h1 + h2) % this.size];\n};\nBloomFilter.prototype.add = function(val) {\n  let h = this._hashes(val);\n  for (let i = 0; i < h.length; i++) this.bits[h[i]] = 1;\n};\nBloomFilter.prototype.has = function(val) {\n  let h = this._hashes(val);\n  for (let i = 0; i < h.length; i++) { if (!this.bits[h[i]]) return false; }\n  return true;\n};",
      "testCode": "var bf = new BloomFilter(256);\nbf.add('hello'); bf.add('world');\nif (!bf.has('hello')) throw new Error('has hello');\nif (!bf.has('world')) throw new Error('has world');",
      "language": "typescript",
      "description": "Bloom filter for probabilistic set membership (TypeScript variant)",
      "tags": [
        "data-structure",
        "bloom-filter",
        "probabilistic",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "4f0a265a9beaeb4b",
      "name": "curry-ts",
      "code": "function curry(fn: any[]) {\n  return function curried() {\n    let args = Array.prototype.slice.call(arguments);\n    if (args.length >= fn.length) return fn.apply(this, args);\n    return function() {\n      return curried.apply(this, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  };\n}",
      "testCode": "var add = curry(function(a, b, c) { return a + b + c; });\nif (add(1, 2, 3) !== 6) throw new Error('all');\nif (add(1)(2)(3) !== 6) throw new Error('curried');\nif (add(1, 2)(3) !== 6) throw new Error('partial');",
      "language": "typescript",
      "description": "Curry a function for partial application (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "d06719e6a3791482",
      "name": "compose-ts",
      "code": "function compose() {\n  let fns = Array.prototype.slice.call(arguments);\n  return function(input) {\n    return fns.reduceRight(function(val, fn) { return fn(val); }, input);\n  };\n}",
      "testCode": "var double = function(x) { return x * 2; };\nvar inc = function(x) { return x + 1; };\nvar transform = compose(String, inc, double);\nif (transform(5) !== '11') throw new Error('compose: ' + transform(5));",
      "language": "typescript",
      "description": "Compose functions right-to-left (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "5e8f3e5d75b7be97",
      "name": "partial-ts",
      "code": "function partial(fn: Function) {\n  let preset = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    return fn.apply(this, preset.concat(Array.prototype.slice.call(arguments)));\n  };\n}",
      "testCode": "var add = function(a, b, c) { return a + b + c; };\nvar add10 = partial(add, 10);\nif (add10(2, 3) !== 15) throw new Error('partial');\nvar add10and20 = partial(add, 10, 20);\nif (add10and20(3) !== 33) throw new Error('two');",
      "language": "typescript",
      "description": "Partially apply arguments to function (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e5fc4336531c676f",
      "name": "once-ts",
      "code": "function once(fn: Function) {\n  let called = false, result;\n  return function() {\n    if (!called) { called = true; result = fn.apply(this, arguments); }\n    return result;\n  };\n}",
      "testCode": "var count = 0;\nvar inc = once(function() { return ++count; });\nif (inc() !== 1) throw new Error('first');\nif (inc() !== 1) throw new Error('cached');\nif (count !== 1) throw new Error('called once');",
      "language": "typescript",
      "description": "Ensure function is only called once (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "d3286139f4f9e42c",
      "name": "negate-ts",
      "code": "function negate(fn: Function) {\n  return function() { return !fn.apply(this, arguments); };\n}",
      "testCode": "var isEven = function(n) { return n % 2 === 0; };\nvar isOdd = negate(isEven);\nif (!isOdd(3)) throw new Error('odd');\nif (isOdd(4)) throw new Error('even');",
      "language": "typescript",
      "description": "Create function that negates predicate result (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "67f97294d602937f",
      "name": "flip-ts",
      "code": "function flip(fn: Function) {\n  return function() {\n    return fn.apply(this, Array.prototype.slice.call(arguments).reverse());\n  };\n}",
      "testCode": "var div = function(a, b) { return a / b; };\nvar flipped = flip(div);\nif (flipped(2, 10) !== 5) throw new Error('flipped');",
      "language": "typescript",
      "description": "Reverse argument order of function (TypeScript variant)",
      "tags": [
        "functional",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "7d121e4cf035a6cc",
      "name": "is-leap-year-py",
      "code": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0",
      "testCode": "assert is_leap_year(2000)\nassert is_leap_year(2024)",
      "language": "python",
      "description": "Check if year is a leap year (Python variant)",
      "tags": [
        "date",
        "utility",
        "validation",
        "variant",
        "python"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "025a1802f405fcc5",
      "name": "is-leap-year-ts",
      "code": "function isLeapYear(year: any) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}",
      "testCode": "if (!isLeapYear(2000)) throw new Error('2000');\nif (!isLeapYear(2024)) throw new Error('2024');\nif (isLeapYear(1900)) throw new Error('1900');\nif (isLeapYear(2023)) throw new Error('2023');",
      "language": "typescript",
      "description": "Check if year is a leap year (TypeScript variant)",
      "tags": [
        "date",
        "utility",
        "validation",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "b2076710d8cc9a10",
      "name": "days-between-ts",
      "code": "function daysBetween(d1: any, d2: any) {\n  let ms = Math.abs(new Date(d1) - new Date(d2));\n  return Math.floor(ms / 86400000);\n}",
      "testCode": "if (daysBetween('2024-01-01', '2024-01-31') !== 30) throw new Error('jan');\nif (daysBetween('2024-01-01', '2024-01-01') !== 0) throw new Error('same');",
      "language": "typescript",
      "description": "Count days between two dates (TypeScript variant)",
      "tags": [
        "date",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "659d47718d14d0d2",
      "name": "days-in-month-ts",
      "code": "function daysInMonth(year: any, month: any) {\n  return new Date(year, month, 0).getDate();\n}",
      "testCode": "if (daysInMonth(2024, 2) !== 29) throw new Error('feb leap');\nif (daysInMonth(2023, 2) !== 28) throw new Error('feb normal');\nif (daysInMonth(2024, 1) !== 31) throw new Error('jan');",
      "language": "typescript",
      "description": "Get number of days in a given month (TypeScript variant)",
      "tags": [
        "date",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d9b86abfca4292db",
      "name": "is-url-ts",
      "code": "function isURL(str: string) {\n  try {\n    let url = new URL(str);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch(e) { return false; }\n}",
      "testCode": "if (!isURL('https://example.com')) throw new Error('https');\nif (!isURL('http://example.com/path?q=1')) throw new Error('path');\nif (isURL('not-a-url')) throw new Error('invalid');\nif (isURL('ftp://x.com')) throw new Error('ftp');",
      "language": "typescript",
      "description": "Validate URL string (TypeScript variant)",
      "tags": [
        "validation",
        "utility",
        "url",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "d9855d8e68deecad",
      "name": "is-json-ts",
      "code": "function isJSON(str: string) {\n  try { JSON.parse(str); return true; } catch(e) { return false; }\n}",
      "testCode": "if (!isJSON('{\"a\":1}')) throw new Error('object');\nif (!isJSON('[1,2,3]')) throw new Error('array');\nif (!isJSON('\"hello\"')) throw new Error('string');\nif (isJSON('not json')) throw new Error('invalid');",
      "language": "typescript",
      "description": "Check if string is valid JSON (TypeScript variant)",
      "tags": [
        "validation",
        "utility",
        "json",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b80c43656a46ebcd",
      "name": "luhn-check-ts",
      "code": "function luhnCheck(num: number) {\n  let str = String(num).replace(/\\D/g, '');\n  let sum = 0, alt = false;\n  for (let i = str.length - 1; i >= 0; i--) {\n    let n = parseInt(str[i], 10);\n    if (alt) { n *= 2; if (n > 9) n -= 9; }\n    sum += n;\n    alt = !alt;\n  }\n  return sum % 10 === 0;\n}",
      "testCode": "if (!luhnCheck('79927398713')) throw new Error('valid');\nif (luhnCheck('1234567890')) throw new Error('invalid');",
      "language": "typescript",
      "description": "Luhn algorithm for credit card validation (TypeScript variant)",
      "tags": [
        "validation",
        "algorithm",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "c6d6dc643f55af7f",
      "name": "build-query-string-ts",
      "code": "function buildQueryString(obj: any[]) {\n  let pairs = Object.keys(obj).filter(function(k) {\n    return obj[k] !== undefined;\n  }).map(function(k) {\n    return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);\n  });\n  return pairs.length ? '?' + pairs.join('&') : '';\n}",
      "testCode": "var r = buildQueryString({foo: 'bar', baz: 42});\nif (!r.includes('foo=bar')) throw new Error('foo');\nif (!r.includes('baz=42')) throw new Error('baz');\nif (r[0] !== '?') throw new Error('question');\nif (buildQueryString({}) !== '') throw new Error('empty');",
      "language": "typescript",
      "description": "Build URL query string from object (TypeScript variant)",
      "tags": [
        "http",
        "utility",
        "url",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "92887dc4f7d739f5",
      "name": "round-to-ts",
      "code": "function roundTo(num: number, places: number) {\n  let factor = Math.pow(10, places);\n  return Math.round((num + Number.EPSILON) * factor) / factor;\n}",
      "testCode": "if (roundTo(3.14159, 2) !== 3.14) throw new Error('2 places');\nif (roundTo(1.005, 2) !== 1.01) throw new Error('rounding');\nif (roundTo(2.675, 2) !== 2.68) throw new Error('banker');\nif (roundTo(5, 0) !== 5) throw new Error('integer');",
      "language": "typescript",
      "description": "Round number to specified decimal places (TypeScript variant)",
      "tags": [
        "math",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "01a1be16095b182b",
      "name": "binary-search-py",
      "code": "def binary_search(arr, target):\n    lo, hi = 0, len(arr) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1",
      "testCode": "assert binary_search([1,2,3,4,5], 3) == 2, \"mid\"\nassert binary_search([1,2,3,4,5], 1) == 0, \"first\"\nassert binary_search([1,2,3,4,5], 6) == -1, \"missing\"\nassert binary_search([], 1) == -1, \"empty\"",
      "language": "python",
      "description": "Binary search on sorted list — O(log n)",
      "tags": [
        "search",
        "algorithm",
        "list",
        "sorted",
        "binary-search"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "01f85528352ad74d",
      "name": "pad-string-ts",
      "code": "function padString(str: any[], len: number, ch: any, right: any) {\n  ch = ch || ' ';\n  while (str.length < len) {\n    str = right ? str + ch : ch + str;\n  }\n  return str;\n}",
      "testCode": "if (padString('5', 3, '0') !== '005') throw new Error('left');\nif (padString('5', 3, '0', true) !== '500') throw new Error('right');\nif (padString('hello', 3) !== 'hello') throw new Error('longer');",
      "language": "typescript",
      "description": "Pad string to target length (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "33ce827cc04ef4c4",
      "name": "count-occurrences-ts",
      "code": "function countOccurrences(str: string, sub: any[]) {\n  if (!sub.length) return 0;\n  let count = 0, pos = 0;\n  while ((pos = str.indexOf(sub, pos)) !== -1) { count++; pos += sub.length; }\n  return count;\n}",
      "testCode": "if (countOccurrences('abcabc', 'abc') !== 2) throw new Error('two');\nif (countOccurrences('hello', 'x') !== 0) throw new Error('none');\nif (countOccurrences('aaa', 'a') !== 3) throw new Error('single');",
      "language": "typescript",
      "description": "Count occurrences of substring in string (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "5b7020d2fd7b3cf7",
      "name": "is-palindrome-ts",
      "code": "function isPalindrome(str: string) {\n  let clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return clean === clean.split('').reverse().join('');\n}",
      "testCode": "if (!isPalindrome('racecar')) throw new Error('basic');\nif (!isPalindrome('A man a plan a canal Panama')) throw new Error('sentence');\nif (isPalindrome('hello')) throw new Error('not palindrome');\nif (!isPalindrome('')) throw new Error('empty');",
      "language": "typescript",
      "description": "Check if string is a palindrome (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "validation",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "3c580b5376631576",
      "name": "repeat-string-ts",
      "code": "function repeatString(str: string, n: any) {\n  let result = '';\n  for (let i = 0; i < n; i++) result += str;\n  return result;\n}",
      "testCode": "if (repeatString('ab', 3) !== 'ababab') throw new Error('basic');\nif (repeatString('x', 0) !== '') throw new Error('zero');\nif (repeatString('', 5) !== '') throw new Error('empty');",
      "language": "typescript",
      "description": "Repeat a string n times (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "eb7bd5fa000de27e",
      "name": "title-case-ts",
      "code": "function titleCase(str: string) {\n  return str.replace(/\\b\\w/g, function(c) { return c.toUpperCase(); });\n}",
      "testCode": "if (titleCase('hello world') !== 'Hello World') throw new Error('basic');\nif (titleCase('foo bar baz') !== 'Foo Bar Baz') throw new Error('three');",
      "language": "typescript",
      "description": "Convert string to Title Case (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "case",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "06995b5c8d6dc5f1",
      "name": "word-count-ts",
      "code": "function wordCount(str: string) {\n  let trimmed = str.trim();\n  if (!trimmed) return 0;\n  return trimmed.split(/\\s+/).length;\n}",
      "testCode": "if (wordCount('hello world') !== 2) throw new Error('two');\nif (wordCount('  one  ') !== 1) throw new Error('padded');\nif (wordCount('') !== 0) throw new Error('empty');\nif (wordCount('a b c d') !== 4) throw new Error('four');",
      "language": "typescript",
      "description": "Count words in a string (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0e65efcad1f01957",
      "name": "reverse-string-ts",
      "code": "function reverseString(str: string) {\n  return str.split('').reverse().join('');\n}",
      "testCode": "if (reverseString('hello') !== 'olleh') throw new Error('basic');\nif (reverseString('') !== '') throw new Error('empty');\nif (reverseString('a') !== 'a') throw new Error('single');",
      "language": "typescript",
      "description": "Reverse a string (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "8c21fef726e1fb8e",
      "name": "unescape-html-ts",
      "code": "function unescapeHTML(str: string) {\n  let map = {'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};\n  return str.replace(/&(?:amp|lt|gt|quot|#39);/g, function(m) { return map[m]; });\n}",
      "testCode": "if (unescapeHTML('&lt;b&gt;') !== '<b>') throw new Error('tags');\nif (unescapeHTML('a&amp;b') !== 'a&b') throw new Error('amp');\nif (unescapeHTML('hello') !== 'hello') throw new Error('noop');",
      "language": "typescript",
      "description": "Unescape HTML entities back to characters (TypeScript variant)",
      "tags": [
        "string",
        "html",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "3e7b688968287909",
      "name": "escape-html-ts",
      "code": "function escapeHTML(str: string) {\n  let map = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\n  return str.replace(/[&<>\"']/g, function(c) { return map[c]; });\n}",
      "testCode": "if (escapeHTML('<b>hi</b>') !== '&lt;b&gt;hi&lt;/b&gt;') throw new Error('tags');\nif (escapeHTML('a&b') !== 'a&amp;b') throw new Error('amp');\nif (escapeHTML('hello') !== 'hello') throw new Error('noop');",
      "language": "typescript",
      "description": "Escape HTML special characters (TypeScript variant)",
      "tags": [
        "string",
        "security",
        "html",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "a79776c9cc0c06f3",
      "name": "slugify-ts",
      "code": "function slugify(str: string) {\n  return str.toLowerCase().trim()\n    .replace(/[^a-z0-9\\s-]/g, '')\n    .replace(/[\\s-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}",
      "testCode": "if (slugify('Hello World!') !== 'hello-world') throw new Error('basic');\nif (slugify('  foo  bar  ') !== 'foo-bar') throw new Error('spaces');\nif (slugify('a--b') !== 'a-b') throw new Error('dashes');",
      "language": "typescript",
      "description": "Convert string to URL-friendly slug (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "url",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "fa5f33a4b0040f25",
      "name": "kebab-case-ts",
      "code": "function kebabCase(str: string) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\s]+/g, '-').toLowerCase();\n}",
      "testCode": "if (kebabCase('helloWorld') !== 'hello-world') throw new Error('camel');\nif (kebabCase('hello_world') !== 'hello-world') throw new Error('snake');\nif (kebabCase('Hello World') !== 'hello-world') throw new Error('space');",
      "language": "typescript",
      "description": "Convert string to kebab-case (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "case",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "f3e4a3c2d5e1ba5e",
      "name": "snake-case-ts",
      "code": "function snakeCase(str: string) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\s]+/g, '_').toLowerCase();\n}",
      "testCode": "if (snakeCase('helloWorld') !== 'hello_world') throw new Error('camel');\nif (snakeCase('hello-world') !== 'hello_world') throw new Error('kebab');\nif (snakeCase('Hello World') !== 'hello_world') throw new Error('space');",
      "language": "typescript",
      "description": "Convert string to snake_case (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "case",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "166a623d6a4d5d2c",
      "name": "camel-case-ts",
      "code": "function camelCase(str: string) {\n  return str.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')\n            .replace(/^[A-Z]/, c => c.toLowerCase());\n}",
      "testCode": "if (camelCase('hello-world') !== 'helloWorld') throw new Error('kebab');\nif (camelCase('foo_bar') !== 'fooBar') throw new Error('snake');\nif (camelCase('Hello World') !== 'helloWorld') throw new Error('space');",
      "language": "typescript",
      "description": "Convert string to camelCase (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "case",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b7b00125c63c45ab",
      "name": "capitalize-ts",
      "code": "function capitalize(s: any[]) {\n  return s ? s[0].toUpperCase() + s.slice(1) : '';\n}",
      "testCode": "if (capitalize('hello') !== 'Hello') throw new Error('basic');\nif (capitalize('') !== '') throw new Error('empty');\nif (capitalize('A') !== 'A') throw new Error('already');",
      "language": "typescript",
      "description": "Capitalize first letter of string (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4fca613657cebd18",
      "name": "validate-email-ts",
      "code": "function validateEmail(email: any[]) {\n  if (typeof email !== 'string') return false;\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email) && email.length <= 254;\n}",
      "testCode": "if (!validateEmail(\"user@example.com\")) throw new Error(\"valid\");\nif (!validateEmail(\"a@b.co\")) throw new Error(\"short valid\");\nif (validateEmail(\"@example.com\")) throw new Error(\"no local\");\nif (validateEmail(\"user@\")) throw new Error(\"no domain\");\nif (validateEmail(\"\")) throw new Error(\"empty\");\nif (validateEmail(null)) throw new Error(\"null\");\nif (validateEmail(\"has space@x.com\")) throw new Error(\"space\");",
      "language": "typescript",
      "description": "Email validation with basic RFC compliance (TypeScript variant)",
      "tags": [
        "validation",
        "email",
        "regex",
        "input",
        "sanitize",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "920d98b3df970432",
      "name": "lru-cache-ts",
      "code": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}",
      "testCode": "const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");",
      "language": "typescript",
      "description": "LRU Cache using Map for O(1) get/set with eviction (TypeScript variant)",
      "tags": [
        "data-structure",
        "cache",
        "lru",
        "map",
        "eviction",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "96344e1ec86349fd",
      "name": "breadth-first-search-ts",
      "code": "function bfs(graph: any[], start: number) {\n  const visited = new Set([start]);\n  const queue = [start];\n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of (graph[node] || [])) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}",
      "testCode": "const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = bfs(g, 'a');\nif (r[0] !== 'a') throw new Error(\"start\");\nif (r.length !== 4) throw new Error(\"all nodes\");\nif (r.indexOf('b') > r.indexOf('d') && r.indexOf('c') > r.indexOf('d')) throw new Error(\"bfs order\");",
      "language": "typescript",
      "description": "Breadth-first search on adjacency list graph (TypeScript variant)",
      "tags": [
        "graph",
        "search",
        "algorithm",
        "bfs",
        "traversal",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "ce4529ac797834e9",
      "name": "merge-sort-ts",
      "code": "function mergeSort(arr: any[]) {\n  if (arr.length <= 1) return arr;\n  const mid = arr.length >>> 1;\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    result.push(left[i] <= right[j] ? left[i++] : right[j++]);\n  }\n  while (i < left.length) result.push(left[i++]);\n  while (j < right.length) result.push(right[j++]);\n  return result;\n}",
      "testCode": "const r1 = mergeSort([5,3,8,1,9,2]);\nif (JSON.stringify(r1) !== '[1,2,3,5,8,9]') throw new Error(\"sort: \" + r1);\nif (JSON.stringify(mergeSort([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(mergeSort([1])) !== '[1]') throw new Error(\"single\");\nif (JSON.stringify(mergeSort([3,1,1,2])) !== '[1,1,2,3]') throw new Error(\"dups\");",
      "language": "typescript",
      "description": "Merge sort — stable O(n log n) sorting (TypeScript variant)",
      "tags": [
        "sort",
        "algorithm",
        "array",
        "merge-sort",
        "stable",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "cae1179f4a183f37",
      "name": "binary-search-ts",
      "code": "function binarySearch(arr: any[], target: any) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}",
      "testCode": "if (binarySearch([1,2,3,4,5], 3) !== 2) throw new Error(\"mid\");\nif (binarySearch([1,2,3,4,5], 1) !== 0) throw new Error(\"first\");\nif (binarySearch([1,2,3,4,5], 5) !== 4) throw new Error(\"last\");\nif (binarySearch([1,2,3,4,5], 6) !== -1) throw new Error(\"missing\");\nif (binarySearch([], 1) !== -1) throw new Error(\"empty\");",
      "language": "typescript",
      "description": "Binary search on a sorted array — O(log n) (TypeScript variant)",
      "tags": [
        "search",
        "algorithm",
        "array",
        "sorted",
        "binary-search",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "62052b65b39fcdc4",
      "name": "result-type-ts",
      "code": "type Result<T, E = Error> = { ok: true; value: T } | { ok: false; error: E };\n\nfunction Ok<T>(value: T): Result<T, never> {\n  return { ok: true, value };\n}\n\nfunction Err<E>(error: E): Result<never, E> {\n  return { ok: false, error };\n}\n\nfunction unwrap<T, E>(result: Result<T, E>): T {\n  if (result.ok) return result.value;\n  throw result.error;\n}",
      "testCode": "const ok = Ok(42);\nif (!ok.ok || ok.value !== 42) throw new Error(\"Ok failed\");\nconst err = Err(new Error(\"boom\"));\nif (err.ok) throw new Error(\"Err should not be ok\");\ntry { unwrap(err); throw new Error(\"should throw\"); } catch(e) { if (e.message !== \"boom\") throw e; }\nif (unwrap(Ok(\"hello\")) !== \"hello\") throw new Error(\"unwrap ok\");",
      "language": "typescript",
      "description": "Result type (Rust-style Ok/Err) for typed error handling",
      "tags": [
        "utility",
        "error-handling",
        "typescript",
        "type-safety",
        "result"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "5e239472aa3ed79d",
      "name": "round-to",
      "code": "function roundTo(num, places) {\n  var factor = Math.pow(10, places);\n  return Math.round((num + Number.EPSILON) * factor) / factor;\n}",
      "testCode": "if (roundTo(3.14159, 2) !== 3.14) throw new Error('2 places');\nif (roundTo(1.005, 2) !== 1.01) throw new Error('rounding');\nif (roundTo(2.675, 2) !== 2.68) throw new Error('banker');\nif (roundTo(5, 0) !== 5) throw new Error('integer');",
      "language": "javascript",
      "description": "Round number to specified decimal places",
      "tags": [
        "math",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "09f2d5995872840d",
      "name": "build-query-string",
      "code": "function buildQueryString(obj) {\n  var pairs = Object.keys(obj).filter(function(k) {\n    return obj[k] !== undefined;\n  }).map(function(k) {\n    return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);\n  });\n  return pairs.length ? '?' + pairs.join('&') : '';\n}",
      "testCode": "var r = buildQueryString({foo: 'bar', baz: 42});\nif (!r.includes('foo=bar')) throw new Error('foo');\nif (!r.includes('baz=42')) throw new Error('baz');\nif (r[0] !== '?') throw new Error('question');\nif (buildQueryString({}) !== '') throw new Error('empty');",
      "language": "javascript",
      "description": "Build URL query string from object",
      "tags": [
        "http",
        "utility",
        "url"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "aad7972e7996ad26",
      "name": "luhn-check",
      "code": "function luhnCheck(num) {\n  var str = String(num).replace(/\\D/g, '');\n  var sum = 0, alt = false;\n  for (var i = str.length - 1; i >= 0; i--) {\n    var n = parseInt(str[i], 10);\n    if (alt) { n *= 2; if (n > 9) n -= 9; }\n    sum += n;\n    alt = !alt;\n  }\n  return sum % 10 === 0;\n}",
      "testCode": "if (!luhnCheck('79927398713')) throw new Error('valid');\nif (luhnCheck('1234567890')) throw new Error('invalid');",
      "language": "javascript",
      "description": "Luhn algorithm for credit card validation",
      "tags": [
        "validation",
        "algorithm"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "560d5ef200350dfd",
      "name": "is-json",
      "code": "function isJSON(str) {\n  try { JSON.parse(str); return true; } catch(e) { return false; }\n}",
      "testCode": "if (!isJSON('{\"a\":1}')) throw new Error('object');\nif (!isJSON('[1,2,3]')) throw new Error('array');\nif (!isJSON('\"hello\"')) throw new Error('string');\nif (isJSON('not json')) throw new Error('invalid');",
      "language": "javascript",
      "description": "Check if string is valid JSON",
      "tags": [
        "validation",
        "utility",
        "json"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "a5a6eb9904955abd",
      "name": "is-url",
      "code": "function isURL(str) {\n  try {\n    var url = new URL(str);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch(e) { return false; }\n}",
      "testCode": "if (!isURL('https://example.com')) throw new Error('https');\nif (!isURL('http://example.com/path?q=1')) throw new Error('path');\nif (isURL('not-a-url')) throw new Error('invalid');\nif (isURL('ftp://x.com')) throw new Error('ftp');",
      "language": "javascript",
      "description": "Validate URL string",
      "tags": [
        "validation",
        "utility",
        "url"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "1ad06563ffa07d04",
      "name": "days-in-month",
      "code": "function daysInMonth(year, month) {\n  return new Date(year, month, 0).getDate();\n}",
      "testCode": "if (daysInMonth(2024, 2) !== 29) throw new Error('feb leap');\nif (daysInMonth(2023, 2) !== 28) throw new Error('feb normal');\nif (daysInMonth(2024, 1) !== 31) throw new Error('jan');",
      "language": "javascript",
      "description": "Get number of days in a given month",
      "tags": [
        "date",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "e8d1b91e7ed56d71",
      "name": "days-between",
      "code": "function daysBetween(d1, d2) {\n  var ms = Math.abs(new Date(d1) - new Date(d2));\n  return Math.floor(ms / 86400000);\n}",
      "testCode": "if (daysBetween('2024-01-01', '2024-01-31') !== 30) throw new Error('jan');\nif (daysBetween('2024-01-01', '2024-01-01') !== 0) throw new Error('same');",
      "language": "javascript",
      "description": "Count days between two dates",
      "tags": [
        "date",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b7b68b9947880d2f",
      "name": "is-leap-year",
      "code": "function isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}",
      "testCode": "if (!isLeapYear(2000)) throw new Error('2000');\nif (!isLeapYear(2024)) throw new Error('2024');\nif (isLeapYear(1900)) throw new Error('1900');\nif (isLeapYear(2023)) throw new Error('2023');",
      "language": "javascript",
      "description": "Check if year is a leap year",
      "tags": [
        "date",
        "utility",
        "validation"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "03e0ad24f0c00ab4",
      "name": "flip",
      "code": "function flip(fn) {\n  return function() {\n    return fn.apply(this, Array.prototype.slice.call(arguments).reverse());\n  };\n}",
      "testCode": "var div = function(a, b) { return a / b; };\nvar flipped = flip(div);\nif (flipped(2, 10) !== 5) throw new Error('flipped');",
      "language": "javascript",
      "description": "Reverse argument order of function",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "67567604bae66f71",
      "name": "negate",
      "code": "function negate(fn) {\n  return function() { return !fn.apply(this, arguments); };\n}",
      "testCode": "var isEven = function(n) { return n % 2 === 0; };\nvar isOdd = negate(isEven);\nif (!isOdd(3)) throw new Error('odd');\nif (isOdd(4)) throw new Error('even');",
      "language": "javascript",
      "description": "Create function that negates predicate result",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "183ec26179f6536c",
      "name": "once",
      "code": "function once(fn) {\n  var called = false, result;\n  return function() {\n    if (!called) { called = true; result = fn.apply(this, arguments); }\n    return result;\n  };\n}",
      "testCode": "var count = 0;\nvar inc = once(function() { return ++count; });\nif (inc() !== 1) throw new Error('first');\nif (inc() !== 1) throw new Error('cached');\nif (count !== 1) throw new Error('called once');",
      "language": "javascript",
      "description": "Ensure function is only called once",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "05d04d35b05d2536",
      "name": "partial",
      "code": "function partial(fn) {\n  var preset = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    return fn.apply(this, preset.concat(Array.prototype.slice.call(arguments)));\n  };\n}",
      "testCode": "var add = function(a, b, c) { return a + b + c; };\nvar add10 = partial(add, 10);\nif (add10(2, 3) !== 15) throw new Error('partial');\nvar add10and20 = partial(add, 10, 20);\nif (add10and20(3) !== 33) throw new Error('two');",
      "language": "javascript",
      "description": "Partially apply arguments to function",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "71fa5984e8e482ca",
      "name": "compose",
      "code": "function compose() {\n  var fns = Array.prototype.slice.call(arguments);\n  return function(input) {\n    return fns.reduceRight(function(val, fn) { return fn(val); }, input);\n  };\n}",
      "testCode": "var double = function(x) { return x * 2; };\nvar inc = function(x) { return x + 1; };\nvar transform = compose(String, inc, double);\nif (transform(5) !== '11') throw new Error('compose: ' + transform(5));",
      "language": "javascript",
      "description": "Compose functions right-to-left",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "e246539d2c0e5b2e",
      "name": "curry",
      "code": "function curry(fn) {\n  return function curried() {\n    var args = Array.prototype.slice.call(arguments);\n    if (args.length >= fn.length) return fn.apply(this, args);\n    return function() {\n      return curried.apply(this, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  };\n}",
      "testCode": "var add = curry(function(a, b, c) { return a + b + c; });\nif (add(1, 2, 3) !== 6) throw new Error('all');\nif (add(1)(2)(3) !== 6) throw new Error('curried');\nif (add(1, 2)(3) !== 6) throw new Error('partial');",
      "language": "javascript",
      "description": "Curry a function for partial application",
      "tags": [
        "functional",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "d370da2a5cccb299",
      "name": "bloom-filter",
      "code": "function BloomFilter(size) {\n  this.size = size || 256;\n  this.bits = new Uint8Array(this.size);\n}\nBloomFilter.prototype._hashes = function(val) {\n  var str = String(val), h1 = 0, h2 = 0;\n  for (var i = 0; i < str.length; i++) {\n    h1 = (h1 * 31 + str.charCodeAt(i)) % this.size;\n    h2 = (h2 * 37 + str.charCodeAt(i)) % this.size;\n  }\n  return [h1, h2, (h1 + h2) % this.size];\n};\nBloomFilter.prototype.add = function(val) {\n  var h = this._hashes(val);\n  for (var i = 0; i < h.length; i++) this.bits[h[i]] = 1;\n};\nBloomFilter.prototype.has = function(val) {\n  var h = this._hashes(val);\n  for (var i = 0; i < h.length; i++) { if (!this.bits[h[i]]) return false; }\n  return true;\n};",
      "testCode": "var bf = new BloomFilter(256);\nbf.add('hello'); bf.add('world');\nif (!bf.has('hello')) throw new Error('has hello');\nif (!bf.has('world')) throw new Error('has world');",
      "language": "javascript",
      "description": "Bloom filter for probabilistic set membership",
      "tags": [
        "data-structure",
        "bloom-filter",
        "probabilistic"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "dbdea0dc5f647c59",
      "name": "priority-queue",
      "code": "function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  var i = this.heap.length - 1;\n  while (i > 0) {\n    var p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    var t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return undefined;\n  var top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    var i = 0, n = this.heap.length;\n    while (true) {\n      var m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      var t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};",
      "testCode": "var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');",
      "language": "javascript",
      "description": "Priority queue using min-heap",
      "tags": [
        "data-structure",
        "priority-queue",
        "heap"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "723ee54e1fcbc390",
      "name": "linked-list",
      "code": "function LinkedList() { this.head = null; this.length = 0; }\nLinkedList.prototype.push = function(val) {\n  this.head = { val: val, next: this.head };\n  this.length++;\n};\nLinkedList.prototype.pop = function() {\n  if (!this.head) return undefined;\n  var val = this.head.val;\n  this.head = this.head.next;\n  this.length--;\n  return val;\n};\nLinkedList.prototype.has = function(val) {\n  var n = this.head;\n  while (n) { if (n.val === val) return true; n = n.next; }\n  return false;\n};\nLinkedList.prototype.toArray = function() {\n  var r = [], n = this.head;\n  while (n) { r.push(n.val); n = n.next; }\n  return r;\n};",
      "testCode": "var ll = new LinkedList();\nll.push(1); ll.push(2); ll.push(3);\nif (ll.length !== 3) throw new Error('length');\nif (!ll.has(2)) throw new Error('has');\nif (ll.pop() !== 3) throw new Error('pop');\nif (JSON.stringify(ll.toArray()) !== '[2,1]') throw new Error('toArray');",
      "language": "javascript",
      "description": "Singly linked list",
      "tags": [
        "data-structure",
        "linked-list"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "6549d9f8178006ad",
      "name": "min-heap",
      "code": "function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  var i = this.data.length - 1;\n  while (i > 0) {\n    var p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    var t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return undefined;\n  var min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    var i = 0, n = this.data.length;\n    while (true) {\n      var m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      var t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };",
      "testCode": "var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');",
      "language": "javascript",
      "description": "Min-heap with insert and extractMin",
      "tags": [
        "data-structure",
        "heap",
        "priority-queue"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "c6b229f231ba8f8d",
      "name": "p-map",
      "code": "function pMap(items, fn, concurrency) {\n  concurrency = concurrency || Infinity;\n  var results = new Array(items.length);\n  var index = 0;\n  function worker() {\n    var work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }\n  var workers = [];\n  for (var i = 0; i < Math.min(concurrency, items.length); i++) workers.push(worker());\n  return Promise.all(workers).then(function() { return results; });\n}",
      "testCode": "pMap([1,2,3], function(x) { return Promise.resolve(x * 2); }, 2).then(function(r) {\n  if (JSON.stringify(r) !== '[2,4,6]') throw new Error('result: ' + JSON.stringify(r));\n});",
      "language": "javascript",
      "description": "Parallel map with concurrency limit",
      "tags": [
        "async",
        "utility",
        "concurrency"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "04e447523c6f9669",
      "name": "deferred",
      "code": "function deferred() {\n  var resolve, reject;\n  var promise = new Promise(function(res, rej) { resolve = res; reject = rej; });\n  return { promise: promise, resolve: resolve, reject: reject };\n}",
      "testCode": "var d = deferred();\nif (typeof d.promise.then !== 'function') throw new Error('promise');\nif (typeof d.resolve !== 'function') throw new Error('resolve');\nif (typeof d.reject !== 'function') throw new Error('reject');\nd.promise.then(function(v) { if (v !== 'ok') throw new Error('value'); });\nd.resolve('ok');",
      "language": "javascript",
      "description": "Create deferred promise with external resolve/reject",
      "tags": [
        "async",
        "utility",
        "promise"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "515382f00fe18267",
      "name": "promise-timeout",
      "code": "function promiseTimeout(promise, ms) {\n  var timeout = new Promise(function(_, reject) {\n    setTimeout(function() { reject(new Error('timeout')); }, ms);\n  });\n  return Promise.race([promise, timeout]);\n}",
      "testCode": "promiseTimeout(Promise.resolve(42), 100).then(function(v) {\n  if (v !== 42) throw new Error('value');\n});",
      "language": "javascript",
      "description": "Wrap promise with timeout",
      "tags": [
        "async",
        "utility",
        "promise"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "892fe0576a71e563",
      "name": "sleep",
      "code": "function sleep(ms) {\n  return new Promise(function(resolve) { setTimeout(resolve, ms); });\n}",
      "testCode": "if (typeof sleep(1).then !== 'function') throw new Error('not promise');\nvar start = Date.now();\nsleep(10).then(function() {\n  if (Date.now() - start < 5) throw new Error('too fast');\n});",
      "language": "javascript",
      "description": "Promise-based delay function",
      "tags": [
        "async",
        "utility",
        "promise"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "6a3aaa1c6821c735",
      "name": "median",
      "code": "function median(arr) {\n  if (!arr.length) return undefined;\n  var sorted = arr.slice().sort(function(a,b) { return a - b; });\n  var mid = sorted.length >>> 1;\n  return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;\n}",
      "testCode": "if (median([3,1,2]) !== 2) throw new Error('odd');\nif (median([4,1,3,2]) !== 2.5) throw new Error('even');\nif (median([5]) !== 5) throw new Error('single');\nif (median([]) !== undefined) throw new Error('empty');",
      "language": "javascript",
      "description": "Calculate median of number array",
      "tags": [
        "math",
        "utility",
        "statistics"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "5eddbe385767f913",
      "name": "sum",
      "code": "function sum(arr) {\n  var total = 0;\n  for (var i = 0; i < arr.length; i++) total += arr[i];\n  return total;\n}",
      "testCode": "if (sum([1,2,3,4]) !== 10) throw new Error('basic');\nif (sum([]) !== 0) throw new Error('empty');\nif (sum([-1, 1]) !== 0) throw new Error('negative');",
      "language": "javascript",
      "description": "Sum array of numbers",
      "tags": [
        "math",
        "utility",
        "array"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "1a94939d05e8aa00",
      "name": "random-int",
      "code": "function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}",
      "testCode": "for (var i = 0; i < 100; i++) {\n  var r = randomInt(1, 10);\n  if (r < 1 || r > 10) throw new Error('out of range: ' + r);\n  if (!Number.isInteger(r)) throw new Error('not int');\n}",
      "language": "javascript",
      "description": "Random integer between min and max inclusive",
      "tags": [
        "math",
        "utility",
        "random"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "5ee3f7fa4f7c6cfb",
      "name": "factorial",
      "code": "function factorial(n) {\n  if (n < 0) throw new Error('negative');\n  var result = 1;\n  for (var i = 2; i <= n; i++) result *= i;\n  return result;\n}",
      "testCode": "if (factorial(0) !== 1) throw new Error('0!');\nif (factorial(5) !== 120) throw new Error('5!');\nif (factorial(1) !== 1) throw new Error('1!');\ntry { factorial(-1); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }",
      "language": "javascript",
      "description": "Compute factorial of n",
      "tags": [
        "math",
        "algorithm"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "d582ab0524642165",
      "name": "gcd",
      "code": "function gcd(a, b) {\n  a = Math.abs(a); b = Math.abs(b);\n  while (b) { var t = b; b = a % b; a = t; }\n  return a;\n}",
      "testCode": "if (gcd(12, 8) !== 4) throw new Error('12,8');\nif (gcd(7, 13) !== 1) throw new Error('coprime');\nif (gcd(0, 5) !== 5) throw new Error('zero');",
      "language": "javascript",
      "description": "Greatest common divisor using Euclidean algorithm",
      "tags": [
        "math",
        "algorithm"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c1b32f6ca0ce546f",
      "name": "is-prime",
      "code": "function isPrime(n) {\n  if (n < 2) return false;\n  if (n < 4) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (var i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}",
      "testCode": "if (!isPrime(2)) throw new Error('2');\nif (!isPrime(17)) throw new Error('17');\nif (isPrime(1)) throw new Error('1');\nif (isPrime(15)) throw new Error('15');",
      "language": "javascript",
      "description": "Check if number is prime",
      "tags": [
        "math",
        "algorithm",
        "validation"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "abada022dd6bb506",
      "name": "fibonacci",
      "code": "function fibonacci(n) {\n  if (n <= 1) return n;\n  var a = 0, b = 1;\n  for (var i = 2; i <= n; i++) { var t = b; b = a + b; a = t; }\n  return b;\n}",
      "testCode": "if (fibonacci(0) !== 0) throw new Error('f0');\nif (fibonacci(1) !== 1) throw new Error('f1');\nif (fibonacci(10) !== 55) throw new Error('f10');\nif (fibonacci(20) !== 6765) throw new Error('f20');",
      "language": "javascript",
      "description": "Get nth Fibonacci number iteratively",
      "tags": [
        "math",
        "algorithm"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "add53db35d34d406",
      "name": "lerp",
      "code": "function lerp(a, b, t) {\n  return a + (b - a) * t;\n}",
      "testCode": "if (lerp(0, 10, 0.5) !== 5) throw new Error('mid');\nif (lerp(0, 10, 0) !== 0) throw new Error('start');\nif (lerp(0, 10, 1) !== 10) throw new Error('end');",
      "language": "javascript",
      "description": "Linear interpolation between two values",
      "tags": [
        "math",
        "utility",
        "animation"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0f382cd996f90ed9",
      "name": "clamp",
      "code": "function clamp(val, min, max) {\n  return Math.min(Math.max(val, min), max);\n}",
      "testCode": "if (clamp(5, 0, 10) !== 5) throw new Error('in range');\nif (clamp(-5, 0, 10) !== 0) throw new Error('below');\nif (clamp(15, 0, 10) !== 10) throw new Error('above');",
      "language": "javascript",
      "description": "Clamp number between min and max",
      "tags": [
        "math",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "247a664fdba85030",
      "name": "has-path",
      "code": "function hasPath(obj, path) {\n  var keys = path.split('.');\n  var current = obj;\n  for (var i = 0; i < keys.length; i++) {\n    if (current == null || !current.hasOwnProperty(keys[i])) return false;\n    current = current[keys[i]];\n  }\n  return true;\n}",
      "testCode": "if (!hasPath({a:{b:{c:1}}}, 'a.b.c')) throw new Error('deep');\nif (hasPath({a:1}, 'a.b')) throw new Error('missing');\nif (hasPath({}, 'x')) throw new Error('empty');",
      "language": "javascript",
      "description": "Check if object has nested path",
      "tags": [
        "object",
        "utility",
        "path"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "381ba46c32615911",
      "name": "freeze-deep",
      "code": "function freezeDeep(obj) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function(key) {\n    if (obj[key] && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {\n      freezeDeep(obj[key]);\n    }\n  });\n  return obj;\n}",
      "testCode": "var o = freezeDeep({a:1, b:{c:2}});\nif (!Object.isFrozen(o)) throw new Error('frozen');\nif (!Object.isFrozen(o.b)) throw new Error('deep frozen');",
      "language": "javascript",
      "description": "Recursively freeze object",
      "tags": [
        "object",
        "utility",
        "immutable"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "91c881184e44969f",
      "name": "defaults",
      "code": "function defaults(obj) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (source.hasOwnProperty(key) && obj[key] === undefined) {\n        obj[key] = source[key];\n      }\n    }\n  }\n  return obj;\n}",
      "testCode": "var r = defaults({a:1}, {a:9, b:2}, {c:3});\nif (r.a !== 1) throw new Error('no override');\nif (r.b !== 2) throw new Error('added b');\nif (r.c !== 3) throw new Error('added c');",
      "language": "javascript",
      "description": "Set default values without overriding existing",
      "tags": [
        "object",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "2472701e49bed30a",
      "name": "sample-array",
      "code": "function sampleArray(arr, n) {\n  var shuffled = arr.slice();\n  for (var i = shuffled.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;\n  }\n  return shuffled.slice(0, n || 1);\n}",
      "testCode": "var s = sampleArray([1,2,3,4,5], 3);\nif (s.length !== 3) throw new Error('length');\nif (!s.every(function(x) { return [1,2,3,4,5].indexOf(x) >= 0; })) throw new Error('items');\nif (sampleArray([], 3).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Get random sample of n items from array",
      "tags": [
        "array",
        "utility",
        "random"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "fe47f865fe999959",
      "name": "without",
      "code": "function without(arr) {\n  var values = Array.prototype.slice.call(arguments, 1);\n  var set = new Set(values);\n  return arr.filter(function(x) { return !set.has(x); });\n}",
      "testCode": "if (JSON.stringify(without([1,2,3,4], 2, 4)) !== '[1,3]') throw new Error('basic');\nif (without([1,1,1], 1).length !== 0) throw new Error('all');",
      "language": "javascript",
      "description": "Remove specified values from array",
      "tags": [
        "array",
        "utility",
        "filter"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "1c186145e5877f26",
      "name": "last",
      "code": "function last(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}",
      "testCode": "if (last([1,2,3]) !== 3) throw new Error('basic');\nif (last([]) !== undefined) throw new Error('empty');\nif (last([42]) !== 42) throw new Error('single');",
      "language": "javascript",
      "description": "Get last element of array",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3771a63ad4e6974a",
      "name": "take",
      "code": "function take(arr, n) {\n  return arr.slice(0, n);\n}",
      "testCode": "if (JSON.stringify(take([1,2,3,4], 2)) !== '[1,2]') throw new Error('basic');\nif (take([], 5).length !== 0) throw new Error('empty');\nif (JSON.stringify(take([1,2], 5)) !== '[1,2]') throw new Error('over');",
      "language": "javascript",
      "description": "Take first n elements from array",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "6d388553458fde9e",
      "name": "partition",
      "code": "function partition(arr, fn) {\n  var pass = [], fail = [];\n  for (var i = 0; i < arr.length; i++) {\n    (fn(arr[i]) ? pass : fail).push(arr[i]);\n  }\n  return [pass, fail];\n}",
      "testCode": "var r = partition([1,2,3,4,5], function(n) { return n % 2 === 0; });\nif (JSON.stringify(r[0]) !== '[2,4]') throw new Error('evens');\nif (JSON.stringify(r[1]) !== '[1,3,5]') throw new Error('odds');",
      "language": "javascript",
      "description": "Split array into two based on predicate",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "f109f71ef738b0c3",
      "name": "unique",
      "code": "function unique(arr) {\n  return Array.from(new Set(arr));\n}",
      "testCode": "if (JSON.stringify(unique([1,2,2,3,3,3])) !== '[1,2,3]') throw new Error('basic');\nif (unique([]).length !== 0) throw new Error('empty');\nif (unique([1]).length !== 1) throw new Error('single');",
      "language": "javascript",
      "description": "Get unique values from array",
      "tags": [
        "array",
        "utility",
        "set"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "4910379d16ca9290",
      "name": "range",
      "code": "function range(start, end, step) {\n  step = step || 1;\n  var result = [];\n  if (step > 0) { for (var i = start; i < end; i += step) result.push(i); }\n  else { for (var i = start; i > end; i += step) result.push(i); }\n  return result;\n}",
      "testCode": "if (JSON.stringify(range(0, 5)) !== '[0,1,2,3,4]') throw new Error('basic');\nif (JSON.stringify(range(0, 10, 2)) !== '[0,2,4,6,8]') throw new Error('step');\nif (JSON.stringify(range(5, 0, -1)) !== '[5,4,3,2,1]') throw new Error('neg');",
      "language": "javascript",
      "description": "Generate array of numbers in range",
      "tags": [
        "array",
        "utility",
        "generator"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "e01985733e6c357f",
      "name": "unzip",
      "code": "function unzip(pairs) {\n  if (!pairs.length) return [];\n  return pairs[0].map(function(_, i) {\n    return pairs.map(function(p) { return p[i]; });\n  });\n}",
      "testCode": "var r = unzip([[1,'a'],[2,'b'],[3,'c']]);\nif (JSON.stringify(r) !== '[[1,2,3],[\"a\",\"b\",\"c\"]]') throw new Error('basic');\nif (unzip([]).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Unzip array of tuples into separate arrays",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "57a20a77e58094e6",
      "name": "zip",
      "code": "function zip() {\n  var arrays = Array.prototype.slice.call(arguments);\n  var len = Math.min.apply(null, arrays.map(function(a) { return a.length; }));\n  var result = [];\n  for (var i = 0; i < len; i++) result.push(arrays.map(function(a) { return a[i]; }));\n  return result;\n}",
      "testCode": "var r = zip([1,2,3], ['a','b','c']);\nif (JSON.stringify(r) !== '[[1,\"a\"],[2,\"b\"],[3,\"c\"]]') throw new Error('basic');\nif (zip([1], [2,3]).length !== 1) throw new Error('unequal');",
      "language": "javascript",
      "description": "Zip multiple arrays into array of tuples",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "af7791a59a2c773a",
      "name": "union",
      "code": "function union(a, b) {\n  return Array.from(new Set(a.concat(b)));\n}",
      "testCode": "var r = union([1,2,3], [2,3,4]);\nif (JSON.stringify(r.sort()) !== '[1,2,3,4]') throw new Error('basic');\nif (union([], []).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Get unique items from both arrays",
      "tags": [
        "array",
        "utility",
        "set"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b8356dd076b7d0d5",
      "name": "intersection",
      "code": "function intersection(a, b) {\n  var set = new Set(b);\n  return a.filter(function(x) { return set.has(x); });\n}",
      "testCode": "if (JSON.stringify(intersection([1,2,3], [2,3,4])) !== '[2,3]') throw new Error('basic');\nif (intersection([1,2], [3,4]).length !== 0) throw new Error('none');",
      "language": "javascript",
      "description": "Get items present in both arrays",
      "tags": [
        "array",
        "utility",
        "set"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "66f97736a6b46a9d",
      "name": "difference",
      "code": "function difference(a, b) {\n  var set = new Set(b);\n  return a.filter(function(x) { return !set.has(x); });\n}",
      "testCode": "if (JSON.stringify(difference([1,2,3], [2,3,4])) !== '[1]') throw new Error('basic');\nif (difference([1,2], [1,2]).length !== 0) throw new Error('same');\nif (JSON.stringify(difference([1,2,3], [])) !== '[1,2,3]') throw new Error('empty b');",
      "language": "javascript",
      "description": "Get items in first array not in second",
      "tags": [
        "array",
        "utility",
        "set"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "d0c3d39a86200a2f",
      "name": "compact",
      "code": "function compact(arr) {\n  return arr.filter(Boolean);\n}",
      "testCode": "var r = compact([0, 1, false, 2, '', 3, null, undefined]);\nif (JSON.stringify(r) !== '[1,2,3]') throw new Error('basic: ' + JSON.stringify(r));\nif (compact([]).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Remove falsy values from array",
      "tags": [
        "array",
        "utility",
        "filter"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "9c4cb0cf0818a9ac",
      "name": "chunk",
      "code": "function chunk(arr, size) {\n  var result = [];\n  for (var i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(chunk([1,2,3,4,5], 2)) !== '[[1,2],[3,4],[5]]') throw new Error('basic');\nif (JSON.stringify(chunk([], 3)) !== '[]') throw new Error('empty');\nif (JSON.stringify(chunk([1], 5)) !== '[[1]]') throw new Error('small');",
      "language": "javascript",
      "description": "Split array into chunks of given size",
      "tags": [
        "array",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "c7b6286346fd7439",
      "name": "pad-string",
      "code": "function padString(str, len, ch, right) {\n  ch = ch || ' ';\n  while (str.length < len) {\n    str = right ? str + ch : ch + str;\n  }\n  return str;\n}",
      "testCode": "if (padString('5', 3, '0') !== '005') throw new Error('left');\nif (padString('5', 3, '0', true) !== '500') throw new Error('right');\nif (padString('hello', 3) !== 'hello') throw new Error('longer');",
      "language": "javascript",
      "description": "Pad string to target length",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "3dadbc69f633c701",
      "name": "count-occurrences",
      "code": "function countOccurrences(str, sub) {\n  if (!sub.length) return 0;\n  var count = 0, pos = 0;\n  while ((pos = str.indexOf(sub, pos)) !== -1) { count++; pos += sub.length; }\n  return count;\n}",
      "testCode": "if (countOccurrences('abcabc', 'abc') !== 2) throw new Error('two');\nif (countOccurrences('hello', 'x') !== 0) throw new Error('none');\nif (countOccurrences('aaa', 'a') !== 3) throw new Error('single');",
      "language": "javascript",
      "description": "Count occurrences of substring in string",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b357bbc238b2e764",
      "name": "is-palindrome",
      "code": "function isPalindrome(str) {\n  var clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return clean === clean.split('').reverse().join('');\n}",
      "testCode": "if (!isPalindrome('racecar')) throw new Error('basic');\nif (!isPalindrome('A man a plan a canal Panama')) throw new Error('sentence');\nif (isPalindrome('hello')) throw new Error('not palindrome');\nif (!isPalindrome('')) throw new Error('empty');",
      "language": "javascript",
      "description": "Check if string is a palindrome",
      "tags": [
        "string",
        "utility",
        "validation"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "b37f6311f2ec440b",
      "name": "repeat-string",
      "code": "function repeatString(str, n) {\n  var result = '';\n  for (var i = 0; i < n; i++) result += str;\n  return result;\n}",
      "testCode": "if (repeatString('ab', 3) !== 'ababab') throw new Error('basic');\nif (repeatString('x', 0) !== '') throw new Error('zero');\nif (repeatString('', 5) !== '') throw new Error('empty');",
      "language": "javascript",
      "description": "Repeat a string n times",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "4af2eb35a975131a",
      "name": "title-case",
      "code": "function titleCase(str) {\n  return str.replace(/\\b\\w/g, function(c) { return c.toUpperCase(); });\n}",
      "testCode": "if (titleCase('hello world') !== 'Hello World') throw new Error('basic');\nif (titleCase('foo bar baz') !== 'Foo Bar Baz') throw new Error('three');",
      "language": "javascript",
      "description": "Convert string to Title Case",
      "tags": [
        "string",
        "utility",
        "case"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "9b3e0ac51345b400",
      "name": "word-count",
      "code": "function wordCount(str) {\n  var trimmed = str.trim();\n  if (!trimmed) return 0;\n  return trimmed.split(/\\s+/).length;\n}",
      "testCode": "if (wordCount('hello world') !== 2) throw new Error('two');\nif (wordCount('  one  ') !== 1) throw new Error('padded');\nif (wordCount('') !== 0) throw new Error('empty');\nif (wordCount('a b c d') !== 4) throw new Error('four');",
      "language": "javascript",
      "description": "Count words in a string",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "efde031b37f09414",
      "name": "reverse-string",
      "code": "function reverseString(str) {\n  return str.split('').reverse().join('');\n}",
      "testCode": "if (reverseString('hello') !== 'olleh') throw new Error('basic');\nif (reverseString('') !== '') throw new Error('empty');\nif (reverseString('a') !== 'a') throw new Error('single');",
      "language": "javascript",
      "description": "Reverse a string",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "0e5fba9377e829aa",
      "name": "unescape-html",
      "code": "function unescapeHTML(str) {\n  var map = {'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};\n  return str.replace(/&(?:amp|lt|gt|quot|#39);/g, function(m) { return map[m]; });\n}",
      "testCode": "if (unescapeHTML('&lt;b&gt;') !== '<b>') throw new Error('tags');\nif (unescapeHTML('a&amp;b') !== 'a&b') throw new Error('amp');\nif (unescapeHTML('hello') !== 'hello') throw new Error('noop');",
      "language": "javascript",
      "description": "Unescape HTML entities back to characters",
      "tags": [
        "string",
        "html"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "9baf69f30add5701",
      "name": "escape-html",
      "code": "function escapeHTML(str) {\n  var map = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\n  return str.replace(/[&<>\"']/g, function(c) { return map[c]; });\n}",
      "testCode": "if (escapeHTML('<b>hi</b>') !== '&lt;b&gt;hi&lt;/b&gt;') throw new Error('tags');\nif (escapeHTML('a&b') !== 'a&amp;b') throw new Error('amp');\nif (escapeHTML('hello') !== 'hello') throw new Error('noop');",
      "language": "javascript",
      "description": "Escape HTML special characters",
      "tags": [
        "string",
        "security",
        "html"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "629bc127067d6a97",
      "name": "slugify",
      "code": "function slugify(str) {\n  return str.toLowerCase().trim()\n    .replace(/[^a-z0-9\\s-]/g, '')\n    .replace(/[\\s-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}",
      "testCode": "if (slugify('Hello World!') !== 'hello-world') throw new Error('basic');\nif (slugify('  foo  bar  ') !== 'foo-bar') throw new Error('spaces');\nif (slugify('a--b') !== 'a-b') throw new Error('dashes');",
      "language": "javascript",
      "description": "Convert string to URL-friendly slug",
      "tags": [
        "string",
        "utility",
        "url"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "90fbf86876d21228",
      "name": "kebab-case",
      "code": "function kebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\s]+/g, '-').toLowerCase();\n}",
      "testCode": "if (kebabCase('helloWorld') !== 'hello-world') throw new Error('camel');\nif (kebabCase('hello_world') !== 'hello-world') throw new Error('snake');\nif (kebabCase('Hello World') !== 'hello-world') throw new Error('space');",
      "language": "javascript",
      "description": "Convert string to kebab-case",
      "tags": [
        "string",
        "utility",
        "case"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "43b9b644bc649554",
      "name": "snake-case",
      "code": "function snakeCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\s]+/g, '_').toLowerCase();\n}",
      "testCode": "if (snakeCase('helloWorld') !== 'hello_world') throw new Error('camel');\nif (snakeCase('hello-world') !== 'hello_world') throw new Error('kebab');\nif (snakeCase('Hello World') !== 'hello_world') throw new Error('space');",
      "language": "javascript",
      "description": "Convert string to snake_case",
      "tags": [
        "string",
        "utility",
        "case"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "e252ee010c9489c8",
      "name": "camel-case",
      "code": "function camelCase(str) {\n  return str.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')\n            .replace(/^[A-Z]/, c => c.toLowerCase());\n}",
      "testCode": "if (camelCase('hello-world') !== 'helloWorld') throw new Error('kebab');\nif (camelCase('foo_bar') !== 'fooBar') throw new Error('snake');\nif (camelCase('Hello World') !== 'helloWorld') throw new Error('space');",
      "language": "javascript",
      "description": "Convert string to camelCase",
      "tags": [
        "string",
        "utility",
        "case"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "694b85fc756fbb70",
      "name": "capitalize",
      "code": "function capitalize(s) {\n  return s ? s[0].toUpperCase() + s.slice(1) : '';\n}",
      "testCode": "if (capitalize('hello') !== 'Hello') throw new Error('basic');\nif (capitalize('') !== '') throw new Error('empty');\nif (capitalize('A') !== 'A') throw new Error('already');",
      "language": "javascript",
      "description": "Capitalize first letter of string",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "129f72a6ec0c8424",
      "name": "validate-email",
      "code": "function validateEmail(email) {\n  if (typeof email !== 'string') return false;\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email) && email.length <= 254;\n}",
      "testCode": "if (!validateEmail(\"user@example.com\")) throw new Error(\"valid\");\nif (!validateEmail(\"a@b.co\")) throw new Error(\"short valid\");\nif (validateEmail(\"@example.com\")) throw new Error(\"no local\");\nif (validateEmail(\"user@\")) throw new Error(\"no domain\");\nif (validateEmail(\"\")) throw new Error(\"empty\");\nif (validateEmail(null)) throw new Error(\"null\");\nif (validateEmail(\"has space@x.com\")) throw new Error(\"space\");",
      "language": "javascript",
      "description": "Email validation with basic RFC compliance",
      "tags": [
        "validation",
        "email",
        "regex",
        "input",
        "sanitize"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 1
    },
    {
      "id": "c0ad2d1c310a0ab7",
      "name": "retry-async",
      "code": "async function retry(fn, maxRetries = 3, delay = 1000) {\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));\n      }\n    }\n  }\n  throw lastError;\n}",
      "testCode": "let attempts = 0;\nconst fn = async () => { attempts++; if (attempts < 3) throw new Error(\"fail\"); return \"ok\"; };\nretry(fn, 3, 1).then(r => {\n  if (r !== \"ok\") throw new Error(\"result\");\n  if (attempts !== 3) throw new Error(\"attempts: \" + attempts);\n});",
      "language": "javascript",
      "description": "Retry with exponential backoff for async operations",
      "tags": [
        "utility",
        "async",
        "retry",
        "backoff",
        "error-handling",
        "resilience"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "6f2e0def9a82319b",
      "name": "breadth-first-search",
      "code": "function bfs(graph, start) {\n  const visited = new Set([start]);\n  const queue = [start];\n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of (graph[node] || [])) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}",
      "testCode": "const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = bfs(g, 'a');\nif (r[0] !== 'a') throw new Error(\"start\");\nif (r.length !== 4) throw new Error(\"all nodes\");\nif (r.indexOf('b') > r.indexOf('d') && r.indexOf('c') > r.indexOf('d')) throw new Error(\"bfs order\");",
      "language": "javascript",
      "description": "Breadth-first search on adjacency list graph",
      "tags": [
        "graph",
        "search",
        "algorithm",
        "bfs",
        "traversal"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 1
    },
    {
      "id": "741e9780b2af6b49",
      "name": "merge-sort",
      "code": "function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = arr.length >>> 1;\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    result.push(left[i] <= right[j] ? left[i++] : right[j++]);\n  }\n  while (i < left.length) result.push(left[i++]);\n  while (j < right.length) result.push(right[j++]);\n  return result;\n}",
      "testCode": "const r1 = mergeSort([5,3,8,1,9,2]);\nif (JSON.stringify(r1) !== '[1,2,3,5,8,9]') throw new Error(\"sort: \" + r1);\nif (JSON.stringify(mergeSort([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(mergeSort([1])) !== '[1]') throw new Error(\"single\");\nif (JSON.stringify(mergeSort([3,1,1,2])) !== '[1,1,2,3]') throw new Error(\"dups\");",
      "language": "javascript",
      "description": "Merge sort — stable O(n log n) sorting",
      "tags": [
        "sort",
        "algorithm",
        "array",
        "merge-sort",
        "stable"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "5538509396c9f83e",
      "name": "binary-search",
      "code": "function binarySearch(arr, target) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}",
      "testCode": "if (binarySearch([1,2,3,4,5], 3) !== 2) throw new Error(\"mid\");\nif (binarySearch([1,2,3,4,5], 1) !== 0) throw new Error(\"first\");\nif (binarySearch([1,2,3,4,5], 5) !== 4) throw new Error(\"last\");\nif (binarySearch([1,2,3,4,5], 6) !== -1) throw new Error(\"missing\");\nif (binarySearch([], 1) !== -1) throw new Error(\"empty\");",
      "language": "javascript",
      "description": "Binary search on a sorted array — O(log n)",
      "tags": [
        "search",
        "algorithm",
        "array",
        "sorted",
        "binary-search"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 1
    },
    {
      "id": "64e99188159ebf34",
      "name": "observable-refined",
      "code": "class Observable {\n  constructor(fn) { this._fn = fn; }\n  subscribe(o) { return this._fn(typeof o==='function'?{next:o}:o); }\n  static of() {\n    const v = Array.prototype.slice.call(arguments);\n    return new Observable(function(o) { v.forEach(function(x){o.next(x)}); if(o.complete)o.complete(); return {unsubscribe:function(){}}; });\n  }\n  map(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){o.next(fn(v))},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n  filter(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){if(fn(v))o.next(v)},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n}",
      "testCode": "var values = [];\nObservable.of(1,2,3).subscribe({next:function(v){values.push(v)}});\nif (values.length !== 3 || values[2] !== 3) throw new Error('of');\nvar mapped = [];\nObservable.of(1,2,3).map(function(x){return x*10}).subscribe({next:function(v){mapped.push(v)}});\nif (mapped[0] !== 10 || mapped[2] !== 30) throw new Error('map');\nvar filtered = [];\nObservable.of(1,2,3,4).filter(function(x){return x%2===0}).subscribe({next:function(v){filtered.push(v)}});\nif (filtered.length !== 2 || filtered[0] !== 2) throw new Error('filter');\nvar u = Observable.of(1).subscribe({next:function(){}});\nif (typeof u.unsubscribe !== 'function') throw new Error('unsubscribe');",
      "language": "javascript",
      "description": "Observable with subscribe, map, filter, and static of() factory (refined)",
      "tags": [
        "observable",
        "reactive",
        "stream",
        "design-pattern",
        "functional",
        "subscribe",
        "auto-refined"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "cc6a5e37d3b20033",
      "name": "jwt-auth-refined",
      "code": "const crypto = require('crypto');\nclass JWTAuth {\n  constructor(secret) { this.secret = secret; }\n  _b(d) { return Buffer.from(d).toString('base64url'); }\n  _h(i) { return crypto.createHmac('sha256', this.secret).update(i).digest('base64url'); }\n  sign(payload, exp) {\n    exp = exp || '1h'; const u = {h:36e5,m:6e4,s:1e3};\n    const hd = this._b('{\"alg\":\"HS256\",\"typ\":\"JWT\"}');\n    const e = Date.now() + parseInt(exp) * (u[exp.slice(-1)] || 36e5);\n    const bd = this._b(JSON.stringify(Object.assign({}, payload, {exp: e})));\n    return hd + '.' + bd + '.' + this._h(hd + '.' + bd);\n  }\n  verify(t) {\n    const p = t.split('.'); if (this._h(p[0]+'.'+p[1]) !== p[2]) throw new Error('Invalid signature');\n    const d = JSON.parse(Buffer.from(p[1], 'base64url'));\n    if (d.exp && Date.now() > d.exp) throw new Error('Token expired'); return d;\n  }\n  decode(t) { return JSON.parse(Buffer.from(t.split('.')[1], 'base64url')); }\n}",
      "testCode": "var auth = new JWTAuth('test-secret-key-12345');\nvar token = auth.sign({ sub: 'user1', role: 'admin' });\nif (typeof token !== 'string' || token.split('.').length !== 3) throw new Error('token format');\nvar payload = auth.verify(token);\nif (payload.sub !== 'user1') throw new Error('verify payload');\nvar decoded = auth.decode(token);\nif (decoded.role !== 'admin') throw new Error('decode payload');\ntry { auth.verify(token+'x'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "javascript",
      "description": "JWT authentication with HMAC-SHA256 signing, verification, and decoding (refined)",
      "tags": [
        "jwt",
        "auth",
        "token",
        "hmac",
        "sha256",
        "crypto",
        "security",
        "validation",
        "auto-refined"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "12d1d555873a292c",
      "name": "observable",
      "code": "class Observable {\n  constructor(fn) { this._fn = fn; }\n  subscribe(o) { return this._fn(typeof o==='function'?{next:o}:o); }\n  static of() {\n    var v = Array.prototype.slice.call(arguments);\n    return new Observable(function(o) { v.forEach(function(x){o.next(x)}); if(o.complete)o.complete(); return {unsubscribe:function(){}}; });\n  }\n  map(fn) { var s=this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){o.next(fn(v))},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n  filter(fn) { var s=this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){if(fn(v))o.next(v)},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n}",
      "testCode": "var values = [];\nObservable.of(1,2,3).subscribe({next:function(v){values.push(v)}});\nif (values.length !== 3 || values[2] !== 3) throw new Error('of');\nvar mapped = [];\nObservable.of(1,2,3).map(function(x){return x*10}).subscribe({next:function(v){mapped.push(v)}});\nif (mapped[0] !== 10 || mapped[2] !== 30) throw new Error('map');\nvar filtered = [];\nObservable.of(1,2,3,4).filter(function(x){return x%2===0}).subscribe({next:function(v){filtered.push(v)}});\nif (filtered.length !== 2 || filtered[0] !== 2) throw new Error('filter');\nvar u = Observable.of(1).subscribe({next:function(){}});\nif (typeof u.unsubscribe !== 'function') throw new Error('unsubscribe');",
      "language": "javascript",
      "description": "Observable with subscribe, map, filter, and static of() factory",
      "tags": [
        "observable",
        "reactive",
        "stream",
        "design-pattern",
        "functional",
        "subscribe"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "4d1d51fa7faf9160",
      "name": "cors-middleware",
      "code": "function cors(opts) {\n  opts = opts || {};\n  var o = { origin: opts.origin||'*', methods: opts.methods||'GET,HEAD,PUT,PATCH,POST,DELETE',\n    headers: opts.headers||'', credentials: !!opts.credentials, maxAge: opts.maxAge||86400 };\n  return function(req, res, next) {\n    res.setHeader('Access-Control-Allow-Origin', o.origin);\n    if (o.credentials) res.setHeader('Access-Control-Allow-Credentials', 'true');\n    if (req.method === 'OPTIONS') {\n      res.setHeader('Access-Control-Allow-Methods', o.methods);\n      if (o.headers) res.setHeader('Access-Control-Allow-Headers', o.headers);\n      res.setHeader('Access-Control-Max-Age', String(o.maxAge));\n      res.writeHead(204); res.end(); return;\n    }\n    next();\n  };\n}",
      "testCode": "var handler = cors({ origin: 'http://example.com', methods: 'GET,POST', credentials: true });\nvar headers = {};\nvar res = { setHeader: function(k,v){headers[k]=v;}, writeHead: function(){}, end: function(){} };\nhandler({ method: 'OPTIONS' }, res, function(){});\nif (headers['Access-Control-Allow-Origin'] !== 'http://example.com') throw new Error('origin');\nif (headers['Access-Control-Allow-Credentials'] !== 'true') throw new Error('credentials');\nif (headers['Access-Control-Allow-Methods'] !== 'GET,POST') throw new Error('methods');\nvar called = false; headers = {};\nhandler({ method: 'GET' }, res, function(){ called = true; });\nif (!called) throw new Error('next not called');",
      "language": "javascript",
      "description": "CORS middleware with preflight handling, origin control, and credentials support",
      "tags": [
        "cors",
        "middleware",
        "http",
        "headers",
        "preflight",
        "security",
        "api"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "defe9355e5d89d23",
      "name": "jwt-auth",
      "code": "const crypto = require('crypto');\nclass JWTAuth {\n  constructor(secret) { this.secret = secret; }\n  _b(d) { return Buffer.from(d).toString('base64url'); }\n  _h(i) { return crypto.createHmac('sha256', this.secret).update(i).digest('base64url'); }\n  sign(payload, exp) {\n    exp = exp || '1h'; var u = {h:36e5,m:6e4,s:1e3};\n    var hd = this._b('{\"alg\":\"HS256\",\"typ\":\"JWT\"}');\n    var e = Date.now() + parseInt(exp) * (u[exp.slice(-1)] || 36e5);\n    var bd = this._b(JSON.stringify(Object.assign({}, payload, {exp: e})));\n    return hd + '.' + bd + '.' + this._h(hd + '.' + bd);\n  }\n  verify(t) {\n    var p = t.split('.'); if (this._h(p[0]+'.'+p[1]) !== p[2]) throw new Error('Invalid signature');\n    var d = JSON.parse(Buffer.from(p[1], 'base64url'));\n    if (d.exp && Date.now() > d.exp) throw new Error('Token expired'); return d;\n  }\n  decode(t) { return JSON.parse(Buffer.from(t.split('.')[1], 'base64url')); }\n}",
      "testCode": "var auth = new JWTAuth('test-secret-key-12345');\nvar token = auth.sign({ sub: 'user1', role: 'admin' });\nif (typeof token !== 'string' || token.split('.').length !== 3) throw new Error('token format');\nvar payload = auth.verify(token);\nif (payload.sub !== 'user1') throw new Error('verify payload');\nvar decoded = auth.decode(token);\nif (decoded.role !== 'admin') throw new Error('decode payload');\ntry { auth.verify(token+'x'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "javascript",
      "description": "JWT authentication with HMAC-SHA256 signing, verification, and decoding",
      "tags": [
        "jwt",
        "auth",
        "token",
        "hmac",
        "sha256",
        "crypto",
        "security",
        "validation"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "0a66cb8e263c0648",
      "name": "csv-parser",
      "code": "function parseCSV(t, o) {\n  o = o || {}; var d = o.delimiter || ',', h = o.headers !== false, q = o.quote || '\"';\n  var rows = [], row = [''], inQ = false, col = 0;\n  for (var i = 0; i < t.length; i++) { var c = t[i];\n    if (inQ) { if (c===q&&t[i+1]===q){row[col]+=q;i++} else if (c===q) inQ=false; else row[col]+=c; }\n    else if (c===q) inQ=true; else if (c===d) row[++col]='';\n    else if (c==='\\n'||(c==='\\r'&&t[i+1]==='\\n')){if(c==='\\r')i++;rows.push(row);row=[''];col=0;}\n    else row[col]+=c;\n  }\n  if (row.length>1||row[0]!=='') rows.push(row);\n  if (!h||!rows.length) return rows;\n  var hd=rows[0];\n  return rows.slice(1).map(function(r){var o={};hd.forEach(function(n,i){o[n]=r[i]||''});return o;});\n}",
      "testCode": "var r1 = parseCSV('name,age\\nAlice,30\\nBob,25');\nif (r1.length !== 2) throw new Error('row count');\nif (r1[0].name !== 'Alice') throw new Error('field value');\nif (r1[1].age !== '25') throw new Error('second row');\nvar r2 = parseCSV('\"a,b\",c\\n\"d\"\"e\",f', { headers: false });\nif (r2[0][0] !== 'a,b') throw new Error('quoted comma');\nif (r2[1][0] !== 'd\"e') throw new Error('escaped quote');",
      "language": "javascript",
      "description": "CSV parser handling quoted fields, escaped quotes, and newlines within quotes",
      "tags": [
        "csv",
        "parser",
        "io",
        "text",
        "delimiter",
        "data-import"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "1cc7fba70f6f699e",
      "name": "retry-with-backoff",
      "code": "async function retryWithBackoff(fn, options = {}) {\n  const { maxRetries = 3, baseDelay = 100, maxDelay = 5000, jitter = true } = options;\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        let delay = Math.min(baseDelay * Math.pow(2, i), maxDelay);\n        if (jitter) delay *= 0.5 + Math.random() * 0.5;\n        await new Promise(r => setTimeout(r, delay));\n      }\n    }\n  }\n  throw lastError;\n}",
      "testCode": "let count = 0;\nconst flaky = async () => { count++; if (count < 3) throw new Error('not yet'); return 'done'; };\nconst result = await retryWithBackoff(flaky, { maxRetries: 3, baseDelay: 10 });\nif (result !== 'done') throw new Error('should return successful result');\nif (count !== 3) throw new Error('should have retried until success');\nlet threw = false;\ntry { await retryWithBackoff(() => { throw new Error('always'); }, { maxRetries: 2, baseDelay: 10 }); }\ncatch(e) { threw = true; if (e.message !== 'always') throw new Error('should throw last error'); }\nif (!threw) throw new Error('should throw after retries exhausted');",
      "language": "javascript",
      "description": "Async retry with exponential backoff, jitter, configurable max retries and delay bounds",
      "tags": [
        "retry",
        "backoff",
        "exponential",
        "resilience",
        "async",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "5b1cbe374c27a771",
      "name": "state-machine",
      "code": "class StateMachine {\n  constructor(config) {\n    this._state = config.initial;\n    this._t = {};\n    for (const t of config.transitions || []) this._t[t.from + ':' + t.event] = t.to;\n  }\n  transition(event) {\n    const next = this._t[this._state + ':' + event];\n    if (!next) throw new Error('Invalid: ' + event + ' from ' + this._state);\n    this._state = next;\n    return this._state;\n  }\n  can(event) {\n    return !!(this._t[this._state + ':' + event]);\n  }\n  getState() { return this._state; }\n}",
      "testCode": "const sm = new StateMachine({\n  initial: 'idle',\n  transitions: [\n    { from: 'idle', event: 'start', to: 'running' },\n    { from: 'running', event: 'pause', to: 'paused' },\n    { from: 'paused', event: 'resume', to: 'running' },\n    { from: 'running', event: 'stop', to: 'idle' }\n  ]\n});\nif (sm.getState() !== 'idle') throw new Error('initial state should be idle');\nif (!sm.can('start')) throw new Error('should be able to start from idle');\nif (sm.can('pause')) throw new Error('should not pause from idle');\nsm.transition('start');\nif (sm.getState() !== 'running') throw new Error('should be running after start');\nlet threw = false;\ntry { sm.transition('resume'); } catch(e) { threw = true; }\nif (!threw) throw new Error('invalid transition should throw');",
      "language": "javascript",
      "description": "Finite state machine with declarative transitions and state querying",
      "tags": [
        "state-machine",
        "fsm",
        "design-pattern",
        "state",
        "transitions"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "7414868469b9fc87",
      "name": "connection-pool",
      "code": "class ConnectionPool {\n  constructor(factory, opts = {}) {\n    this._f = factory; this._max = opts.max || 10;\n    this._p = []; this._a = 0; this._w = [];\n  }\n  async acquire() {\n    if (this._p.length > 0) { this._a++; return this._p.pop(); }\n    if (this._a < this._max) { this._a++; return this._f(); }\n    return new Promise(r => this._w.push(r));\n  }\n  release(conn) {\n    if (this._w.length > 0) this._w.shift()(conn);\n    else { this._a--; this._p.push(conn); }\n  }\n  drain() {\n    this._p = []; this._w.forEach(r => r(null));\n    this._w = []; this._a = 0;\n  }\n}",
      "testCode": "let created = 0;\nconst pool = new ConnectionPool(() => ({ id: ++created }), { max: 2 });\nconst c1 = await pool.acquire();\nconst c2 = await pool.acquire();\nif (created !== 2) throw new Error('should create 2 connections');\npool.release(c1);\nconst c3 = await pool.acquire();\nif (c3.id !== c1.id) throw new Error('should reuse released connection');\nif (created !== 2) throw new Error('should not create new after reuse');\nawait pool.drain();",
      "language": "javascript",
      "description": "Object connection pool with configurable max size, factory function, and waiting queue",
      "tags": [
        "pool",
        "connection",
        "concurrency",
        "resource",
        "database",
        "connection-pool"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "cc4a76caa37ba4d6",
      "name": "memoize-py",
      "code": "def memoize(fn):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = fn(*args)\n        return cache[args]\n    wrapper.cache = cache\n    return wrapper",
      "testCode": "calls = 0\ndef add(a, b):\n    global calls\n    calls += 1\n    return a + b\nmemo_add = memoize(add)\nassert memo_add(1, 2) == 3\nassert memo_add(1, 2) == 3\nassert calls == 1, f\"should cache: {calls}\"",
      "language": "python",
      "description": "Memoize decorator — caches function results by arguments",
      "tags": [
        "utility",
        "cache",
        "memoize",
        "decorator",
        "performance"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.99
    },
    {
      "id": "14248cba342c63c4",
      "name": "parse-cookie",
      "code": "function parseCookie(str) {\n  if (!str) return {};\n  return str.split(';').reduce(function(obj, pair) {\n    var parts = pair.trim().split('=');\n    var key = parts[0].trim();\n    obj[key] = parts.slice(1).join('=').trim();\n    return obj;\n  }, {});\n}",
      "testCode": "var r = parseCookie('foo=bar; baz=42; name=hello');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (r.name !== 'hello') throw new Error('name');\nif (Object.keys(parseCookie('')).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Parse cookie header string to object",
      "tags": [
        "http",
        "utility",
        "cookie"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "d7cc6686813e9a5e",
      "name": "parse-query-string",
      "code": "function parseQueryString(qs) {\n  if (!qs || qs === '?') return {};\n  return qs.replace(/^\\?/, '').split('&').reduce(function(obj, pair) {\n    var parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '');\n    return obj;\n  }, {});\n}",
      "testCode": "var r = parseQueryString('?foo=bar&baz=42');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (Object.keys(parseQueryString('')).length !== 0) throw new Error('empty');",
      "language": "javascript",
      "description": "Parse URL query string to object",
      "tags": [
        "http",
        "utility",
        "url"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "eb59fdfd2718d9e5",
      "name": "rename-keys",
      "code": "function renameKeys(obj, keyMap) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    var newKey = keyMap[keys[i]] || keys[i];\n    result[newKey] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = renameKeys({a:1, b:2}, {a:'x'});\nif (r.x !== 1) throw new Error('renamed');\nif (r.b !== 2) throw new Error('kept');\nif ('a' in r) throw new Error('old key');",
      "language": "javascript",
      "description": "Rename object keys via mapping",
      "tags": [
        "object",
        "utility",
        "transform"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "f0e2edd45f6dc495",
      "name": "invert",
      "code": "function invert(obj) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[obj[keys[i]]] = keys[i];\n  }\n  return result;\n}",
      "testCode": "var r = invert({a:'x', b:'y'});\nif (r.x !== 'a' || r.y !== 'b') throw new Error('inverted');",
      "language": "javascript",
      "description": "Swap keys and values in object",
      "tags": [
        "object",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "6558354abfae7268",
      "name": "map-keys",
      "code": "function mapKeys(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[fn(keys[i], obj[keys[i]])] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = mapKeys({a:1,b:2}, function(k) { return k.toUpperCase(); });\nif (r.A !== 1 || r.B !== 2) throw new Error('mapped');\nif ('a' in r) throw new Error('old key');",
      "language": "javascript",
      "description": "Map over object keys",
      "tags": [
        "object",
        "utility",
        "transform"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "c427867d966dd6cb",
      "name": "map-values",
      "code": "function mapValues(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = fn(obj[keys[i]], keys[i]);\n  }\n  return result;\n}",
      "testCode": "var r = mapValues({a:1,b:2}, function(v) { return v * 2; });\nif (r.a !== 2 || r.b !== 4) throw new Error('doubled');",
      "language": "javascript",
      "description": "Map over object values",
      "tags": [
        "object",
        "utility",
        "transform"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "093afc662a89d1f7",
      "name": "deep-merge",
      "code": "function deepMerge(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        target[key] = deepMerge(target[key] || {}, source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}",
      "testCode": "var r = deepMerge({a:1, b:{c:2, d:3}}, {b:{c:9, e:4}});\nif (r.a !== 1) throw new Error('a');\nif (r.b.c !== 9) throw new Error('override');\nif (r.b.d !== 3) throw new Error('keep');\nif (r.b.e !== 4) throw new Error('add');",
      "language": "javascript",
      "description": "Deep merge multiple objects",
      "tags": [
        "object",
        "utility",
        "merge"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "92da5722e7965801",
      "name": "omit",
      "code": "function omit(obj, keys) {\n  var set = new Set(keys);\n  var result = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k) && !set.has(k)) result[k] = obj[k];\n  }\n  return result;\n}",
      "testCode": "var r = omit({a:1,b:2,c:3}, ['b']);\nif (r.a !== 1 || r.c !== 3) throw new Error('kept');\nif ('b' in r) throw new Error('omitted');",
      "language": "javascript",
      "description": "Omit specified keys from object",
      "tags": [
        "object",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "e16dec36c4c3904c",
      "name": "pick",
      "code": "function pick(obj, keys) {\n  var result = {};\n  for (var i = 0; i < keys.length; i++) {\n    if (keys[i] in obj) result[keys[i]] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = pick({a:1,b:2,c:3}, ['a','c']);\nif (r.a !== 1 || r.c !== 3) throw new Error('picked');\nif ('b' in r) throw new Error('excluded');",
      "language": "javascript",
      "description": "Pick specified keys from object",
      "tags": [
        "object",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "ea678b09ce2b3c34",
      "name": "group-by",
      "code": "function groupBy(arr, keyFn) {\n  const groups = {};\n  for (const item of arr) {\n    const key = typeof keyFn === 'function' ? keyFn(item) : item[keyFn];\n    (groups[key] = groups[key] || []).push(item);\n  }\n  return groups;\n}",
      "testCode": "const data = [{n:'a',t:1},{n:'b',t:1},{n:'c',t:2}];\nconst g = groupBy(data, 't');\nif (g[1].length !== 2) throw new Error(\"group 1\");\nif (g[2].length !== 1) throw new Error(\"group 2\");\nconst g2 = groupBy(data, item => item.t);\nif (g2[1].length !== 2) throw new Error(\"fn key\");",
      "language": "javascript",
      "description": "Group array items by a key or function",
      "tags": [
        "transformation",
        "array",
        "group",
        "aggregate",
        "utility"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "48f5b64c9a4f67c5",
      "name": "trie",
      "code": "class Trie {\n  constructor() { this.root = {}; }\n  insert(word) {\n    let node = this.root;\n    for (const ch of word) { node = node[ch] = node[ch] || {}; }\n    node._end = true;\n  }\n  search(word) {\n    let node = this.root;\n    for (const ch of word) { if (!node[ch]) return false; node = node[ch]; }\n    return node._end === true;\n  }\n  startsWith(prefix) {\n    let node = this.root;\n    for (const ch of prefix) { if (!node[ch]) return false; node = node[ch]; }\n    return true;\n  }\n}",
      "testCode": "const t = new Trie();\nt.insert(\"hello\"); t.insert(\"help\");\nif (!t.search(\"hello\")) throw new Error(\"find hello\");\nif (t.search(\"hell\")) throw new Error(\"partial\");\nif (!t.startsWith(\"hel\")) throw new Error(\"prefix\");\nif (t.startsWith(\"xyz\")) throw new Error(\"bad prefix\");",
      "language": "javascript",
      "description": "Trie (prefix tree) for fast string lookups and prefix search",
      "tags": [
        "data-structure",
        "trie",
        "string",
        "prefix",
        "search"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.99
    },
    {
      "id": "a2691e7376540843",
      "name": "deep-clone",
      "code": "function deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) {\n    cloned[key] = deepClone(obj[key]);\n  }\n  return cloned;\n}",
      "testCode": "const orig = { a: 1, b: { c: [1,2,{d:3}] }, e: new Date(0) };\nconst clone = deepClone(orig);\nif (clone === orig) throw new Error(\"same ref\");\nif (clone.b === orig.b) throw new Error(\"shallow copy\");\nclone.b.c[2].d = 999;\nif (orig.b.c[2].d === 999) throw new Error(\"mutation leaked\");\nif (clone.e.getTime() !== 0) throw new Error(\"date clone\");\nif (deepClone(null) !== null) throw new Error(\"null\");\nif (deepClone(42) !== 42) throw new Error(\"primitive\");",
      "language": "javascript",
      "description": "Deep clone — recursively copies objects, arrays, dates, regexps",
      "tags": [
        "utility",
        "clone",
        "deep-copy",
        "object",
        "immutable"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.99
    },
    {
      "id": "4776befda23ee7dc",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "0f59cc0fd8fb3ebe",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "e5286716d36c92ed",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "b2c4b415dc55149a",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "dbcf9d86484a3d98",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "53756da61146f45e",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "958ecbd01b0e6c25",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "e7a34f82771057fe",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "553bc413fd942559",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "3d17e6e6367f4ba4",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "b654b51d80971b03",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "444f0dea1296ad77",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "c9051412bb58e682",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "622f44529c0ff533",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "eda7eeee98703f09",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "171206ca1218f774",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "2ee407d739625433",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "e5105ef211be82d4",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "5e4382f0e3e7eeff",
      "name": "linked-list-rust",
      "code": "pub struct LinkedList<T> {\n    head: Option<Box<Node<T>>>,\n    len: usize,\n}\n\nstruct Node<T> {\n    value: T,\n    next: Option<Box<Node<T>>>,\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> Self {\n        LinkedList { head: None, len: 0 }\n    }\n\n    pub fn push_front(&mut self, value: T) {\n        let node = Box::new(Node { value, next: self.head.take() });\n        self.head = Some(node);\n        self.len += 1;\n    }\n\n    pub fn pop_front(&mut self) -> Option<T> {\n        self.head.take().map(|node| {\n            self.head = node.next;\n            self.len -= 1;\n            node.value\n        })\n    }\n\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.head.is_none()\n    }\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_linked_list() {\n    let mut ll = LinkedList::new();\n    ll.push_front(3);\n    ll.push_front(2);\n    ll.push_front(1);\n    assert_eq!(ll.len(), 3);\n    assert_eq!(ll.pop_front(), Some(1));\n    assert_eq!(ll.pop_front(), Some(2));\n    assert_eq!(ll.pop_front(), Some(3));\n    assert!(ll.is_empty());\n}",
      "language": "rust",
      "description": "Singly linked list using Box and Option",
      "tags": [
        "data-structure",
        "linked-list",
        "ownership",
        "rust-native"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "4db9ed7863fa70f5",
      "name": "iterator-pipeline-rust",
      "code": "pub fn top_n_words(text: &str, n: usize) -> Vec<(String, usize)> {\n    let mut counts = std::collections::HashMap::new();\n    for word in text.split_whitespace() {\n        let w = word.to_lowercase();\n        *counts.entry(w).or_insert(0usize) += 1;\n    }\n    let mut pairs: Vec<_> = counts.into_iter().collect();\n    pairs.sort_by(|a, b| b.1.cmp(&a.1));\n    pairs.truncate(n);\n    pairs\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_top_n_words() {\n    let result = top_n_words(\"the cat sat on the mat the\", 2);\n    assert_eq!(result[0].0, \"the\");\n    assert_eq!(result[0].1, 3);\n    assert_eq!(result.len(), 2);\n}",
      "language": "rust",
      "description": "Word frequency counter with iterator pipeline",
      "tags": [
        "iterator",
        "string",
        "frequency",
        "rust-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "a302dd272c5091df",
      "name": "result-chain-rust",
      "code": "use std::num::ParseIntError;\n\npub fn parse_and_double(s: &str) -> Result<i64, ParseIntError> {\n    s.trim().parse::<i64>().map(|n| n * 2)\n}\n\npub fn parse_sum(values: &[&str]) -> Result<i64, ParseIntError> {\n    values.iter()\n        .map(|s| s.trim().parse::<i64>())\n        .try_fold(0i64, |acc, r| r.map(|n| acc + n))\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_result_chain() {\n    assert_eq!(parse_and_double(\"21\"), Ok(42));\n    assert!(parse_and_double(\"abc\").is_err());\n    assert_eq!(parse_sum(&[\"1\", \"2\", \"3\"]), Ok(6));\n    assert!(parse_sum(&[\"1\", \"x\"]).is_err());\n}",
      "language": "rust",
      "description": "Result chaining with map and try_fold",
      "tags": [
        "result",
        "error-handling",
        "iterator",
        "rust-native"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "e823849172ca8a98",
      "name": "binary-search-rust",
      "code": "pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {\n    arr.binary_search(target).ok()\n}\n\npub fn binary_search_by<T, F>(arr: &[T], mut cmp: F) -> Option<usize>\nwhere\n    F: FnMut(&T) -> std::cmp::Ordering,\n{\n    arr.binary_search_by(|item| cmp(item)).ok()\n}",
      "testCode": "use super::*;\n\n#[test]\nfn test_binary_search() {\n    let arr = vec![1, 2, 3, 4, 5];\n    assert_eq!(binary_search(&arr, &3), Some(2));\n    assert_eq!(binary_search(&arr, &1), Some(0));\n    assert_eq!(binary_search(&arr, &6), None);\n    let empty: Vec<i32> = vec![];\n    assert_eq!(binary_search(&empty, &1), None);\n}",
      "language": "rust",
      "description": "Binary search using slice::binary_search — idiomatic Rust",
      "tags": [
        "search",
        "algorithm",
        "slice",
        "rust-native"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "8a0f45631926481f",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "ee22a50a8d0990c6",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "70a396f9eb12480e",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "e9053d6e3fc7eb89",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "411a432ac36dc6b3",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "889e9c7f3a96982a",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "bdef8468d6177215",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "607cebc6a5a45e8c",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "350e62826a59b6a7",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "79726858d8925393",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "c5ead4ced98e72db",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "37a77087b1a8f232",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "ccd8949e3cd27287",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "0521bb6c9821c579",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "79297e93e24d1a66",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "d37a3be0992bbdd8",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "ac0f69b9084e7a4f",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "67c1a14728a64792",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "ed4fe5a458410fb6",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "350746e85fbb16e3",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "20bf7301ea2c55dd",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "3ccc25f85424b37e",
      "name": "pub-sub-ts-refined",
      "code": "class PubSub {\n  constructor() { this._subs = new Map(); }\n  subscribe(topic, handler) {\n    if (!this._subs.has(topic)) this._subs.set(topic, new Set());\n    this._subs.get(topic).add(handler); let self = this;\n    return function() { let h = self._subs.get(topic); if (h){h.delete(handler);if (!h.size)self._subs.delete(topic)} };\n  }\n  publish(topic, data) {\n    for (let e of this._subs) { let p = e[0], h = e[1];\n      if (p===topic||p==='*'||(p.includes('*')&&new RegExp('^'+p.split('*').join('.*')+'$').test(topic)))\n        h.forEach(function(fn){fn(data,topic)});\n    }\n  }\n  topics() { return Array.from(this._subs.keys()); }\n}",
      "testCode": "var ps = new PubSub();\nvar msgs = [];\nvar unsub = ps.subscribe('chat', function(d){ msgs.push(d); });\nps.publish('chat', 'hello');\nps.publish('chat', 'world');\nif (msgs.length !== 2 || msgs[0] !== 'hello') throw new Error('basic pub/sub');\nunsub();\nps.publish('chat', 'gone');\nif (msgs.length !== 2) throw new Error('unsubscribe failed');\nvar wild = [];\nps.subscribe('*', function(d){ wild.push(d); });\nps.publish('anything', 'test');\nif (wild.length !== 1) throw new Error('wildcard');\nif (!ps.topics().includes('*')) throw new Error('topics list');",
      "language": "typescript",
      "description": "Publish-subscribe system with wildcard topic matching and unsubscribe support (TypeScript variant) (refined)",
      "tags": [
        "pub-sub",
        "pubsub",
        "event",
        "design-pattern",
        "message",
        "wildcard",
        "topic",
        "variant",
        "typescript",
        "auto-refined",
        "auto-generated"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "d80a358926e9fea5",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "54ba3c1829095cc9",
      "name": "pub-sub-ts",
      "code": "class PubSub {\n  constructor() { this._subs = new Map(); }\n  subscribe(topic, handler) {\n    if (!this._subs.has(topic)) this._subs.set(topic, new Set());\n    this._subs.get(topic).add(handler); let self = this;\n    return function() { let h = self._subs.get(topic); if(h){h.delete(handler);if(!h.size)self._subs.delete(topic)} };\n  }\n  publish(topic, data) {\n    for (let e of this._subs) { let p=e[0], h=e[1];\n      if (p===topic||p==='*'||(p.includes('*')&&new RegExp('^'+p.split('*').join('.*')+'$').test(topic)))\n        h.forEach(function(fn){fn(data,topic)});\n    }\n  }\n  topics() { return Array.from(this._subs.keys()); }\n}",
      "testCode": "var ps = new PubSub();\nvar msgs = [];\nvar unsub = ps.subscribe('chat', function(d){ msgs.push(d); });\nps.publish('chat', 'hello');\nps.publish('chat', 'world');\nif (msgs.length !== 2 || msgs[0] !== 'hello') throw new Error('basic pub/sub');\nunsub();\nps.publish('chat', 'gone');\nif (msgs.length !== 2) throw new Error('unsubscribe failed');\nvar wild = [];\nps.subscribe('*', function(d){ wild.push(d); });\nps.publish('anything', 'test');\nif (wild.length !== 1) throw new Error('wildcard');\nif (!ps.topics().includes('*')) throw new Error('topics list');",
      "language": "typescript",
      "description": "Publish-subscribe system with wildcard topic matching and unsubscribe support (TypeScript variant)",
      "tags": [
        "pub-sub",
        "pubsub",
        "event",
        "design-pattern",
        "message",
        "wildcard",
        "topic",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "1384d4f848a53673",
      "name": "completion-debounce",
      "code": "function debounce(fn, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "86dc680292edcaa9",
      "name": "promise-timeout-ts",
      "code": "function promiseTimeout(promise: any, ms: any) {\n  let timeout = new Promise(function(_, reject) {\n    setTimeout(function() { reject(new Error('timeout')); }, ms);\n  });\n  return Promise.race([promise, timeout]);\n}",
      "testCode": "promiseTimeout(Promise.resolve(42), 100).then(function(v) {\n  if (v !== 42) throw new Error('value');\n});",
      "language": "typescript",
      "description": "Wrap promise with timeout (TypeScript variant)",
      "tags": [
        "async",
        "utility",
        "promise",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "3be78bc72ebf0e69",
      "name": "p-map-ts",
      "code": "function pMap(items: any[], fn: Function, concurrency: any) {\n  concurrency = concurrency || Infinity;\n  let results = new Array(items.length);\n  let index = 0;\n  function worker() {\n    let work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }\n  let workers = [];\n  for (let i = 0; i < Math.min(concurrency, items.length); i++) workers.push(worker());\n  return Promise.all(workers).then(function() { return results; });\n}",
      "testCode": "pMap([1,2,3], function(x) { return Promise.resolve(x * 2); }, 2).then(function(r) {\n  if (JSON.stringify(r) !== '[2,4,6]') throw new Error('result: ' + JSON.stringify(r));\n});",
      "language": "typescript",
      "description": "Parallel map with concurrency limit (TypeScript variant)",
      "tags": [
        "async",
        "utility",
        "concurrency",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "8e8920178648027a",
      "name": "retry-async-ts",
      "code": "async function retry(fn: Function, maxRetries: number, delay: number) {\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));\n      }\n    }\n  }\n  throw lastError;\n}",
      "testCode": "let attempts = 0;\nconst fn = async () => { attempts++; if (attempts < 3) throw new Error(\"fail\"); return \"ok\"; };\nretry(fn, 3, 1).then(r => {\n  if (r !== \"ok\") throw new Error(\"result\");\n  if (attempts !== 3) throw new Error(\"attempts: \" + attempts);\n});",
      "language": "typescript",
      "description": "Retry with exponential backoff for async operations (TypeScript variant)",
      "tags": [
        "utility",
        "async",
        "retry",
        "backoff",
        "error-handling",
        "resilience",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "c1262e459876ed8a",
      "name": "truncate",
      "code": "function truncate(str, maxLen, suffix) {\n  suffix = suffix || '...';\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - suffix.length) + suffix;\n}",
      "testCode": "if (truncate('hello world', 8) !== 'hello...') throw new Error('basic');\nif (truncate('hi', 10) !== 'hi') throw new Error('short');\nif (truncate('abcdef', 5, '..') !== 'abc..') throw new Error('custom');",
      "language": "javascript",
      "description": "Truncate string to max length with suffix",
      "tags": [
        "string",
        "utility"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.97
    },
    {
      "id": "62971b17826d550d",
      "name": "flatten-deep",
      "code": "function flattenDeep(arr) {\n  const result = [];\n  const stack = [...arr];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    if (Array.isArray(item)) {\n      stack.push(...item);\n    } else {\n      result.unshift(item);\n    }\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(flattenDeep([1,[2,[3,[4]]]])) !== '[1,2,3,4]') throw new Error(\"nested\");\nif (JSON.stringify(flattenDeep([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(flattenDeep([1,2,3])) !== '[1,2,3]') throw new Error(\"flat\");",
      "language": "javascript",
      "description": "Flatten deeply nested arrays iteratively (no recursion limit)",
      "tags": [
        "transformation",
        "array",
        "flatten",
        "iterative",
        "utility"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "3e2f180e21397ffa",
      "name": "pipe",
      "code": "function pipe(...fns) {\n  return function(input) {\n    return fns.reduce((val, fn) => fn(val), input);\n  };\n}",
      "testCode": "const double = x => x * 2;\nconst inc = x => x + 1;\nconst str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");",
      "language": "javascript",
      "description": "Function pipe — compose left-to-right",
      "tags": [
        "utility",
        "functional",
        "pipe",
        "compose",
        "transform"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "ce8b157adbdc651e",
      "name": "memoize",
      "code": "function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}",
      "testCode": "let calls = 0;\nconst add = memoize((a, b) => { calls++; return a + b; });\nif (add(1, 2) !== 3) throw new Error(\"first call\");\nif (add(1, 2) !== 3) throw new Error(\"cached call\");\nif (calls !== 1) throw new Error(\"should cache: \" + calls);\nif (add(2, 3) !== 5) throw new Error(\"diff args\");\nif (calls !== 2) throw new Error(\"new args: \" + calls);",
      "language": "javascript",
      "description": "Memoize — caches function results by arguments",
      "tags": [
        "utility",
        "cache",
        "memoize",
        "performance",
        "optimization"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "d46914445a22c38e",
      "name": "throttle",
      "code": "function throttle(fn, limit) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      return fn.apply(this, args);\n    }\n  };\n}",
      "testCode": "let count = 0;\nconst t = throttle(() => count++, 50);\nt(); t(); t();\nif (count !== 1) throw new Error(\"should throttle: \" + count);",
      "language": "javascript",
      "description": "Throttle — limits function to one call per time window",
      "tags": [
        "utility",
        "async",
        "throttle",
        "rate-limit",
        "timing"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "a0f6429924b76edc",
      "name": "debounce",
      "code": "function debounce(fn, delay) {\n  let timer;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}",
      "testCode": "const d = debounce(() => {}, 100);\nif (typeof d !== 'function') throw new Error(\"should return function\");",
      "language": "javascript",
      "description": "Debounce — delays function execution until pause in calls",
      "tags": [
        "utility",
        "async",
        "debounce",
        "rate-limit",
        "timing"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.97
    },
    {
      "id": "da22de297c732800",
      "name": "depth-first-search",
      "code": "function dfs(graph, start, visited = new Set()) {\n  visited.add(start);\n  const result = [start];\n  for (const neighbor of (graph[start] || [])) {\n    if (!visited.has(neighbor)) {\n      result.push(...dfs(graph, neighbor, visited));\n    }\n  }\n  return result;\n}",
      "testCode": "const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = dfs(g, 'a');\nif (!r.includes('a') || !r.includes('b') || !r.includes('c') || !r.includes('d')) throw new Error(\"missing nodes\");\nif (r[0] !== 'a') throw new Error(\"should start at root\");\nif (r.length !== 4) throw new Error(\"should visit all: \" + r);",
      "language": "javascript",
      "description": "Depth-first search on adjacency list graph",
      "tags": [
        "graph",
        "search",
        "algorithm",
        "dfs",
        "traversal"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.97
    },
    {
      "id": "d44fa5ab546d57a4",
      "name": "mockRes-ts",
      "code": "function mockRes() {\n  const res = { statusCode: 200, headers: {}, body: '' };\n  res.setHeader = (k, v) => { res.headers[k] = v; };\n  res.writeHead = (code) => { res.statusCode = code; };\n  res.end = (body) => { res.body = body; };\n  return res;\n}",
      "testCode": "if (mockRes() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — tests/auth.test.js (TypeScript variant)",
      "tags": [
        "mockRes",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "a9853542f25f0a12",
      "name": "tryLoadSQLite-ts",
      "code": "function tryLoadSQLite() {\n  try {\n    const { DatabaseSync } = require('node:sqlite');\n    if (DatabaseSync) {\n      const { SQLiteStore } = require('./sqlite');\n      return SQLiteStore;\n    }\n  } catch {}\n  return null;\n}",
      "testCode": "if (tryLoadSQLite() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested function from . — src/store/history.js (TypeScript variant)",
      "tags": [
        "tryLoadSQLite",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "67578d07ed8c00bc",
      "name": "jwt-auth-refined-ts",
      "code": "const crypto = require('crypto');\nclass JWTAuth {\n  constructor(secret) { this.secret = secret; }\n  _b(d) { return Buffer.from(d).toString('base64url'); }\n  _h(i) { return crypto.createHmac('sha256', this.secret).update(i).digest('base64url'); }\n  sign(payload, exp) {\n    exp = exp || '1h'; const u = {h:36e5,m:6e4,s:1e3};\n    const hd = this._b('{\"alg\":\"HS256\",\"typ\":\"JWT\"}');\n    const e = Date.now() + parseInt(exp) * (u[exp.slice(-1)] || 36e5);\n    const bd = this._b(JSON.stringify(Object.assign({}, payload, {exp: e})));\n    return hd + '.' + bd + '.' + this._h(hd + '.' + bd);\n  }\n  verify(t) {\n    const p = t.split('.'); if (this._h(p[0]+'.'+p[1]) !== p[2]) throw new Error('Invalid signature');\n    const d = JSON.parse(Buffer.from(p[1], 'base64url'));\n    if (d.exp && Date.now() > d.exp) throw new Error('Token expired'); return d;\n  }\n  decode(t) { return JSON.parse(Buffer.from(t.split('.')[1], 'base64url')); }\n}",
      "testCode": "var auth = new JWTAuth('test-secret-key-12345');\nvar token = auth.sign({ sub: 'user1', role: 'admin' });\nif (typeof token !== 'string' || token.split('.').length !== 3) throw new Error('token format');\nvar payload = auth.verify(token);\nif (payload.sub !== 'user1') throw new Error('verify payload');\nvar decoded = auth.decode(token);\nif (decoded.role !== 'admin') throw new Error('decode payload');\ntry { auth.verify(token+'x'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "typescript",
      "description": "JWT authentication with HMAC-SHA256 signing, verification, and decoding (refined) (TypeScript variant)",
      "tags": [
        "jwt",
        "auth",
        "token",
        "hmac",
        "sha256",
        "crypto",
        "security",
        "validation",
        "auto-refined",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "cdd8c467df319c50",
      "name": "code-fingerprint-dedup-ts",
      "code": "const crypto = require('crypto');\n\nfunction codeFingerprint(code: any) {\n  if (!code || typeof code !== 'string') return '';\n  let normalized = code\n    .replace(/\\/\\/[^\\n]*/g, '')\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n    .replace(/#[^\\n]*/g, '')\n    .replace(/\\s+/g, ' ')\n    .replace(/\\s*([(){}[\\];,:.=+\\-*/<>!&|^~?])\\s*/g, '$1')\n    .replace(/([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g, '\"\"')\n    .replace(/\\b\\d+\\.?\\d*\\b/g, '0')\n    .trim();\n  return crypto.createHash('sha256').update(normalized).digest('hex').slice(0, 16);\n}\n\nfunction codeSimilarity(codeA, codeB) {\n  if (!codeA || !codeB) return 0;\n  const tokenize = (code) => {\n    return code\n      .replace(/\\/\\/[^\\n]*/g, '')\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      .replace(/#[^\\n]*/g, '')\n      .replace(/\\s+/g, ' ')\n      .split(/[\\s{}()\\[\\];,.:=+\\-*/<>!&|^~?@#]+/)\n      .filter(t => t.length > 0);\n  };\n  const tokensA = new Set(tokenize(codeA));\n  const tokensB = new Set(tokenize(codeB));\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n  let intersection = 0;\n  for (const t of tokensA) { if (tokensB.has(t)) intersection++; }\n  const union = tokensA.size + tokensB.size - intersection;\n  return union > 0 ? intersection / union : 0;\n}\n\nmodule.exports = { codeFingerprint, codeSimilarity };\n",
      "testCode": "const fp1 = codeFingerprint('function add(a, b) { return a + b; }');\nconst fp2 = codeFingerprint('function add(a, b) { return a + b; }');\nif (fp1 !== fp2) throw new Error('Same code should produce same fingerprint');\nif (fp1.length !== 16) throw new Error('Fingerprint should be 16 chars');\nif (!/^[0-9a-f]+$/.test(fp1)) throw new Error('Fingerprint should be hex');\nconst fp3 = codeFingerprint('function multiply(a, b) { return a * b; }');\nif (fp1 === fp3) throw new Error('Different code should produce different fingerprint');\nif (codeFingerprint('') !== '') throw new Error('Empty should return empty');\nif (codeFingerprint(null) !== '') throw new Error('Null should return empty');\nconst sim1 = codeSimilarity('function add(a, b) { return a + b; }', 'function add(a, b) { return a + b; }');\nif (sim1 < 0.99) throw new Error('Identical code should have sim ~1.0, got ' + sim1);\nconst sim2 = codeSimilarity('function add(a, b) { return a + b; }', '');\nif (sim2 !== 0) throw new Error('Empty comparison should be 0');\nconst sim3 = codeSimilarity('function x() { return 1; }', 'class EventEmitter { constructor() { this.h = {}; } on(n, f) { this.h[n] = f; } }');\nif (sim3 > 0.5) throw new Error('Different code should have low sim, got ' + sim3);\n",
      "language": "typescript",
      "description": "Code fingerprinting and token-level Jaccard similarity for detecting duplicate or near-duplicate code (TypeScript variant)",
      "tags": [
        "deduplication",
        "fingerprint",
        "similarity",
        "hash",
        "jaccard",
        "code-analysis",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "e864db77e29a5cc0",
      "name": "cors-middleware-ts",
      "code": "function cors(opts: Record<string, any>) {\n  opts = opts || {};\n  let o = { origin: opts.origin||'*', methods: opts.methods||'GET,HEAD,PUT,PATCH,POST,DELETE',\n    headers: opts.headers||'', credentials: !!opts.credentials, maxAge: opts.maxAge||86400 };\n  return function(req, res, next) {\n    res.setHeader('Access-Control-Allow-Origin', o.origin);\n    if (o.credentials) res.setHeader('Access-Control-Allow-Credentials', 'true');\n    if (req.method === 'OPTIONS') {\n      res.setHeader('Access-Control-Allow-Methods', o.methods);\n      if (o.headers) res.setHeader('Access-Control-Allow-Headers', o.headers);\n      res.setHeader('Access-Control-Max-Age', String(o.maxAge));\n      res.writeHead(204); res.end(); return;\n    }\n    next();\n  };\n}",
      "testCode": "var handler = cors({ origin: 'http://example.com', methods: 'GET,POST', credentials: true });\nvar headers = {};\nvar res = { setHeader: function(k,v){headers[k]=v;}, writeHead: function(){}, end: function(){} };\nhandler({ method: 'OPTIONS' }, res, function(){});\nif (headers['Access-Control-Allow-Origin'] !== 'http://example.com') throw new Error('origin');\nif (headers['Access-Control-Allow-Credentials'] !== 'true') throw new Error('credentials');\nif (headers['Access-Control-Allow-Methods'] !== 'GET,POST') throw new Error('methods');\nvar called = false; headers = {};\nhandler({ method: 'GET' }, res, function(){ called = true; });\nif (!called) throw new Error('next not called');",
      "language": "typescript",
      "description": "CORS middleware with preflight handling, origin control, and credentials support (TypeScript variant)",
      "tags": [
        "cors",
        "middleware",
        "http",
        "headers",
        "preflight",
        "security",
        "api",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "a7611c22e8fd8c8f",
      "name": "jwt-auth-ts",
      "code": "const crypto = require('crypto');\nclass JWTAuth {\n  constructor(secret) { this.secret = secret; }\n  _b(d) { return Buffer.from(d).toString('base64url'); }\n  _h(i) { return crypto.createHmac('sha256', this.secret).update(i).digest('base64url'); }\n  sign(payload, exp) {\n    exp = exp || '1h'; let u = {h:36e5,m:6e4,s:1e3};\n    let hd = this._b('{\"alg\":\"HS256\",\"typ\":\"JWT\"}');\n    let e = Date.now() + parseInt(exp) * (u[exp.slice(-1)] || 36e5);\n    let bd = this._b(JSON.stringify(Object.assign({}, payload, {exp: e})));\n    return hd + '.' + bd + '.' + this._h(hd + '.' + bd);\n  }\n  verify(t) {\n    let p = t.split('.'); if (this._h(p[0]+'.'+p[1]) !== p[2]) throw new Error('Invalid signature');\n    let d = JSON.parse(Buffer.from(p[1], 'base64url'));\n    if (d.exp && Date.now() > d.exp) throw new Error('Token expired'); return d;\n  }\n  decode(t) { return JSON.parse(Buffer.from(t.split('.')[1], 'base64url')); }\n}",
      "testCode": "var auth = new JWTAuth('test-secret-key-12345');\nvar token = auth.sign({ sub: 'user1', role: 'admin' });\nif (typeof token !== 'string' || token.split('.').length !== 3) throw new Error('token format');\nvar payload = auth.verify(token);\nif (payload.sub !== 'user1') throw new Error('verify payload');\nvar decoded = auth.decode(token);\nif (decoded.role !== 'admin') throw new Error('decode payload');\ntry { auth.verify(token+'x'); throw new Error('no'); } catch(e) { if (e.message==='no') throw e; }",
      "language": "typescript",
      "description": "JWT authentication with HMAC-SHA256 signing, verification, and decoding (TypeScript variant)",
      "tags": [
        "jwt",
        "auth",
        "token",
        "hmac",
        "sha256",
        "crypto",
        "security",
        "validation",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "e159c2ff1b1a533a",
      "name": "state-machine-ts",
      "code": "class StateMachine {\n  constructor(config) {\n    this._state = config.initial;\n    this._t = {};\n    for (const t of config.transitions || []) this._t[t.from + ':' + t.event] = t.to;\n  }\n  transition(event) {\n    const next = this._t[this._state + ':' + event];\n    if (!next) throw new Error('Invalid: ' + event + ' from ' + this._state);\n    this._state = next;\n    return this._state;\n  }\n  can(event) {\n    return !!(this._t[this._state + ':' + event]);\n  }\n  getState() { return this._state; }\n}",
      "testCode": "const sm = new StateMachine({\n  initial: 'idle',\n  transitions: [\n    { from: 'idle', event: 'start', to: 'running' },\n    { from: 'running', event: 'pause', to: 'paused' },\n    { from: 'paused', event: 'resume', to: 'running' },\n    { from: 'running', event: 'stop', to: 'idle' }\n  ]\n});\nif (sm.getState() !== 'idle') throw new Error('initial state should be idle');\nif (!sm.can('start')) throw new Error('should be able to start from idle');\nif (sm.can('pause')) throw new Error('should not pause from idle');\nsm.transition('start');\nif (sm.getState() !== 'running') throw new Error('should be running after start');\nlet threw = false;\ntry { sm.transition('resume'); } catch(e) { threw = true; }\nif (!threw) throw new Error('invalid transition should throw');",
      "language": "typescript",
      "description": "Finite state machine with declarative transitions and state querying (TypeScript variant)",
      "tags": [
        "state-machine",
        "fsm",
        "design-pattern",
        "state",
        "transitions",
        "variant",
        "typescript"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "ecb50a836bee6d4c",
      "name": "connection-pool-ts",
      "code": "class ConnectionPool {\n  constructor(factory, opts = {}) {\n    this._f = factory; this._max = opts.max || 10;\n    this._p = []; this._a = 0; this._w = [];\n  }\n  async acquire() {\n    if (this._p.length > 0) { this._a++; return this._p.pop(); }\n    if (this._a < this._max) { this._a++; return this._f(); }\n    return new Promise(r => this._w.push(r));\n  }\n  release(conn) {\n    if (this._w.length > 0) this._w.shift()(conn);\n    else { this._a--; this._p.push(conn); }\n  }\n  drain() {\n    this._p = []; this._w.forEach(r => r(null));\n    this._w = []; this._a = 0;\n  }\n}",
      "testCode": "let created = 0;\nconst pool = new ConnectionPool(() => ({ id: ++created }), { max: 2 });\nconst c1 = await pool.acquire();\nconst c2 = await pool.acquire();\nif (created !== 2) throw new Error('should create 2 connections');\npool.release(c1);\nconst c3 = await pool.acquire();\nif (c3.id !== c1.id) throw new Error('should reuse released connection');\nif (created !== 2) throw new Error('should not create new after reuse');\nawait pool.drain();",
      "language": "typescript",
      "description": "Object connection pool with configurable max size, factory function, and waiting queue (TypeScript variant)",
      "tags": [
        "pool",
        "connection",
        "concurrency",
        "resource",
        "database",
        "connection-pool",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "7f42c583a2bf3442",
      "name": "trie-ts",
      "code": "class Trie {\n  constructor() { this.root = {}; }\n  insert(word) {\n    let node = this.root;\n    for (const ch of word) { node = node[ch] = node[ch] || {}; }\n    node._end = true;\n  }\n  search(word) {\n    let node = this.root;\n    for (const ch of word) { if (!node[ch]) return false; node = node[ch]; }\n    return node._end === true;\n  }\n  startsWith(prefix) {\n    let node = this.root;\n    for (const ch of prefix) { if (!node[ch]) return false; node = node[ch]; }\n    return true;\n  }\n}",
      "testCode": "const t = new Trie();\nt.insert(\"hello\"); t.insert(\"help\");\nif (!t.search(\"hello\")) throw new Error(\"find hello\");\nif (t.search(\"hell\")) throw new Error(\"partial\");\nif (!t.startsWith(\"hel\")) throw new Error(\"prefix\");\nif (t.startsWith(\"xyz\")) throw new Error(\"bad prefix\");",
      "language": "typescript",
      "description": "Trie (prefix tree) for fast string lookups and prefix search (TypeScript variant)",
      "tags": [
        "data-structure",
        "trie",
        "string",
        "prefix",
        "search",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "dad8c667b4fd8efe",
      "name": "code-fingerprint-dedup",
      "code": "const crypto = require('crypto');\n\nfunction codeFingerprint(code) {\n  if (!code || typeof code !== 'string') return '';\n  let normalized = code\n    .replace(/\\/\\/[^\\n]*/g, '')\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n    .replace(/#[^\\n]*/g, '')\n    .replace(/\\s+/g, ' ')\n    .replace(/\\s*([(){}[\\];,:.=+\\-*/<>!&|^~?])\\s*/g, '$1')\n    .replace(/([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g, '\"\"')\n    .replace(/\\b\\d+\\.?\\d*\\b/g, '0')\n    .trim();\n  return crypto.createHash('sha256').update(normalized).digest('hex').slice(0, 16);\n}\n\nfunction codeSimilarity(codeA, codeB) {\n  if (!codeA || !codeB) return 0;\n  const tokenize = (code) => {\n    return code\n      .replace(/\\/\\/[^\\n]*/g, '')\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      .replace(/#[^\\n]*/g, '')\n      .replace(/\\s+/g, ' ')\n      .split(/[\\s{}()\\[\\];,.:=+\\-*/<>!&|^~?@#]+/)\n      .filter(t => t.length > 0);\n  };\n  const tokensA = new Set(tokenize(codeA));\n  const tokensB = new Set(tokenize(codeB));\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n  let intersection = 0;\n  for (const t of tokensA) { if (tokensB.has(t)) intersection++; }\n  const union = tokensA.size + tokensB.size - intersection;\n  return union > 0 ? intersection / union : 0;\n}\n\nmodule.exports = { codeFingerprint, codeSimilarity };\n",
      "testCode": "const fp1 = codeFingerprint('function add(a, b) { return a + b; }');\nconst fp2 = codeFingerprint('function add(a, b) { return a + b; }');\nif (fp1 !== fp2) throw new Error('Same code should produce same fingerprint');\nif (fp1.length !== 16) throw new Error('Fingerprint should be 16 chars');\nif (!/^[0-9a-f]+$/.test(fp1)) throw new Error('Fingerprint should be hex');\nconst fp3 = codeFingerprint('function multiply(a, b) { return a * b; }');\nif (fp1 === fp3) throw new Error('Different code should produce different fingerprint');\nif (codeFingerprint('') !== '') throw new Error('Empty should return empty');\nif (codeFingerprint(null) !== '') throw new Error('Null should return empty');\nconst sim1 = codeSimilarity('function add(a, b) { return a + b; }', 'function add(a, b) { return a + b; }');\nif (sim1 < 0.99) throw new Error('Identical code should have sim ~1.0, got ' + sim1);\nconst sim2 = codeSimilarity('function add(a, b) { return a + b; }', '');\nif (sim2 !== 0) throw new Error('Empty comparison should be 0');\nconst sim3 = codeSimilarity('function x() { return 1; }', 'class EventEmitter { constructor() { this.h = {}; } on(n, f) { this.h[n] = f; } }');\nif (sim3 > 0.5) throw new Error('Different code should have low sim, got ' + sim3);\n",
      "language": "javascript",
      "description": "Code fingerprinting and token-level Jaccard similarity for detecting duplicate or near-duplicate code",
      "tags": [
        "deduplication",
        "fingerprint",
        "similarity",
        "hash",
        "jaccard",
        "code-analysis"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "66024bd4ff51a386",
      "name": "pick-ts",
      "code": "function pick(obj: any[], keys: any[]) {\n  let result = {};\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i] in obj) result[keys[i]] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = pick({a:1,b:2,c:3}, ['a','c']);\nif (r.a !== 1 || r.c !== 3) throw new Error('picked');\nif ('b' in r) throw new Error('excluded');",
      "language": "typescript",
      "description": "Pick specified keys from object (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "a1f00193673dec27",
      "name": "omit-ts",
      "code": "function omit(obj: any[], keys: any) {\n  let set = new Set(keys);\n  let result = {};\n  for (let k in obj) {\n    if (obj.hasOwnProperty(k) && !set.has(k)) result[k] = obj[k];\n  }\n  return result;\n}",
      "testCode": "var r = omit({a:1,b:2,c:3}, ['b']);\nif (r.a !== 1 || r.c !== 3) throw new Error('kept');\nif ('b' in r) throw new Error('omitted');",
      "language": "typescript",
      "description": "Omit specified keys from object (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "fd6809905a0f875e",
      "name": "deep-merge-ts",
      "code": "function deepMerge(target: any[]) {\n  for (let i = 1; i < arguments.length; i++) {\n    let source = arguments[i];\n    for (let key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        target[key] = deepMerge(target[key] || {}, source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}",
      "testCode": "var r = deepMerge({a:1, b:{c:2, d:3}}, {b:{c:9, e:4}});\nif (r.a !== 1) throw new Error('a');\nif (r.b.c !== 9) throw new Error('override');\nif (r.b.d !== 3) throw new Error('keep');\nif (r.b.e !== 4) throw new Error('add');",
      "language": "typescript",
      "description": "Deep merge multiple objects (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "merge",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "233e6ba6be5ff3cb",
      "name": "map-values-ts",
      "code": "function mapValues(obj: any[], fn: Function) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = fn(obj[keys[i]], keys[i]);\n  }\n  return result;\n}",
      "testCode": "var r = mapValues({a:1,b:2}, function(v) { return v * 2; });\nif (r.a !== 2 || r.b !== 4) throw new Error('doubled');",
      "language": "typescript",
      "description": "Map over object values (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "transform",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "78636d2fef522e23",
      "name": "map-keys-ts",
      "code": "function mapKeys(obj: any[], fn: Function) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    result[fn(keys[i], obj[keys[i]])] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = mapKeys({a:1,b:2}, function(k) { return k.toUpperCase(); });\nif (r.A !== 1 || r.B !== 2) throw new Error('mapped');\nif ('a' in r) throw new Error('old key');",
      "language": "typescript",
      "description": "Map over object keys (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "transform",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "9a73312494b32432",
      "name": "invert-ts",
      "code": "function invert(obj: any[]) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    result[obj[keys[i]]] = keys[i];\n  }\n  return result;\n}",
      "testCode": "var r = invert({a:'x', b:'y'});\nif (r.x !== 'a' || r.y !== 'b') throw new Error('inverted');",
      "language": "typescript",
      "description": "Swap keys and values in object (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "82a57463b68fc800",
      "name": "rename-keys-ts",
      "code": "function renameKeys(obj: any[], keyMap: any[]) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    let newKey = keyMap[keys[i]] || keys[i];\n    result[newKey] = obj[keys[i]];\n  }\n  return result;\n}",
      "testCode": "var r = renameKeys({a:1, b:2}, {a:'x'});\nif (r.x !== 1) throw new Error('renamed');\nif (r.b !== 2) throw new Error('kept');\nif ('a' in r) throw new Error('old key');",
      "language": "typescript",
      "description": "Rename object keys via mapping (TypeScript variant)",
      "tags": [
        "object",
        "utility",
        "transform",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "565c1250eb55ce21",
      "name": "parse-query-string-ts",
      "code": "function parseQueryString(qs: any) {\n  if (!qs || qs === '?') return {};\n  return qs.replace(/^\\?/, '').split('&').reduce(function(obj, pair) {\n    let parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '');\n    return obj;\n  }, {});\n}",
      "testCode": "var r = parseQueryString('?foo=bar&baz=42');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (Object.keys(parseQueryString('')).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Parse URL query string to object (TypeScript variant)",
      "tags": [
        "http",
        "utility",
        "url",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.96
    },
    {
      "id": "716af1bc4b91d0c0",
      "name": "parse-cookie-ts",
      "code": "function parseCookie(str: string) {\n  if (!str) return {};\n  return str.split(';').reduce(function(obj, pair) {\n    let parts = pair.trim().split('=');\n    let key = parts[0].trim();\n    obj[key] = parts.slice(1).join('=').trim();\n    return obj;\n  }, {});\n}",
      "testCode": "var r = parseCookie('foo=bar; baz=42; name=hello');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (r.name !== 'hello') throw new Error('name');\nif (Object.keys(parseCookie('')).length !== 0) throw new Error('empty');",
      "language": "typescript",
      "description": "Parse cookie header string to object (TypeScript variant)",
      "tags": [
        "http",
        "utility",
        "cookie",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "d2c9962f9275b44c",
      "name": "group-by-ts",
      "code": "function groupBy(arr: any, keyFn: any) {\n  const groups = {};\n  for (const item of arr) {\n    const key = typeof keyFn === 'function' ? keyFn(item) : item[keyFn];\n    (groups[key] = groups[key] || []).push(item);\n  }\n  return groups;\n}",
      "testCode": "const data = [{n:'a',t:1},{n:'b',t:1},{n:'c',t:2}];\nconst g = groupBy(data, 't');\nif (g[1].length !== 2) throw new Error(\"group 1\");\nif (g[2].length !== 1) throw new Error(\"group 2\");\nconst g2 = groupBy(data, item => item.t);\nif (g2[1].length !== 2) throw new Error(\"fn key\");",
      "language": "typescript",
      "description": "Group array items by a key or function (TypeScript variant)",
      "tags": [
        "transformation",
        "array",
        "group",
        "aggregate",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "8acc81e3e8c5ca1c",
      "name": "deep-clone-ts",
      "code": "function deepClone(obj: any[]) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) {\n    cloned[key] = deepClone(obj[key]);\n  }\n  return cloned;\n}",
      "testCode": "const orig = { a: 1, b: { c: [1,2,{d:3}] }, e: new Date(0) };\nconst clone = deepClone(orig);\nif (clone === orig) throw new Error(\"same ref\");\nif (clone.b === orig.b) throw new Error(\"shallow copy\");\nclone.b.c[2].d = 999;\nif (orig.b.c[2].d === 999) throw new Error(\"mutation leaked\");\nif (clone.e.getTime() !== 0) throw new Error(\"date clone\");\nif (deepClone(null) !== null) throw new Error(\"null\");\nif (deepClone(42) !== 42) throw new Error(\"primitive\");",
      "language": "typescript",
      "description": "Deep clone — recursively copies objects, arrays, dates, regexps (TypeScript variant)",
      "tags": [
        "utility",
        "clone",
        "deep-copy",
        "object",
        "immutable",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "8d5aa3a6ad644ad7",
      "name": "typed-event-emitter-ts",
      "code": "type EventMap = Record<string, any>;\n\nclass TypedEmitter<T extends EventMap> {\n  private listeners: { [K in keyof T]?: Array<(payload: T[K]) => void> } = {};\n\n  on<K extends keyof T>(event: K, fn: (payload: T[K]) => void): void {\n    (this.listeners[event] = this.listeners[event] || []).push(fn);\n  }\n\n  off<K extends keyof T>(event: K, fn: (payload: T[K]) => void): void {\n    const fns = this.listeners[event];\n    if (fns) this.listeners[event] = fns.filter(f => f !== fn);\n  }\n\n  emit<K extends keyof T>(event: K, payload: T[K]): void {\n    for (const fn of this.listeners[event] || []) fn(payload);\n  }\n}",
      "testCode": "const em = new TypedEmitter();\nlet got = null;\nconst handler = (v) => { got = v; };\nem.on('test', handler);\nem.emit('test', 42);\nif (got !== 42) throw new Error(\"emit failed: \" + got);\nem.off('test', handler);\nem.emit('test', 99);\nif (got !== 42) throw new Error(\"off failed: \" + got);",
      "language": "typescript",
      "description": "Type-safe event emitter with generics for event map",
      "tags": [
        "utility",
        "events",
        "typescript",
        "generic",
        "type-safe"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 0.96
    },
    {
      "id": "d1384830912d88a7",
      "name": "scored-registry-search",
      "code": "function searchRegistry(query, repos, options = {}) {\n  const { language, limit = 10 } = options;\n  const terms = query.toLowerCase().split(/\\s+/).filter(Boolean);\n  let filtered = [...repos];\n  if (language) {\n    filtered = filtered.filter(r => r.language === language);\n  }\n  const scored = filtered.map(repo => {\n    let score = 0;\n    for (const term of terms) {\n      if (repo.name.toLowerCase().includes(term)) score += 3;\n      if (repo.topics && repo.topics.some(t => t.includes(term))) score += 2;\n      if (repo.description && repo.description.toLowerCase().includes(term)) score += 1;\n    }\n    return { ...repo, score };\n  });\n  return scored\n    .filter(r => r.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit);\n}\n\nmodule.exports = { searchRegistry };\n",
      "testCode": "const testRepos = [\n  { name: 'lodash', language: 'javascript', topics: ['utility', 'functional'], description: 'A modern utility library' },\n  { name: 'algorithms', language: 'javascript', topics: ['algorithm', 'sorting'], description: 'Algorithms in JS' },\n  { name: 'toolz', language: 'python', topics: ['functional', 'utility'], description: 'Functional Python' },\n];\nconst r1 = searchRegistry('utility', testRepos);\nif (r1.length === 0) throw new Error('Should find utility matches');\nif (r1[0].score <= 0) throw new Error('Should have positive score');\nfor (let i = 1; i < r1.length; i++) {\n  if (r1[i-1].score < r1[i].score) throw new Error('Should sort by score desc');\n}\nconst r2 = searchRegistry('utility', testRepos, { language: 'python' });\nif (r2.some(r => r.language !== 'python')) throw new Error('Should filter by language');\nconst r3 = searchRegistry('xyznonexistent', testRepos);\nif (r3.length !== 0) throw new Error('No match should return empty');\nconst r4 = searchRegistry('algorithm sorting', testRepos, { limit: 1 });\nif (r4.length > 1) throw new Error('Should respect limit');\n",
      "language": "javascript",
      "description": "Multi-term scored search across a registry of repos — ranks by name/topic/description match",
      "tags": [
        "search",
        "registry",
        "scoring",
        "ranking",
        "filter"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.95
    },
    {
      "id": "7f88a03e1ffba30c",
      "name": "spdx-license-checker",
      "code": "const LICENSE_CATEGORIES = {\n  'MIT': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'Apache-2.0': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'BSD-2-Clause': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'BSD-3-Clause': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'ISC': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'Unlicense': { allowed: true, category: 'permissive', reason: 'Public domain — free to use' },\n  'CC0-1.0': { allowed: true, category: 'permissive', reason: 'Public domain — free to use' },\n  'CC-BY-4.0': { allowed: true, category: 'permissive', reason: 'Creative Commons Attribution — free with attribution' },\n  'Zlib': { allowed: true, category: 'permissive', reason: 'Permissive license — free to use' },\n  'BSL-1.0': { allowed: true, category: 'permissive', reason: 'Boost Software License — free to use' },\n  '0BSD': { allowed: true, category: 'permissive', reason: 'Zero-clause BSD — free to use' },\n  'LGPL-2.1': { allowed: true, category: 'weak-copyleft', reason: 'Weak copyleft — library use is fine, modifications must share' },\n  'LGPL-3.0': { allowed: true, category: 'weak-copyleft', reason: 'Weak copyleft — library use is fine, modifications must share' },\n  'MPL-2.0': { allowed: true, category: 'weak-copyleft', reason: 'Weak copyleft — file-level copyleft, rest is fine' },\n  'EPL-2.0': { allowed: true, category: 'weak-copyleft', reason: 'Eclipse Public License — module-level copyleft' },\n  'GPL-2.0': { allowed: false, category: 'strong-copyleft', reason: 'Strong copyleft — patterns may become derivative works' },\n  'GPL-3.0': { allowed: false, category: 'strong-copyleft', reason: 'Strong copyleft — patterns may become derivative works' },\n  'AGPL-3.0': { allowed: false, category: 'strong-copyleft', reason: 'Network copyleft — even server use triggers sharing requirement' },\n  'NOASSERTION': { allowed: false, category: 'unknown', reason: 'No license assertion — cannot determine usage rights' },\n  'unknown': { allowed: false, category: 'unknown', reason: 'Unknown license — cannot determine usage rights' },\n};\n\nfunction checkLicense(spdxId, options = {}) {\n  const { allowCopyleft = false } = options;\n  const normalized = spdxId?.trim() || 'unknown';\n  const entry = LICENSE_CATEGORIES[normalized];\n  if (entry) {\n    if (allowCopyleft && entry.category === 'strong-copyleft') {\n      return { ...entry, allowed: true, reason: entry.reason + ' (override: allowCopyleft)' };\n    }\n    return entry;\n  }\n  const upper = normalized.toUpperCase();\n  if (upper.includes('MIT') || upper.includes('BSD') || upper.includes('APACHE') || upper.includes('ISC')) {\n    return { allowed: true, category: 'permissive', reason: 'Appears permissive based on name' };\n  }\n  return { allowed: false, category: 'unknown', reason: 'Unrecognized license: ' + normalized };\n}\n\nmodule.exports = { checkLicense, LICENSE_CATEGORIES };\n",
      "testCode": "const r1 = checkLicense('MIT');\nif (!r1.allowed) throw new Error('MIT should be allowed');\nif (r1.category !== 'permissive') throw new Error('MIT should be permissive');\nconst r2 = checkLicense('Apache-2.0');\nif (!r2.allowed) throw new Error('Apache should be allowed');\nconst r3 = checkLicense('GPL-3.0');\nif (r3.allowed) throw new Error('GPL should be blocked');\nif (r3.category !== 'strong-copyleft') throw new Error('GPL should be strong-copyleft');\nconst r4 = checkLicense('GPL-3.0', { allowCopyleft: true });\nif (!r4.allowed) throw new Error('GPL override should work');\nconst r5 = checkLicense('unknown');\nif (r5.allowed) throw new Error('unknown should be blocked');\nconst r6 = checkLicense(null);\nif (r6.allowed) throw new Error('null should be blocked');\nconst r7 = checkLicense('LGPL-3.0');\nif (!r7.allowed) throw new Error('LGPL should be allowed');\nif (r7.category !== 'weak-copyleft') throw new Error('LGPL should be weak-copyleft');\n",
      "language": "javascript",
      "description": "SPDX license compatibility checker — categorizes licenses as permissive, weak-copyleft, strong-copyleft, or unknown",
      "tags": [
        "license",
        "spdx",
        "compliance",
        "validation",
        "open-source"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.95
    },
    {
      "id": "e3b49ce159491ce1",
      "name": "quicksort-ts",
      "code": "function quickSort(arr: any[]) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\nmodule.exports = { quickSort };\n",
      "testCode": "if (quickSort([1, 2, 3]) === undefined) throw new Error(\"returned undefined\");\nif (quickSort([]) === undefined) throw new Error(\"returned undefined\");\nif (quickSort([1]) === undefined) throw new Error(\"returned undefined\");\nif (quickSort([0, 0, 0]) === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested from . — examples/quicksort.js (5 functions) (TypeScript variant)",
      "tags": [
        "quickSort",
        "pivot",
        "left",
        "middle",
        "right",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "0de2640682424949",
      "name": "depth-first-search-ts",
      "code": "function dfs(graph, start, visited = new Set()) {\n  visited.add(start);\n  const result = [start];\n  for (const neighbor of (graph[start] || [])) {\n    if (!visited.has(neighbor)) {\n      result.push(...dfs(graph, neighbor, visited));\n    }\n  }\n  return result;\n}",
      "testCode": "const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = dfs(g, 'a');\nif (!r.includes('a') || !r.includes('b') || !r.includes('c') || !r.includes('d')) throw new Error(\"missing nodes\");\nif (r[0] !== 'a') throw new Error(\"should start at root\");\nif (r.length !== 4) throw new Error(\"should visit all: \" + r);",
      "language": "typescript",
      "description": "Depth-first search on adjacency list graph (TypeScript variant)",
      "tags": [
        "graph",
        "search",
        "algorithm",
        "dfs",
        "traversal",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.94
    },
    {
      "id": "7520cb08784223f2",
      "name": "memoize-async-ts",
      "code": "function memoizeAsync(fn: Function, opts: Record<string, any>) {\n  const { ttl = 0, keyFn = (...a) => JSON.stringify(a), max = 100 } = opts;\n  const cache = new Map(), order = [];\n  return async function(...args) {\n    const k = keyFn(...args), e = cache.get(k);\n    if (e && (!ttl || Date.now() - e.t < ttl)) {\n      const i = order.indexOf(k);\n      if (i > -1) { order.splice(i, 1); order.push(k); }\n      return e.v;\n    }\n    const v = await fn(...args);\n    cache.set(k, { v, t: Date.now() });\n    if (!order.includes(k)) order.push(k);\n    while (order.length > max) cache.delete(order.shift());\n    return v;\n  };\n}",
      "testCode": "let calls = 0;\nconst fn = memoizeAsync(async (x) => { calls++; return x * 2; }, { max: 2 });\nconst r1 = await fn(5);\nif (r1 !== 10) throw new Error('should return computed value');\nawait fn(5);\nif (calls !== 1) throw new Error('should use cache on second call');\nawait fn(6);\nawait fn(7);\nif (calls !== 3) throw new Error('should compute for new args');\nawait fn(5);\nif (calls !== 4) throw new Error('should evict LRU entry when maxSize exceeded');",
      "language": "typescript",
      "description": "Async function memoizer with LRU eviction, TTL expiry, and custom key function (TypeScript variant)",
      "tags": [
        "memoize",
        "cache",
        "async",
        "lru",
        "ttl",
        "utility",
        "memoization",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.94
    },
    {
      "id": "9ca94866ad44ab33",
      "name": "completion-debounce-ts",
      "code": "function debounce(fn: Function, delay: any) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); }; }",
      "testCode": "const d = debounce(() => {}, 100); if (typeof d !== \"function\") throw new Error(\"fail\");",
      "language": "typescript",
      "description": " (TypeScript variant)",
      "tags": [
        "utility",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "129ff1afee32b9c1",
      "name": "truncate-ts",
      "code": "function truncate(str: any[], maxLen: number, suffix: any[]) {\n  suffix = suffix || '...';\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - suffix.length) + suffix;\n}",
      "testCode": "if (truncate('hello world', 8) !== 'hello...') throw new Error('basic');\nif (truncate('hi', 10) !== 'hi') throw new Error('short');\nif (truncate('abcdef', 5, '..') !== 'abc..') throw new Error('custom');",
      "language": "typescript",
      "description": "Truncate string to max length with suffix (TypeScript variant)",
      "tags": [
        "string",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.94
    },
    {
      "id": "8c151211ab451697",
      "name": "flatten-deep-ts",
      "code": "function flattenDeep(arr: any) {\n  const result = [];\n  const stack = [...arr];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    if (Array.isArray(item)) {\n      stack.push(...item);\n    } else {\n      result.unshift(item);\n    }\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(flattenDeep([1,[2,[3,[4]]]])) !== '[1,2,3,4]') throw new Error(\"nested\");\nif (JSON.stringify(flattenDeep([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(flattenDeep([1,2,3])) !== '[1,2,3]') throw new Error(\"flat\");",
      "language": "typescript",
      "description": "Flatten deeply nested arrays iteratively (no recursion limit) (TypeScript variant)",
      "tags": [
        "transformation",
        "array",
        "flatten",
        "iterative",
        "utility",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "46220cb7c08cd50d",
      "name": "pipe-ts",
      "code": "function pipe(...fns: any) {\n  return function(input) {\n    return fns.reduce((val, fn) => fn(val), input);\n  };\n}",
      "testCode": "const double = x => x * 2;\nconst inc = x => x + 1;\nconst str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");",
      "language": "typescript",
      "description": "Function pipe — compose left-to-right (TypeScript variant)",
      "tags": [
        "utility",
        "functional",
        "pipe",
        "compose",
        "transform",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "c53a90b4cb414fff",
      "name": "memoize-ts",
      "code": "function memoize(fn: Function) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}",
      "testCode": "let calls = 0;\nconst add = memoize((a, b) => { calls++; return a + b; });\nif (add(1, 2) !== 3) throw new Error(\"first call\");\nif (add(1, 2) !== 3) throw new Error(\"cached call\");\nif (calls !== 1) throw new Error(\"should cache: \" + calls);\nif (add(2, 3) !== 5) throw new Error(\"diff args\");\nif (calls !== 2) throw new Error(\"new args: \" + calls);",
      "language": "typescript",
      "description": "Memoize — caches function results by arguments (TypeScript variant)",
      "tags": [
        "utility",
        "cache",
        "memoize",
        "performance",
        "optimization",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "0ee42d6b58977960",
      "name": "throttle-ts",
      "code": "function throttle(fn: Function, limit: number) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      return fn.apply(this, args);\n    }\n  };\n}",
      "testCode": "let count = 0;\nconst t = throttle(() => count++, 50);\nt(); t(); t();\nif (count !== 1) throw new Error(\"should throttle: \" + count);",
      "language": "typescript",
      "description": "Throttle — limits function to one call per time window (TypeScript variant)",
      "tags": [
        "utility",
        "async",
        "throttle",
        "rate-limit",
        "timing",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.94
    },
    {
      "id": "823c9bc7bb4d7775",
      "name": "debounce-ts",
      "code": "function debounce<T extends (...args: any[]) => void>(fn: T, delay: number): T {\n  let timer: ReturnType<typeof setTimeout>;\n  return ((...args: Parameters<T>) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  }) as T;\n}",
      "testCode": "let count = 0;\nconst inc = debounce(() => { count++; }, 50);\ninc(); inc(); inc();\nsetTimeout(() => {\n  if (count !== 0) throw new Error(\"should not fire yet: \" + count);\n  setTimeout(() => {\n    if (count !== 1) throw new Error(\"should fire once: \" + count);\n  }, 60);\n}, 20);",
      "language": "typescript",
      "description": "Debounce with TypeScript generics — preserves argument types",
      "tags": [
        "utility",
        "async",
        "debounce",
        "rate-limit",
        "typescript",
        "generic"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.94
    },
    {
      "id": "4a83bfc209fee87b",
      "name": "observable-refined-ts-refined",
      "code": "class Observable {\n  constructor(fn) { this._fn = fn; }\n  subscribe(o) { return this._fn(typeof o==='function'?{next:o}:o); }\n  static of() {\n    const v = Array.prototype.slice.call(arguments);\n    return new Observable(function(o) { v.forEach(function(x){o.next(x)}); if (o.complete)o.complete(); return {unsubscribe:function(){}}; });\n  }\n  map(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){o.next(fn(v))},error:function(e){if (o.error)o.error(e)},complete:function(){if (o.complete)o.complete()}});\n  }); }\n  filter(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){if (fn(v))o.next(v)},error:function(e){if (o.error)o.error(e)},complete:function(){if (o.complete)o.complete()}});\n  }); }\n}",
      "testCode": "var values = [];\nObservable.of(1,2,3).subscribe({next:function(v){values.push(v)}});\nif (values.length !== 3 || values[2] !== 3) throw new Error('of');\nvar mapped = [];\nObservable.of(1,2,3).map(function(x){return x*10}).subscribe({next:function(v){mapped.push(v)}});\nif (mapped[0] !== 10 || mapped[2] !== 30) throw new Error('map');\nvar filtered = [];\nObservable.of(1,2,3,4).filter(function(x){return x%2===0}).subscribe({next:function(v){filtered.push(v)}});\nif (filtered.length !== 2 || filtered[0] !== 2) throw new Error('filter');\nvar u = Observable.of(1).subscribe({next:function(){}});\nif (typeof u.unsubscribe !== 'function') throw new Error('unsubscribe');",
      "language": "typescript",
      "description": "Observable with subscribe, map, filter, and static of() factory (refined) (TypeScript variant) (refined)",
      "tags": [
        "observable",
        "reactive",
        "stream",
        "design-pattern",
        "functional",
        "subscribe",
        "auto-refined",
        "variant",
        "typescript",
        "auto-generated",
        "auto-refined",
        "auto-generated"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "79eaf8b28ac11e3f",
      "name": "observable-refined-ts",
      "code": "class Observable {\n  constructor(fn) { this._fn = fn; }\n  subscribe(o) { return this._fn(typeof o==='function'?{next:o}:o); }\n  static of() {\n    const v = Array.prototype.slice.call(arguments);\n    return new Observable(function(o) { v.forEach(function(x){o.next(x)}); if(o.complete)o.complete(); return {unsubscribe:function(){}}; });\n  }\n  map(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){o.next(fn(v))},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n  filter(fn) { let s =this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){if(fn(v))o.next(v)},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n}",
      "testCode": "var values = [];\nObservable.of(1,2,3).subscribe({next:function(v){values.push(v)}});\nif (values.length !== 3 || values[2] !== 3) throw new Error('of');\nvar mapped = [];\nObservable.of(1,2,3).map(function(x){return x*10}).subscribe({next:function(v){mapped.push(v)}});\nif (mapped[0] !== 10 || mapped[2] !== 30) throw new Error('map');\nvar filtered = [];\nObservable.of(1,2,3,4).filter(function(x){return x%2===0}).subscribe({next:function(v){filtered.push(v)}});\nif (filtered.length !== 2 || filtered[0] !== 2) throw new Error('filter');\nvar u = Observable.of(1).subscribe({next:function(){}});\nif (typeof u.unsubscribe !== 'function') throw new Error('unsubscribe');",
      "language": "typescript",
      "description": "Observable with subscribe, map, filter, and static of() factory (refined) (TypeScript variant)",
      "tags": [
        "observable",
        "reactive",
        "stream",
        "design-pattern",
        "functional",
        "subscribe",
        "auto-refined",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "c5d98687507425c6",
      "name": "observable-ts",
      "code": "class Observable {\n  constructor(fn) { this._fn = fn; }\n  subscribe(o) { return this._fn(typeof o==='function'?{next:o}:o); }\n  static of() {\n    let v = Array.prototype.slice.call(arguments);\n    return new Observable(function(o) { v.forEach(function(x){o.next(x)}); if(o.complete)o.complete(); return {unsubscribe:function(){}}; });\n  }\n  map(fn) { let s=this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){o.next(fn(v))},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n  filter(fn) { let s=this; return new Observable(function(o) {\n    return s.subscribe({next:function(v){if(fn(v))o.next(v)},error:function(e){if(o.error)o.error(e)},complete:function(){if(o.complete)o.complete()}});\n  }); }\n}",
      "testCode": "var values = [];\nObservable.of(1,2,3).subscribe({next:function(v){values.push(v)}});\nif (values.length !== 3 || values[2] !== 3) throw new Error('of');\nvar mapped = [];\nObservable.of(1,2,3).map(function(x){return x*10}).subscribe({next:function(v){mapped.push(v)}});\nif (mapped[0] !== 10 || mapped[2] !== 30) throw new Error('map');\nvar filtered = [];\nObservable.of(1,2,3,4).filter(function(x){return x%2===0}).subscribe({next:function(v){filtered.push(v)}});\nif (filtered.length !== 2 || filtered[0] !== 2) throw new Error('filter');\nvar u = Observable.of(1).subscribe({next:function(){}});\nif (typeof u.unsubscribe !== 'function') throw new Error('unsubscribe');",
      "language": "typescript",
      "description": "Observable with subscribe, map, filter, and static of() factory (TypeScript variant)",
      "tags": [
        "observable",
        "reactive",
        "stream",
        "design-pattern",
        "functional",
        "subscribe",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "786f27b9b5026c2f",
      "name": "memoize-async",
      "code": "function memoizeAsync(fn, opts = {}) {\n  const { ttl = 0, keyFn = (...a) => JSON.stringify(a), max = 100 } = opts;\n  const cache = new Map(), order = [];\n  return async function(...args) {\n    const k = keyFn(...args), e = cache.get(k);\n    if (e && (!ttl || Date.now() - e.t < ttl)) {\n      const i = order.indexOf(k);\n      if (i > -1) { order.splice(i, 1); order.push(k); }\n      return e.v;\n    }\n    const v = await fn(...args);\n    cache.set(k, { v, t: Date.now() });\n    if (!order.includes(k)) order.push(k);\n    while (order.length > max) cache.delete(order.shift());\n    return v;\n  };\n}",
      "testCode": "let calls = 0;\nconst fn = memoizeAsync(async (x) => { calls++; return x * 2; }, { max: 2 });\nconst r1 = await fn(5);\nif (r1 !== 10) throw new Error('should return computed value');\nawait fn(5);\nif (calls !== 1) throw new Error('should use cache on second call');\nawait fn(6);\nawait fn(7);\nif (calls !== 3) throw new Error('should compute for new args');\nawait fn(5);\nif (calls !== 4) throw new Error('should evict LRU entry when maxSize exceeded');",
      "language": "javascript",
      "description": "Async function memoizer with LRU eviction, TTL expiry, and custom key function",
      "tags": [
        "memoize",
        "cache",
        "async",
        "lru",
        "ttl",
        "utility",
        "memoization"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "bf393bbb5404ca42",
      "name": "circuit-breaker",
      "code": "class CircuitBreaker {\n  constructor(fn, o = {}) {\n    this._fn = fn; this._th = o.threshold || 5; this._to = o.timeout || 30000;\n    this._s = 'closed'; this._f = this._at = 0;\n  }\n  async call(...args) {\n    if (this._s === 'open') {\n      if (Date.now() - this._at >= this._to) this._s = 'half-open';\n      else throw new Error('Open');\n    }\n    try {\n      const r = await this._fn(...args);\n      this._f = 0; this._s = 'closed'; return r;\n    } catch (e) {\n      if (++this._f >= this._th) { this._s = 'open'; this._at = Date.now(); }\n      throw e;\n    }\n  }\n  getState() { return this._s; }\n}",
      "testCode": "let callCount = 0;\nconst breaker = new CircuitBreaker(async () => { callCount++; throw new Error('fail'); }, { threshold: 3, timeout: 100 });\nfor (let i = 0; i < 3; i++) { try { await breaker.call(); } catch(e) {} }\nif (breaker.getState() !== 'open') throw new Error('should be open after threshold failures');\nlet blocked = false;\ntry { await breaker.call(); } catch(e) { blocked = e.message === 'Open'; }\nif (!blocked) throw new Error('should block calls when circuit is open');\nif (callCount !== 3) throw new Error('should not invoke fn when open');\nconst ok = new CircuitBreaker(async (x) => x * 2, { threshold: 5 });\nconst r = await ok.call(21);\nif (r !== 42) throw new Error('should return result on success');",
      "language": "javascript",
      "description": "Circuit breaker with closed/open/half-open states, failure threshold, and automatic recovery",
      "tags": [
        "circuit-breaker",
        "resilience",
        "fault-tolerance",
        "design-pattern",
        "reliability"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "ab767d05a6fe7099",
      "name": "event-emitter",
      "code": "class EventEmitter {\n  constructor() { this._e = {}; }\n  on(event, fn) {\n    (this._e[event] = this._e[event] || []).push(fn);\n    return this;\n  }\n  off(event, fn) {\n    if (this._e[event]) this._e[event] = this._e[event].filter(h => h !== fn);\n    return this;\n  }\n  emit(event, ...args) {\n    if (this._e[event]) this._e[event].slice().forEach(h => h(...args));\n    return this;\n  }\n  once(event, fn) {\n    const w = (...a) => { this.off(event, w); fn(...a); };\n    return this.on(event, w);\n  }\n}",
      "testCode": "const ee = new EventEmitter();\nlet called = 0;\nconst handler = () => called++;\nee.on('test', handler);\nee.emit('test');\nif (called !== 1) throw new Error('should call handler once');\nee.off('test', handler);\nee.emit('test');\nif (called !== 1) throw new Error('should not call after off');\nlet onceCount = 0;\nee.once('x', () => onceCount++);\nee.emit('x');\nee.emit('x');\nif (onceCount !== 1) throw new Error('once should fire only once');\nlet arg;\nee.on('data', v => { arg = v; });\nee.emit('data', 42);\nif (arg !== 42) throw new Error('should pass arguments to handler');",
      "language": "javascript",
      "description": "Minimal event emitter with on, off, emit, and once support",
      "tags": [
        "event",
        "emitter",
        "pubsub",
        "observer",
        "design-pattern",
        "events"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 0.93
    },
    {
      "id": "169b20da0f64844e",
      "name": "DependencyGraph",
      "code": "class DependencyGraph {\n  constructor() { this.nodes = new Map(); }\n  addNode(id, meta = {}) { if (!this.nodes.has(id)) this.nodes.set(id, { deps: new Set(), meta }); return this; }\n  addEdge(from, to) { this.addNode(from); this.addNode(to); this.nodes.get(from).deps.add(to); return this; }\n  hasCycle() { \n    const visited = new Set(), stack = new Set();\n    const dfs = (id) => { if (stack.has(id)) return true; if (visited.has(id)) return false; visited.add(id); stack.add(id); for (const dep of (this.nodes.get(id)?.deps || [])) { if (dfs(dep)) return true; } stack.delete(id); return false; };\n    for (const id of this.nodes.keys()) { if (dfs(id)) return true; }\n    return false;\n  }\n  topologicalSort() {\n    const visited = new Set(), result = [];\n    const dfs = (id) => { if (visited.has(id)) return; visited.add(id); for (const dep of (this.nodes.get(id)?.deps || [])) dfs(dep); result.push(id); };\n    for (const id of this.nodes.keys()) dfs(id);\n    return result;\n  }\n  getImpact(id) { const affected = new Set(); for (const [nid, node] of this.nodes) { if (node.deps.has(id)) affected.add(nid); } return [...affected]; }\n}",
      "testCode": "\nconst g = new DependencyGraph();\ng.addNode('a').addNode('b').addNode('c').addEdge('a', 'b').addEdge('b', 'c');\nif (g.hasCycle()) throw new Error('false cycle');\nconst order = g.topologicalSort();\nif (order.indexOf('c') > order.indexOf('b')) throw new Error('topo fail');\nif (order.indexOf('b') > order.indexOf('a')) throw new Error('topo fail 2');\nconst impact = g.getImpact('c');\nif (!impact.includes('b')) throw new Error('impact fail');\n",
      "language": "javascript",
      "description": "Dependency graph with topological sort, cycle detection, and impact analysis",
      "tags": [
        "graph",
        "dependency",
        "topological-sort",
        "data-structure",
        "algorithm"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "88d3739ddb6f1139",
      "name": "deep-merge",
      "code": "function deepMerge(target, source) {\n  const result = { ...target };\n  for (const key of Object.keys(source)) {\n    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n      result[key] = deepMerge(result[key] || {}, source[key]);\n    } else {\n      result[key] = source[key];\n    }\n  }\n  return result;\n}",
      "testCode": "if (JSON.stringify(deepMerge({a:1,b:{c:2}},{b:{d:3}})) !== JSON.stringify({a:1,b:{c:2,d:3}})) throw new Error('failed');\nif (JSON.stringify(deepMerge({},{a:1})) !== JSON.stringify({a:1})) throw new Error('failed');\nif (JSON.stringify(deepMerge({a:1},{})) !== JSON.stringify({a:1})) throw new Error('failed');",
      "language": "javascript",
      "description": "",
      "tags": [
        "utility",
        "object",
        "merge",
        "deep"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.93
    },
    {
      "id": "828e6ddcbd446b71",
      "name": "csv-parser-ts",
      "code": "function parseCSV(t: any[], o: any[]) {\n  o = o || {}; let d = o.delimiter || ',', h = o.headers !== false, q = o.quote || '\"';\n  let rows = [], row = [''], inQ = false, col = 0;\n  for (let i = 0; i < t.length; i++) { let c = t[i];\n    if (inQ) { if (c===q&&t[i+1]===q){row[col]+=q;i++} else if (c===q) inQ=false; else row[col]+=c; }\n    else if (c===q) inQ=true; else if (c===d) row[++col]='';\n    else if (c==='\\n'||(c==='\\r'&&t[i+1]==='\\n')){if(c==='\\r')i++;rows.push(row);row=[''];col=0;}\n    else row[col]+=c;\n  }\n  if (row.length>1||row[0]!=='') rows.push(row);\n  if (!h||!rows.length) return rows;\n  let hd=rows[0];\n  return rows.slice(1).map(function(r){let o={};hd.forEach(function(n,i){o[n]=r[i]||''});return o;});\n}",
      "testCode": "var r1 = parseCSV('name,age\\nAlice,30\\nBob,25');\nif (r1.length !== 2) throw new Error('row count');\nif (r1[0].name !== 'Alice') throw new Error('field value');\nif (r1[1].age !== '25') throw new Error('second row');\nvar r2 = parseCSV('\"a,b\",c\\n\"d\"\"e\",f', { headers: false });\nif (r2[0][0] !== 'a,b') throw new Error('quoted comma');\nif (r2[1][0] !== 'd\"e') throw new Error('escaped quote');",
      "language": "typescript",
      "description": "CSV parser handling quoted fields, escaped quotes, and newlines within quotes (TypeScript variant)",
      "tags": [
        "csv",
        "parser",
        "io",
        "text",
        "delimiter",
        "data-import",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.91
    },
    {
      "id": "1531935cdb9d3b29",
      "name": "circuit-breaker-ts",
      "code": "class CircuitBreaker {\n  constructor(fn, o = {}) {\n    this._fn = fn; this._th = o.threshold || 5; this._to = o.timeout || 30000;\n    this._s = 'closed'; this._f = this._at = 0;\n  }\n  async call(...args) {\n    if (this._s === 'open') {\n      if (Date.now() - this._at >= this._to) this._s = 'half-open';\n      else throw new Error('Open');\n    }\n    try {\n      const r = await this._fn(...args);\n      this._f = 0; this._s = 'closed'; return r;\n    } catch (e) {\n      if (++this._f >= this._th) { this._s = 'open'; this._at = Date.now(); }\n      throw e;\n    }\n  }\n  getState() { return this._s; }\n}",
      "testCode": "let callCount = 0;\nconst breaker = new CircuitBreaker(async () => { callCount++; throw new Error('fail'); }, { threshold: 3, timeout: 100 });\nfor (let i = 0; i < 3; i++) { try { await breaker.call(); } catch(e) {} }\nif (breaker.getState() !== 'open') throw new Error('should be open after threshold failures');\nlet blocked = false;\ntry { await breaker.call(); } catch(e) { blocked = e.message === 'Open'; }\nif (!blocked) throw new Error('should block calls when circuit is open');\nif (callCount !== 3) throw new Error('should not invoke fn when open');\nconst ok = new CircuitBreaker(async (x) => x * 2, { threshold: 5 });\nconst r = await ok.call(21);\nif (r !== 42) throw new Error('should return result on success');",
      "language": "typescript",
      "description": "Circuit breaker with closed/open/half-open states, failure threshold, and automatic recovery (TypeScript variant)",
      "tags": [
        "circuit-breaker",
        "resilience",
        "fault-tolerance",
        "design-pattern",
        "reliability",
        "variant",
        "typescript"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 0.9
    },
    {
      "id": "48e049312289ada0",
      "name": "event-emitter-ts",
      "code": "class EventEmitter {\n  constructor() { this._e = {}; }\n  on(event, fn) {\n    (this._e[event] = this._e[event] || []).push(fn);\n    return this;\n  }\n  off(event, fn) {\n    if (this._e[event]) this._e[event] = this._e[event].filter(h => h !== fn);\n    return this;\n  }\n  emit(event, ...args) {\n    if (this._e[event]) this._e[event].slice().forEach(h => h(...args));\n    return this;\n  }\n  once(event, fn) {\n    const w = (...a) => { this.off(event, w); fn(...a); };\n    return this.on(event, w);\n  }\n}",
      "testCode": "const ee = new EventEmitter();\nlet called = 0;\nconst handler = () => called++;\nee.on('test', handler);\nee.emit('test');\nif (called !== 1) throw new Error('should call handler once');\nee.off('test', handler);\nee.emit('test');\nif (called !== 1) throw new Error('should not call after off');\nlet onceCount = 0;\nee.once('x', () => onceCount++);\nee.emit('x');\nee.emit('x');\nif (onceCount !== 1) throw new Error('once should fire only once');\nlet arg;\nee.on('data', v => { arg = v; });\nee.emit('data', 42);\nif (arg !== 42) throw new Error('should pass arguments to handler');",
      "language": "typescript",
      "description": "Minimal event emitter with on, off, emit, and once support (TypeScript variant)",
      "tags": [
        "event",
        "emitter",
        "pubsub",
        "observer",
        "design-pattern",
        "events",
        "variant",
        "typescript"
      ],
      "patternType": "design-pattern",
      "complexity": "composite",
      "coherency": 0.9
    },
    {
      "id": "d2e9d749227d3524",
      "name": "DependencyGraph-ts",
      "code": "class DependencyGraph {\n  constructor() { this.nodes = new Map(); }\n  addNode(id, meta = {}) { if (!this.nodes.has(id)) this.nodes.set(id, { deps: new Set(), meta }); return this; }\n  addEdge(from, to) { this.addNode(from); this.addNode(to); this.nodes.get(from).deps.add(to); return this; }\n  hasCycle() { \n    const visited = new Set(), stack = new Set();\n    const dfs = (id) => { if (stack.has(id)) return true; if (visited.has(id)) return false; visited.add(id); stack.add(id); for (const dep of (this.nodes.get(id)?.deps || [])) { if (dfs(dep)) return true; } stack.delete(id); return false; };\n    for (const id of this.nodes.keys()) { if (dfs(id)) return true; }\n    return false;\n  }\n  topologicalSort() {\n    const visited = new Set(), result = [];\n    const dfs = (id) => { if (visited.has(id)) return; visited.add(id); for (const dep of (this.nodes.get(id)?.deps || [])) dfs(dep); result.push(id); };\n    for (const id of this.nodes.keys()) dfs(id);\n    return result;\n  }\n  getImpact(id) { const affected = new Set(); for (const [nid, node] of this.nodes) { if (node.deps.has(id)) affected.add(nid); } return [...affected]; }\n}",
      "testCode": "\nconst g = new DependencyGraph();\ng.addNode('a').addNode('b').addNode('c').addEdge('a', 'b').addEdge('b', 'c');\nif (g.hasCycle()) throw new Error('false cycle');\nconst order = g.topologicalSort();\nif (order.indexOf('c') > order.indexOf('b')) throw new Error('topo fail');\nif (order.indexOf('b') > order.indexOf('a')) throw new Error('topo fail 2');\nconst impact = g.getImpact('c');\nif (!impact.includes('b')) throw new Error('impact fail');\n",
      "language": "typescript",
      "description": "Dependency graph with topological sort, cycle detection, and impact analysis (TypeScript variant)",
      "tags": [
        "graph",
        "dependency",
        "topological-sort",
        "data-structure",
        "algorithm",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.9
    },
    {
      "id": "c7c462d9e8963e40",
      "name": "compute",
      "code": "function compute(x) {\n  return x * 2 + 1;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "compute",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "46d329ff1637826a",
      "name": "compute",
      "code": "function compute(x) {\n  return x * 2;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "compute",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "2393c043803f0ee6",
      "name": "triple",
      "code": "const triple = (n) => {\n  return n * 3;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "triple",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "031d85cf9dbebbbe",
      "name": "mul",
      "code": "function mul(a, b) { return a * b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "mul",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "16b9659ec62c11ab",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "1720c949b7b0d739",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "9bbf25a45f277719",
      "name": "safeCode",
      "code": "function safeCode() { return 42; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "safeCode",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6c120bb081e1fc0a",
      "name": "x",
      "code": "function x() { return 42; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/sandbox.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "a4f5b4da872cc577",
      "name": "fib",
      "code": "function fib(n) { return fib(n-1) + fib(n-2); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "fib",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "06d0c7d24662f9f8",
      "name": "uniqueFn",
      "code": "function uniqueFn(x) { return x; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "uniqueFn",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "8e7cab57dfc20782",
      "name": "broken",
      "code": "function broken(n) { return n + 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "broken",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "bbae88bb3f65342a",
      "name": "square",
      "code": "function square(n) { return n * n; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "square",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "dfd16baa58d9931f",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "e79919865da5cd16",
      "name": "custom",
      "code": "function custom() { return base() + 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "custom",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "c7aecfce8f4fa3f1",
      "name": "base",
      "code": "function base() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "base",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "b8f08d954ba021fa",
      "name": "compB",
      "code": "function compB() { return 2; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "compB",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "c5a42d1b085fed4d",
      "name": "compA",
      "code": "function compA() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "compA",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d72150bf23a02a17",
      "name": "a",
      "code": "function a() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "a",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "4a6546f21ae64141",
      "name": "good",
      "code": "function good() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "good",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d836d432546f2c07",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "2f9a95f1a3290a52",
      "name": "c",
      "code": "function c() { return 3; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "c",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "a19ee369aa4e2337",
      "name": "b",
      "code": "function b() { return 2; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "b",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "4744cf6b8bb346b8",
      "name": "a",
      "code": "function a() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "a",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d8cc9ec5788ee14e",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/oracle.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "3adaa744ebcf2132",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/oracle.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6e693d4669cdc786",
      "name": "broken",
      "code": "function broken() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/oracle.test.js",
      "tags": [
        "broken",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6b6dc4407a5cafe6",
      "name": "roundTrip",
      "code": "function roundTrip(x) { return x * 2; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "roundTrip",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d644000c829dadd1",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "fc65b5af337fa47c",
      "name": "dry",
      "code": "function dry() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "dry",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "90db05c1515639f7",
      "name": "dup",
      "code": "function dup() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "dup",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "e04cff32d9cbed48",
      "name": "testFunc",
      "code": "function testFunc() { return 42; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "testFunc",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "8d9d1bab5869adfc",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/improvements.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d855a44c72fbd8de",
      "name": "mcpTest",
      "code": "function mcpTest() { return \"hello\"; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "mcpTest",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "0a656e4c2e6bfc6f",
      "name": "evTest",
      "code": "function evTest() { return 42; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "evTest",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "9115380cfa734aae",
      "name": "only",
      "code": "function only() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "only",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "23608076d6e90010",
      "name": "hidden",
      "code": "function hidden() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "hidden",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "ea604c61c7ff7b46",
      "name": "jsFunc",
      "code": "function jsFunc() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "jsFunc",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "5a7209f2befd1118",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "668135baf5f21af5",
      "name": "realFunction",
      "code": "function realFunction() { return 4; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "realFunction",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "876770e46000f3aa",
      "name": "sort",
      "code": "function sort(arr) { return arr.sort(); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/covenant.test.js",
      "tags": [
        "sort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "7d2045a9daa4dbd9",
      "name": "x",
      "code": "function x() { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/connectors.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "5d158c40a8b60bdd",
      "name": "x",
      "code": "const x = () => { return 1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/coherency.test.js",
      "tags": [
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "ad9a3acf91921458",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/auto-seed.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "3f8c1b1d8d9d37da",
      "name": "sub",
      "code": "function sub(a, b) { return a - b; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/ast.test.js",
      "tags": [
        "sub",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "2dbdd23f28ace43b",
      "name": "retry",
      "code": "async function retry(fn, maxRetries = 3, delay = 1000) {\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));\n      }\n    }\n  }\n  throw lastError;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "retry",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "46bacdbda6cf8c72",
      "name": "bfs",
      "code": "function bfs(graph, start) {\n  const visited = new Set([start]);\n  const queue = [start];\n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of (graph[node] || [])) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "bfs",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "abde69e2f12df2d5",
      "name": "binarySearch",
      "code": "function binarySearch(arr, target) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "binarySearch",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "76508333a4ec192b",
      "name": "buildQueryString",
      "code": "function buildQueryString(obj) {\n  var pairs = Object.keys(obj).filter(function(k) {\n    return obj[k] !== undefined;\n  }).map(function(k) {\n    return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);\n  });\n  return pairs.length ? '?' + pairs.join('&') : '';\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "buildQueryString",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "4a93b0951d44a3d2",
      "name": "isJSON",
      "code": "function isJSON(str) {\n  try { JSON.parse(str); return true; } catch(e) { return false; }\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "isJSON",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "9142e46ed0b45e3d",
      "name": "isURL",
      "code": "function isURL(str) {\n  try {\n    var url = new URL(str);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch(e) { return false; }\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "isURL",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "ebb702aeb8823424",
      "name": "daysInMonth",
      "code": "function daysInMonth(year, month) {\n  return new Date(year, month, 0).getDate();\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "daysInMonth",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "c4929cf486550dde",
      "name": "daysBetween",
      "code": "function daysBetween(d1, d2) {\n  var ms = Math.abs(new Date(d1) - new Date(d2));\n  return Math.floor(ms / 86400000);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "daysBetween",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "df6550872fb2947e",
      "name": "isLeapYear",
      "code": "function isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "isLeapYear",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "8bb96c2e513d6d4a",
      "name": "PriorityQueue",
      "code": "function PriorityQueue() { this.heap = []; }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "PriorityQueue",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6de5c28d3d2985f5",
      "name": "MinHeap",
      "code": "function MinHeap() { this.data = []; }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "MinHeap",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "e3ea8c0f72682386",
      "name": "Stack",
      "code": "function Stack() {\n  this.items = [];\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "Stack",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "941722ba7fe26bea",
      "name": "pMap",
      "code": "function pMap(items, fn, concurrency) {\n  concurrency = concurrency || Infinity;\n  var results = new Array(items.length);\n  var index = 0;\n  function worker() {\n    var work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }\n  var workers = [];\n  for (var i = 0; i < Math.min(concurrency, items.length); i++) workers.push(worker());\n  return Promise.all(workers).then(function() { return results; });\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "pMap",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "211b2ebad43b3ea8",
      "name": "promiseTimeout",
      "code": "function promiseTimeout(promise, ms) {\n  var timeout = new Promise(function(_, reject) {\n    setTimeout(function() { reject(new Error('timeout')); }, ms);\n  });\n  return Promise.race([promise, timeout]);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "promiseTimeout",
        "javascript",
        "harvested"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "29fd4efa883af6b9",
      "name": "randomInt",
      "code": "function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "randomInt",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "7dbcab2280875305",
      "name": "roundTo",
      "code": "function roundTo(num, places) {\n  var factor = Math.pow(10, places);\n  return Math.round((num + Number.EPSILON) * factor) / factor;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "roundTo",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "5c340b8821cc4475",
      "name": "isPrime",
      "code": "function isPrime(n) {\n  if (n < 2) return false;\n  if (n < 4) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (var i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "isPrime",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "042aa3521483b299",
      "name": "hasPath",
      "code": "function hasPath(obj, path) {\n  var keys = path.split('.');\n  var current = obj;\n  for (var i = 0; i < keys.length; i++) {\n    if (current == null || !current.hasOwnProperty(keys[i])) return false;\n    current = current[keys[i]];\n  }\n  return true;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "hasPath",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "62fa071887bc2eb7",
      "name": "freezeDeep",
      "code": "function freezeDeep(obj) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function(key) {\n    if (obj[key] && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {\n      freezeDeep(obj[key]);\n    }\n  });\n  return obj;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "freezeDeep",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "0074d00e20c8c52c",
      "name": "sampleArray",
      "code": "function sampleArray(arr, n) {\n  var shuffled = arr.slice();\n  for (var i = shuffled.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;\n  }\n  return shuffled.slice(0, n || 1);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "sampleArray",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "183d08d63ca727a6",
      "name": "padString",
      "code": "function padString(str, len, ch, right) {\n  ch = ch || ' ';\n  while (str.length < len) {\n    str = right ? str + ch : ch + str;\n  }\n  return str;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "padString",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "7307fa26af29bd1a",
      "name": "countOccurrences",
      "code": "function countOccurrences(str, sub) {\n  if (!sub.length) return 0;\n  var count = 0, pos = 0;\n  while ((pos = str.indexOf(sub, pos)) !== -1) { count++; pos += sub.length; }\n  return count;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "countOccurrences",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "258221066278b260",
      "name": "isPalindrome",
      "code": "function isPalindrome(str) {\n  var clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return clean === clean.split('').reverse().join('');\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "isPalindrome",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "205f3e860e25475c",
      "name": "repeatString",
      "code": "function repeatString(str, n) {\n  var result = '';\n  for (var i = 0; i < n; i++) result += str;\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "repeatString",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "0ecaa427c5a2fc07",
      "name": "unescapeHTML",
      "code": "function unescapeHTML(str) {\n  var map = {'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};\n  return str.replace(/&(?:amp|lt|gt|quot|#39);/g, function(m) { return map[m]; });\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "unescapeHTML",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "e7a57190e065b89a",
      "name": "escapeHTML",
      "code": "function escapeHTML(str) {\n  var map = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\n  return str.replace(/[&<>\"']/g, function(c) { return map[c]; });\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "escapeHTML",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "a54b13002b15af31",
      "name": "oracle.test",
      "code": "const { describe, it, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst { RemembranceOracle } = require('../src/api/oracle');\n\ndescribe('RemembranceOracle', () => {\n  let tmpDir;\n  let oracle;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, threshold: 0.5, autoSeed: false });\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('submit', () => {\n    it('accepts valid code with good coherency', () => {\n      const result = oracle.submit('function add(a, b) { return a + b; }', {\n        description: 'Add two numbers',\n        tags: ['math', 'utility'],\n        language: 'javascript',\n      });\n      assert.equal(result.accepted, true);\n      assert.ok(result.entry.id);\n      assert.ok(result.entry.coherencyScore.total >= 0.5);\n    });\n\n    it('rejects code that fails its test', () => {\n      const result = oracle.submit('function broken() { return 1; }', {\n        description: 'Bad code',\n        language: 'javascript',\n        testCode: 'if (broken() !== 999) throw new Error(\"FAIL\");',\n      });\n      assert.equal(result.accepted, false);\n      assert.ok(result.reason.length > 0);\n    });\n\n    it('accepts code that passes tests', () => {\n      const code = 'function double(n) { return n * 2; }';\n      const testCode = 'if (double(3) !== 6) throw new Error(\"FAIL\");';\n      const result = oracle.submit(code, {\n        testCode,\n        language: 'javascript',\n        tags: ['math'],\n      });\n      assert.equal(result.accepted, true);\n      assert.equal(result.validation.testPassed, true);\n    });\n\n    it('rejects code that fails tests', () => {\n      const code = 'function double(n) { return n + 2; }';\n      const testCode = 'if (double(3) !== 6) throw new Error(\"FAIL\");';\n      const result = oracle.submit(code, {\n        testCode,\n        language: 'javascript',\n        tags: ['math'],\n      });\n      assert.equal(result.accepted, false);\n    });\n  });\n\n  describe('query', () => {\n    it('returns relevant results ranked by coherency', () => {\n      oracle.submit('function sortArray(arr) { return arr.sort((a, b) => a - b); }', {\n        description: 'Sort array ascending',\n        tags: ['sort', 'array'],\n        language: 'javascript',\n      });\n      oracle.submit('function reverseString(s) { return s.split(\"\").reverse().join(\"\"); }', {\n        description: 'Reverse a string',\n        tags: ['string', 'reverse'],\n        language: 'javascript',\n      });\n\n      const results = oracle.query({\n        description: 'sort an array',\n        tags: ['sort'],\n        language: 'javascript',\n      });\n\n      assert.ok(results.length > 0);\n      assert.ok(results[0].code.includes('sort'));\n    });\n\n    it('filters by language', () => {\n      oracle.submit('function add(a, b) { return a + b; }', {\n        tags: ['math'],\n        language: 'javascript',\n      });\n\n      const pyResults = oracle.query({ language: 'python' });\n      // May return results but they should rank lower due to language mismatch\n      // The key is the system works\n      assert.ok(Array.isArray(pyResults));\n    });\n\n    it('returns empty for no matches', () => {\n      const results = oracle.query({\n        description: 'quantum computing',\n        minCoherency: 0.99,\n      });\n      assert.equal(results.length, 0);\n    });\n  });\n\n  describe('feedback', () => {\n    it('updates reliability on positive feedback', () => {\n      const { entry } = oracle.submit('function add(a, b) { return a + b; }', {\n        tags: ['math'],\n      });\n      const result = oracle.feedback(entry.id, true);\n      assert.equal(result.success, true);\n      assert.equal(result.newReliability, 1.0);\n    });\n\n    it('updates reliability on negative feedback', () => {\n      const { entry } = oracle.submit('function add(a, b) { return a + b; }', {\n        tags: ['math'],\n      });\n      oracle.feedback(entry.id, true);\n      oracle.feedback(entry.id, false);\n      const inspection = oracle.inspect(entry.id);\n      assert.equal(inspection.reliability.timesUsed, 2);\n      assert.equal(inspection.reliability.historicalScore, 0.5);\n    });\n\n    it('returns error for unknown id', () => {\n      const result = oracle.feedback('nonexistent', true);\n      assert.equal(result.success, false);\n    });\n  });\n\n  describe('stats', () => {\n    it('returns summary', () => {\n      oracle.submit('function x() { return 1; }', { tags: ['test'] });\n      const stats = oracle.stats();\n      assert.ok(stats.totalEntries >= 1);\n      assert.ok(Array.isArray(stats.languages));\n    });\n  });\n\n  describe('prune', () => {\n    it('removes low-coherency entries', () => {\n      oracle.submit('function x() { return 1; }', { tags: ['a'] });\n      const result = oracle.prune(0.99);\n      assert.ok(result.removed >= 0);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/oracle.test.js (17 functions)",
      "tags": [
        "assert",
        "fs",
        "path",
        "os",
        "result",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "a066c4cb7b99c35b",
      "name": "oracle-llm.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst os = require('os');\nconst fs = require('fs');\nconst { RemembranceOracle } = require('../src/api/oracle');\nconst { ClaudeBridge } = require('../src/core/claude-bridge');\n\n// Test with a fresh oracle in a temp directory\nfunction createTestOracle(claudeOverride) {\n  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n  const oracle = new RemembranceOracle({\n    baseDir: tmpDir,\n    autoSeed: false,\n    autoGrow: false,\n    claude: claudeOverride || null,\n  });\n  return { oracle, tmpDir };\n}\n\n// Create a mock Claude bridge that returns predictable responses\nfunction createMockClaude() {\n  const bridge = new ClaudeBridge({ verbose: false });\n  bridge._available = true;\n  bridge.prompt = function(prompt) {\n    if (prompt.includes('Convert this') || prompt.includes('Transpile') || prompt.includes('transpiler')) {\n      return '```python\\ndef add(a, b):\\n    return a + b\\n```';\n    }\n    if (prompt.includes('Generate comprehensive tests') || prompt.includes('test')) {\n      return '```javascript\\nif (add(1, 2) !== 3) throw new Error(\"fail\");\\nif (add(0, 0) !== 0) throw new Error(\"fail zero\");\\n```';\n    }\n    if (prompt.includes('alternative implementation')) {\n      return '```javascript\\nfunction add(a, b) { return a - (-b); }\\n```';\n    }\n    if (prompt.includes('Improve this')) {\n      return '```javascript\\nfunction add(a, b) {\\n  if (typeof a !== \"number\") throw new TypeError(\"a must be number\");\\n  return a + b;\\n}\\n```';\n    }\n    if (prompt.includes('Write a JSDoc') || prompt.includes('Write a Google') || prompt.includes('doc comment')) {\n      return '/**\\n * Adds two numbers together.\\n * @param {number} a - First number\\n * @param {number} b - Second number\\n * @returns {number} The sum\\n */';\n    }\n    if (prompt.includes('Analyze this')) {\n      return '{\"issues\": [{\"severity\": \"low\", \"description\": \"No type checking\"}], \"suggestions\": [\"Add type annotations\"], \"complexity\": \"low\", \"quality\": 0.85}';\n    }\n    if (prompt.includes('Explain what')) {\n      return 'This function adds two numbers together and returns their sum.';\n    }\n    return null;\n  };\n  return bridge;\n}\n\n// Register a test pattern in the oracle\nfunction registerTestPattern(oracle) {\n  return oracle.registerPattern({\n    name: 'add',\n    code: 'function add(a, b) { return a + b; }',\n    language: 'javascript',\n    description: 'Add two numbers',\n    tags: ['math', 'utility'],\n    testCode: 'if (add(1, 2) !== 3) throw new Error(\"fail\");',\n  });\n}\n\ndescribe('Oracle LLM Integration', () => {\n  let oracle, tmpDir, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    ({ oracle, tmpDir } = createTestOracle(mockClaude));\n    registerTestPattern(oracle);\n  });\n\n  it('isLLMAvailable returns true with mock', () => {\n    assert.equal(oracle.isLLMAvailable(), true);\n  });\n\n  it('isLLMAvailable returns false without claude', () => {\n    const { oracle: plain } = createTestOracle();\n    // Force unavailability\n    plain._getClaude()._available = false;\n    assert.equal(plain.isLLMAvailable(), false);\n  });\n});\n\ndescribe('Oracle llmTranspile', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('transpiles via Claude when available', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmTranspile(patterns[0].id, 'python');\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.ok(result.result.code.includes('def add'));\n    assert.equal(result.result.language, 'python');\n  });\n\n  it('falls back to AST when Claude fails', () => {\n    mockClaude.prompt = () => null; // Force Claude failure\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmTranspile(patterns[0].id, 'python');\n    // Should fall back to AST transpiler\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'ast');\n    assert.ok(result.result.code.includes('def'));\n  });\n\n  it('returns error for unknown pattern', () => {\n    const result = oracle.llmTranspile('nonexistent', 'python');\n    assert.equal(result.success, false);\n    assert.ok(result.error.includes('not found'));\n  });\n});\n\ndescribe('Oracle llmGenerateTests', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('generates tests via Claude', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmGenerateTests(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.ok(result.testCode.includes('add(1, 2)'));\n  });\n\n  it('returns error for unknown pattern', () => {\n    const result = oracle.llmGenerateTests('nonexistent');\n    assert.equal(result.success, false);\n  });\n});\n\ndescribe('Oracle llmRefine', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('refines via Claude', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmRefine(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.ok(result.refinedCode.includes('function add'));\n  });\n\n  it('falls back to reflection when Claude fails', () => {\n    mockClaude.prompt = () => null;\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmRefine(patterns[0].id);\n    // Reflection may or may not improve — but should return with reflection method or fail gracefully\n    assert.ok(result.method === 'reflection' || result.method === 'none');\n  });\n});\n\ndescribe('Oracle llmAlternative', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('generates alternative via Claude', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmAlternative(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.equal(result.alternative.name, 'add-alt');\n    assert.ok(result.alternative.tags.includes('alternative'));\n  });\n});\n\ndescribe('Oracle llmDocs', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('generates docs via Claude', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmDocs(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.ok(result.docs.includes('Adds two numbers'));\n  });\n});\n\ndescribe('Oracle llmAnalyze', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n  });\n\n  it('analyzes via Claude', () => {\n    const result = oracle.llmAnalyze('function add(a, b) { return a + b; }', 'javascript');\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.equal(result.analysis.quality, 0.85);\n    assert.equal(result.analysis.complexity, 'low');\n  });\n\n  it('falls back to coherency when Claude fails', () => {\n    mockClaude.prompt = () => null;\n    const result = oracle.llmAnalyze('function add(a, b) { return a + b; }', 'javascript');\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'coherency');\n    assert.ok(typeof result.analysis.quality === 'number');\n  });\n});\n\ndescribe('Oracle llmExplain', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('explains via Claude', () => {\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmExplain(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'claude');\n    assert.ok(result.explanation.includes('adds'));\n  });\n\n  it('falls back to metadata when Claude fails', () => {\n    mockClaude.prompt = () => null;\n    const patterns = oracle.patterns.getAll();\n    const result = oracle.llmExplain(patterns[0].id);\n    assert.equal(result.success, true);\n    assert.equal(result.method, 'metadata');\n  });\n});\n\ndescribe('Oracle llmGenerate', () => {\n  let oracle, mockClaude;\n\n  beforeEach(() => {\n    mockClaude = createMockClaude();\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-llm-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, autoGrow: false, claude: mockClaude });\n    registerTestPattern(oracle);\n  });\n\n  it('generates LLM-enhanced candidates', () => {\n    const result = oracle.llmGenerate({ maxPatterns: 5, languages: ['python'] });\n    assert.equal(result.method, 'claude');\n    assert.ok(result.generated >= 0);\n  });\n\n  it('falls back to regex when Claude unavailable', () => {\n    mockClaude._available = false;\n    const result = oracle.llmGenerate({ maxPatterns: 5 });\n    assert.equal(result.method, 'regex');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/oracle-llm.test.js (14 functions)",
      "tags": [
        "assert",
        "path",
        "os",
        "fs",
        "createTestOracle",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "d15b9e25847f4a48",
      "name": "improvements.test",
      "code": "const { describe, it, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst http = require('http');\nconst { RemembranceOracle } = require('../src/api/oracle');\n\n// ─── Oracle Event System ───\n\ndescribe('Oracle Event System', () => {\n  let tmpDir, oracle;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-events-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, threshold: 0.5, autoSeed: false });\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  it('fires event on submit', () => {\n    const events = [];\n    oracle.on(e => events.push(e));\n    oracle.submit('function add(a, b) { return a + b; }', {\n      description: 'Add two numbers',\n      tags: ['math'],\n      language: 'javascript',\n    });\n    assert.ok(events.some(e => e.type === 'entry_added'));\n  });\n\n  it('fires event on feedback', () => {\n    const events = [];\n    const { entry } = oracle.submit('function add(a, b) { return a + b; }', {\n      tags: ['math'],\n      language: 'javascript',\n    });\n    oracle.on(e => events.push(e));\n    oracle.feedback(entry.id, true);\n    assert.ok(events.some(e => e.type === 'feedback'));\n    assert.ok(events.some(e => e.succeeded === true));\n  });\n\n  it('fires event on registerPattern', () => {\n    const events = [];\n    oracle.on(e => events.push(e));\n    oracle.registerPattern({\n      name: 'test-add',\n      code: 'function add(a, b) { return a + b; }',\n      language: 'javascript',\n      description: 'Addition',\n      tags: ['math'],\n    });\n    assert.ok(events.some(e => e.type === 'pattern_registered'));\n  });\n\n  it('unsubscribe works', () => {\n    const events = [];\n    const unsub = oracle.on(e => events.push(e));\n    unsub();\n    oracle.submit('function x() { return 1; }', { tags: ['test'] });\n    assert.equal(events.length, 0);\n  });\n\n  it('listener errors do not break oracle', () => {\n    oracle.on(() => { throw new Error('boom'); });\n    // Should not throw\n    const result = oracle.submit('function add(a, b) { return a + b; }', {\n      tags: ['math'],\n      language: 'javascript',\n    });\n    assert.equal(result.accepted, true);\n  });\n});\n\n// ─── Pattern Import ───\n\ndescribe('Oracle Import', () => {\n  let tmpDir, oracle;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-import-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, threshold: 0.5, autoSeed: false });\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  it('imports patterns from exported JSON string', () => {\n    // Register one pattern, export, then import into fresh oracle\n    oracle.registerPattern({\n      name: 'test-func',\n      code: 'function testFunc() { return 42; }',\n      language: 'javascript',\n      description: 'Test function',\n      tags: ['test'],\n    });\n    const exported = oracle.export({ format: 'json' });\n\n    // Fresh oracle\n    const tmpDir2 = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-import2-'));\n    const oracle2 = new RemembranceOracle({ baseDir: tmpDir2, threshold: 0.5, autoSeed: false });\n\n    const result = oracle2.import(exported);\n    assert.ok(result.imported >= 1);\n    assert.equal(result.errors.length, 0);\n\n    fs.rmSync(tmpDir2, { recursive: true, force: true });\n  });\n\n  it('imports patterns from parsed object', () => {\n    const data = {\n      patterns: [\n        { name: 'add-fn', code: 'function add(a, b) { return a + b; }', language: 'javascript', description: 'Add' },\n      ],\n    };\n    const result = oracle.import(data);\n    assert.equal(result.imported, 1);\n  });\n\n  it('skips duplicate patterns', () => {\n    const data = {\n      patterns: [\n        { name: 'dup-fn', code: 'function dup() { return 1; }', language: 'javascript', description: 'Dup' },\n      ],\n    };\n    oracle.import(data);\n    const result = oracle.import(data);\n    assert.equal(result.skipped, 1);\n    assert.ok(result.results.some(r => r.status === 'duplicate'));\n  });\n\n  it('skips patterns without code or name', () => {\n    const data = { patterns: [{ description: 'no code' }] };\n    const result = oracle.import(data);\n    assert.equal(result.skipped, 1);\n    assert.ok(result.errors.length > 0);\n  });\n\n  it('dry run does not write', () => {\n    const data = {\n      patterns: [\n        { name: 'dry-fn', code: 'function dry() { return 1; }', language: 'javascript', description: 'Dry' },\n      ],\n    };\n    const result = oracle.import(data, { dryRun: true });\n    assert.equal(result.imported, 1);\n    assert.ok(result.results.some(r => r.status === 'would_import'));\n    // Verify nothing was actually stored\n    const patterns = oracle.patterns.getAll();\n    assert.ok(!patterns.some(p => p.name === 'dry-fn'));\n  });\n\n  it('fires import_complete event', () => {\n    const events = [];\n    oracle.on(e => events.push(e));\n    oracle.import({\n      patterns: [{ name: 'evt-fn', code: 'function x() { return 1; }', language: 'javascript', description: 'x' }],\n    });\n    assert.ok(events.some(e => e.type === 'import_complete'));\n  });\n\n  it('export → import round trip preserves patterns', () => {\n    oracle.registerPattern({\n      name: 'round-trip',\n      code: 'function roundTrip(x) { return x * 2; }',\n      language: 'javascript',\n      description: 'Double a value',\n      tags: ['math', 'utility'],\n    });\n    const exported = oracle.export({ format: 'json' });\n\n    const tmpDir2 = fs.mkdtempSync(path.join(os.tmpdir(), 'oracle-rt-'));\n    const oracle2 = new RemembranceOracle({ baseDir: tmpDir2, threshold: 0.5, autoSeed: false });\n    oracle2.import(exported);\n\n    const patterns = oracle2.patterns.getAll();\n    assert.ok(patterns.some(p => p.name === 'round-trip'));\n\n    fs.rmSync(tmpDir2, { recursive: true, force: true });\n  });\n});\n\n// ─── Combined Reflection Transform (applyHeal) ───\n\ndescribe('applyHeal — combined transform', () => {\n  const { applyHeal, generateCandidates } = require('../src/core/reflection');\n\n  it('applies all 5 strategies in sequence', () => {\n    const code = 'var x = 1;   \\nif(x == true) { console.log(\"yes\") }';\n    const healed = applyHeal(code, 'javascript');\n    // Should have: const (not var), === (not ==), space after if, trimmed whitespace\n    assert.ok(!healed.includes('var '), 'Should replace var');\n    assert.ok(healed.includes('if ('), 'Should add space after if');\n  });\n\n  it('is included as 6th candidate in generateCandidates', () => {\n    const candidates = generateCandidates('var x = 1;', 'javascript');\n    assert.equal(candidates.length, 6);\n    assert.ok(candidates.some(c => c.strategy === 'heal'));\n  });\n\n  it('heal candidate applies combined changes', () => {\n    const code = 'var x = 1;   \\n\\n\\n\\nvar y = 2;';\n    const candidates = generateCandidates(code, 'javascript');\n    const healCandidate = candidates.find(c => c.strategy === 'heal');\n    assert.ok(healCandidate.changed, 'heal should change the code');\n    assert.ok(!healCandidate.code.includes('var '), 'heal should replace var');\n  });\n});\n\n// ─── Rate Limiting ───\n\ndescribe('Rate Limiting', () => {\n  const { createRateLimiter } = require('../src/dashboard/server');\n\n  it('allows requests within limit', () => {\n    const limiter = createRateLimiter({ windowMs: 1000, maxRequests: 5 });\n    let blocked = false;\n    const fakeReq = { socket: { remoteAddress: '1.2.3.4' } };\n    const fakeRes = {\n      headers: {},\n      setHeader(k, v) { this.headers[k] = v; },\n      writeHead() {},\n      end() { blocked = true; },\n    };\n    limiter(fakeReq, fakeRes, () => {});\n    assert.equal(blocked, false);\n    assert.equal(fakeRes.headers['X-RateLimit-Limit'], 5);\n    assert.ok(fakeRes.headers['X-RateLimit-Remaining'] >= 0);\n  });\n\n  it('blocks requests over limit', () => {\n    const limiter = createRateLimiter({ windowMs: 60000, maxRequests: 3 });\n    let blockedCount = 0;\n    const fakeReq = { socket: { remoteAddress: '5.6.7.8' } };\n\n    for (let i = 0; i < 5; i++) {\n      let passed = false;\n      const fakeRes = {\n        headers: {},\n        setHeader(k, v) { this.headers[k] = v; },\n        writeHead(code) { if (code === 429) blockedCount++; },\n        end() {},\n      };\n      limiter(fakeReq, fakeRes, () => { passed = true; });\n    }\n    assert.ok(blockedCount >= 2, `Expected >= 2 blocked, got ${blockedCount}`);\n  });\n\n  it('tracks different IPs separately', () => {\n    const limiter = createRateLimiter({ windowMs: 60000, maxRequests: 2 });\n    let passedA = 0, passedB = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const fakeRes = { headers: {}, setHeader() {}, writeHead() {}, end() {} };\n      limiter({ socket: { remoteAddress: '10.0.0.1' } }, fakeRes, () => { passedA++; });\n    }\n    for (let i = 0; i < 3; i++) {\n      const fakeRes = { headers: {}, setHeader() {}, writeHead() {}, end() {} };\n      limiter({ socket: { remoteAddress: '10.0.0.2' } }, fakeRes, () => { passedB++; });\n    }\n    assert.equal(passedA, 2);\n    assert.equal(passedB, 2);\n  });\n\n  it('dashboard integrates rate limiter when auth is enabled', () => {\n    const { createDashboardServer } = require('../src/dashboard/server');\n    // rateLimit defaults to true when auth is not false\n    // Just verify server creates without errors\n    const server = createDashboardServer(undefined, { auth: false, rateLimit: false });\n    assert.ok(server);\n    server.close();\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/improvements.test.js (33 functions)",
      "tags": [
        "assert",
        "fs",
        "path",
        "os",
        "http",
        "javascript",
        "harvested"
      ],
      "patternType": "design-pattern",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "836c8e461bd4de14",
      "name": "quicksort.test",
      "code": "// Test for quickSort (validator concatenates code + test, so quickSort is already in scope)\nconst _assert = (cond, msg) => { if (!cond) throw new Error(msg); };\n\n_assert(JSON.stringify(quickSort([3,1,2])) === '[1,2,3]', 'basic sort failed');\n_assert(JSON.stringify(quickSort([])) === '[]', 'empty array failed');\n_assert(JSON.stringify(quickSort([1])) === '[1]', 'single element failed');\n_assert(JSON.stringify(quickSort([5,3,8,1,9,2])) === '[1,2,3,5,8,9]', 'larger array failed');\n_assert(JSON.stringify(quickSort([1,1,1])) === '[1,1,1]', 'duplicates failed');\nconsole.log('All quickSort tests passed!');\n",
      "language": "javascript",
      "description": "Harvested from . — examples/quicksort.test.js (1 functions)",
      "tags": [
        "_assert",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "28e13a7c0ac8db15",
      "name": "handler",
      "code": "const handler = (chunk) => {\n        data.push(chunk);\n        clientSocket.removeListener('data', handler);\n        resolve();\n      }",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "handler",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "14ea0815ee3b00e7",
      "name": "check",
      "code": "const check = () => {\n        if (wss.clients.size >= count) resolve();\n        else setTimeout(check, 20);\n      }",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "check",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "95dfe2f40a602324",
      "name": "onData",
      "code": "const onData = (chunk) => {\n      buf += chunk.toString();\n      const endOfHeaders = buf.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders !== -1) {\n        socket.removeListener('data', onData);\n        const headerSection = buf.slice(0, endOfHeaders);\n        const remaining = Buffer.from(buf.slice(endOfHeaders + 4), 'binary');\n        resolve({ socket, headers: headerSection, remaining });\n      }\n    }",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "onData",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "fe9f86c2fffa2477",
      "name": "connectRawWebSocket",
      "code": "function connectRawWebSocket(port, key) {\n  return new Promise((resolve, reject) => {\n    const socket = net.createConnection({ port, host: '127.0.0.1' }, () => {\n      socket.write(buildUpgradeRequest(key));\n    });\n\n    let buf = '';\n    const onData = (chunk) => {\n      buf += chunk.toString();\n      const endOfHeaders = buf.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders !== -1) {\n        socket.removeListener('data', onData);\n        const headerSection = buf.slice(0, endOfHeaders);\n        const remaining = Buffer.from(buf.slice(endOfHeaders + 4), 'binary');\n        resolve({ socket, headers: headerSection, remaining });\n      }\n    };\n\n    socket.on('data', onData);\n    socket.on('error', reject);\n  });\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "connectRawWebSocket",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "ec7ff0014ad6281d",
      "name": "httpGet",
      "code": "function httpGet(url) {\n  return new Promise((resolve, reject) => {\n    http.get(url, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data, headers: res.headers }));\n    }).on('error', reject);\n  });\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "httpGet",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "7051268306702a4a",
      "name": "encodeTextFrame",
      "code": "function encodeTextFrame(text) {\n  const payload = Buffer.from(text, 'utf8');\n  const mask = crypto.randomBytes(4);\n  const masked = Buffer.from(payload);\n  for (let i = 0; i < masked.length; i++) {\n    masked[i] ^= mask[i & 3];\n  }\n\n  let header;\n  if (payload.length < 126) {\n    header = Buffer.allocUnsafe(2);\n    header[0] = 0x81; // FIN + text opcode\n    header[1] = 0x80 | payload.length; // masked bit + length\n  } else {\n    header = Buffer.allocUnsafe(4);\n    header[0] = 0x81;\n    header[1] = 0x80 | 126;\n    header.writeUInt16BE(payload.length, 2);\n  }\n\n  return Buffer.concat([header, mask, masked]);\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "encodeTextFrame",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "bc8a5b2f73eaf407",
      "name": "buildUpgradeRequest",
      "code": "function buildUpgradeRequest(key, path = '/') {\n  return (\n    `GET ${path} HTTP/1.1\\r\\n` +\n    `Host: localhost\\r\\n` +\n    `Upgrade: websocket\\r\\n` +\n    `Connection: Upgrade\\r\\n` +\n    `Sec-WebSocket-Key: ${key}\\r\\n` +\n    `Sec-WebSocket-Version: 13\\r\\n` +\n    `\\r\\n`\n  );\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "buildUpgradeRequest",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "e89b0d9bb9e9c54c",
      "name": "farewell",
      "code": "function farewell(name) {\n  return 'Bye ' + name;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "farewell",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "86f9c886ca7c04dd",
      "name": "greet",
      "code": "function greet(name) {\n  return 'Hello ' + name;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "greet",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "246df039e7500ac5",
      "name": "calculateTotal",
      "code": "function calculateTotal(items) {\n  let total = 0;\n  for (let i = 0; i < items.length; i++) {\n    total += items[i].price;\n  }\n  return total;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "calculateTotal",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "cef96458514cca2f",
      "name": "add",
      "code": "function   add(a,b){\nvar result=a+b;\nreturn result\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "a3690e893f058e66",
      "name": "makeTempDir",
      "code": "function makeTempDir() {\n  const dir = path.join(os.tmpdir(), `recycler-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "makeTempDir",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "479abccfe8a466c9",
      "name": "reverseString",
      "code": "function reverseString(s) { return s.split(\"\").reverse().join(\"\"); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/oracle.test.js",
      "tags": [
        "reverseString",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6f9da0d2470342fa",
      "name": "sortArray",
      "code": "function sortArray(arr) { return arr.sort((a, b) => a - b); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/oracle.test.js",
      "tags": [
        "sortArray",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "993757d8ca086944",
      "name": "beta",
      "code": "function beta() {\n  return 'beta function result here';\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "beta",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "7084159643ae87b8",
      "name": "alpha",
      "code": "function alpha() {\n  return 'alpha function result';\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "alpha",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "2a427c6f6fbd7ccd",
      "name": "capitalize",
      "code": "function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "capitalize",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "83a5559f4bf561eb",
      "name": "lerp",
      "code": "function lerp(a, b, t) { return a + (b - a) * t; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "lerp",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "3f0bfdaed3f717d2",
      "name": "f",
      "code": "function f() { if (true) { return 1; } return 0; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "8b2a640fe23b004f",
      "name": "bsearch",
      "code": "function bsearch(arr, t) { let lo = 0, hi = arr.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; if (arr[mid] === t) return mid; arr[mid] < t ? lo = mid + 1 : hi = mid - 1; } return -1; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "bsearch",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "a35aba5ce53b9a5c",
      "name": "mergeSort",
      "code": "function mergeSort(arr) { if (arr.length <= 1) return arr; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "mergeSort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "d69f1e6840db9433",
      "name": "mergeSort",
      "code": "function mergeSort(arr) {\n      if (arr.length <= 1) return arr;\n      const mid = Math.floor(arr.length / 2);\n      const left = mergeSort(arr.slice(0, mid));\n      const right = mergeSort(arr.slice(mid));\n      return merge(left, right);\n    }",
      "language": "javascript",
      "description": "Harvested function from . — tests/covenant.test.js",
      "tags": [
        "mergeSort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "532f04dd458b8e77",
      "name": "seedLibrary",
      "code": "function seedLibrary(oracle) {\n  const existing = oracle.patterns.getAll();\n  const existingNames = new Set(existing.map(p => p.name));\n\n  let registered = 0, skipped = 0, failed = 0;\n\n  for (const seed of SEEDS) {\n    if (existingNames.has(seed.name)) {\n      skipped++;\n      continue;\n    }\n\n    const result = oracle.registerPattern(seed);\n    if (result.registered) {\n      registered++;\n    } else {\n      failed++;\n      console.log(`  [FAIL] ${seed.name}: ${result.reason}`);\n    }\n  }\n\n  return { registered, skipped, failed, total: SEEDS.length };\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "seedLibrary",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "8ea0db3f6abc7599",
      "name": "validateEmail",
      "code": "function validateEmail(email) {\n  if (typeof email !== 'string') return false;\n  const re = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n  return re.test(email) && email.length <= 254;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "validateEmail",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "232fa8d86e69e7b1",
      "name": "fn",
      "code": "const fn = async () => { attempts++; if (attempts < 3) throw new Error(\"fail\"); return \"ok\"; }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "fn",
        "javascript",
        "harvested"
      ],
      "patternType": "concurrency",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "007c458001f72729",
      "name": "luhnCheck",
      "code": "function luhnCheck(num) {\n  var str = String(num).replace(/\\\\D/g, '');\n  var sum = 0, alt = false;\n  for (var i = str.length - 1; i >= 0; i--) {\n    var n = parseInt(str[i], 10);\n    if (alt) { n *= 2; if (n > 9) n -= 9; }\n    sum += n;\n    alt = !alt;\n  }\n  return sum % 10 === 0;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "luhnCheck",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "a68c592e9d44efa0",
      "name": "curried",
      "code": "function curried() {\n    var args = Array.prototype.slice.call(arguments);\n    if (args.length >= fn.length) return fn.apply(this, args);\n    return function() {\n      return curried.apply(this, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "curried",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "c006f8cfa52fe6c8",
      "name": "BloomFilter",
      "code": "function BloomFilter(size) {\n  this.size = size || 256;\n  this.bits = new Uint8Array(this.size);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "BloomFilter",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "5979f907f3a5ea0a",
      "name": "LinkedList",
      "code": "function LinkedList() { this.head = null; this.length = 0; }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "LinkedList",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "af2d71f4678ac5e4",
      "name": "worker",
      "code": "function worker() {\n    var work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "worker",
        "javascript",
        "harvested"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "676d0d1c03d4b514",
      "name": "titleCase",
      "code": "function titleCase(str) {\n  return str.replace(/\\\\b\\\\w/g, function(c) { return c.toUpperCase(); });\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "titleCase",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "6464dae682e0689a",
      "name": "wordCount",
      "code": "function wordCount(str) {\n  var trimmed = str.trim();\n  if (!trimmed) return 0;\n  return trimmed.split(/\\\\s+/).length;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "wordCount",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "67c1518e213d144b",
      "name": "slugify",
      "code": "function slugify(str) {\n  return str.toLowerCase().trim()\n    .replace(/[^a-z0-9\\\\s-]/g, '')\n    .replace(/[\\\\s-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "slugify",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "d1409e41e50f07e8",
      "name": "kebabCase",
      "code": "function kebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\\\s]+/g, '-').toLowerCase();\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "kebabCase",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "b2a225c79d998fb1",
      "name": "snakeCase",
      "code": "function snakeCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\\\s]+/g, '_').toLowerCase();\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "snakeCase",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "e9cb556db0bbb5f8",
      "name": "camelCase",
      "code": "function camelCase(str) {\n  return str.replace(/[-_\\\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')\n            .replace(/^[A-Z]/, c => c.toLowerCase());\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "camelCase",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "f0d6c1fe14f33196",
      "name": "handleDispatch",
      "code": "function handleDispatch() {\n  let input = '';\n  process.stdin.setEncoding('utf-8');\n  process.stdin.on('data', chunk => { input += chunk; });\n  process.stdin.on('end', () => {\n    try {\n      const payload = JSON.parse(input);\n      const command = payload.action\n        ? payload\n        : { action: payload.command || 'stats', params: payload.params || payload };\n\n      const result = connector.execute(command);\n      console.log(JSON.stringify(result, null, 2));\n    } catch (err) {\n      console.error('Failed to parse dispatch payload:', err.message);\n      process.exit(1);\n    }\n  });\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/connectors/github-handler.js",
      "tags": [
        "handleDispatch",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "122ec57f7d41687f",
      "name": "getCode",
      "code": "function getCode(args) {\n  if (args.file) return fs.readFileSync(path.resolve(args.file), 'utf-8');\n  const stdin = readStdin();\n  if (stdin.trim()) return stdin;\n  return null;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli.js",
      "tags": [
        "getCode",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "b44238af03782c25",
      "name": "readStdin",
      "code": "function readStdin() {\n  if (process.stdin.isTTY) return '';\n  try {\n    return fs.readFileSync(0, 'utf-8');\n  } catch {\n    return '';\n  }\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli.js",
      "tags": [
        "readStdin",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "c5ab0b94d25cca54",
      "name": "parseArgs",
      "code": "function parseArgs(args) {\n  const parsed = { _command: args[0] };\n  for (let i = 1; i < args.length; i++) {\n    if (args[i].startsWith('--')) {\n      const key = args[i].slice(2);\n      const val = args[i + 1] && !args[i + 1].startsWith('--') ? args[i + 1] : true;\n      parsed[key] = val;\n      if (val !== true) i++;\n    }\n  }\n  return parsed;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli.js",
      "tags": [
        "parseArgs",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "6d1d9ab656464408",
      "name": "colorSource",
      "code": "function colorSource(source) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "colorSource",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "64b026a7491fb9a6",
      "name": "colorDiff",
      "code": "function colorDiff(type, line) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "colorDiff",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "e4c53ba4adc1ce8f",
      "name": "colorStatus",
      "code": "function colorStatus(accepted) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "colorStatus",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "07a0d79e94608472",
      "name": "colorDecision",
      "code": "function colorDecision(decision) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "colorDecision",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "6a076dbde6ed7a1a",
      "name": "colorScore",
      "code": "function colorScore(score) {\n  if (score == null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "colorScore",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "e796eedf88349e3e",
      "name": "wrap",
      "code": "function wrap(code, text) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/cli/colors.js",
      "tags": [
        "wrap",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "3f6a2e3c2fd5051d",
      "name": "wrapWithTracking",
      "code": "function wrapWithTracking(oracle) {\n  const reporter = new CIFeedbackReporter(oracle);\n\n  const origResolve = oracle.resolve.bind(oracle);\n  oracle.resolve = function (request) {\n    const result = origResolve(request);\n    if (result.pattern && result.decision === 'pull') {\n      reporter.trackPull({ id: result.pattern.id, name: result.pattern.name, source: 'pattern' });\n    }\n    return result;\n  };\n\n  const origQuery = oracle.query.bind(oracle);\n  oracle.query = function (query) {\n    const results = origQuery(query);\n    for (const r of results.slice(0, 1)) { // Track only the top result\n      reporter.trackPull({ id: r.id, name: r.description, source: 'history' });\n    }\n    return results;\n  };\n\n  oracle._feedbackReporter = reporter;\n  return reporter;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/ci/feedback.js",
      "tags": [
        "wrapWithTracking",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "806c8f59ff052f80",
      "name": "setOutput",
      "code": "function setOutput(name, value) {\n  const filePath = process.env.GITHUB_OUTPUT;\n  if (filePath) {\n    fs.appendFileSync(filePath, `${name}=${typeof value === 'object' ? JSON.stringify(value) : value}\\n`);\n  }\n  console.log(`::set-output name=${name}::${typeof value === 'object' ? JSON.stringify(value) : value}`);\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/action.js",
      "tags": [
        "setOutput",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.88
    },
    {
      "id": "e33de0c2735e758c",
      "name": "getInput",
      "code": "function getInput(name) {\n  const envVar = `INPUT_${name.replace(/-/g, '_').toUpperCase()}`;\n  return process.env[envVar] || '';\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/action.js",
      "tags": [
        "getInput",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.88
    },
    {
      "id": "d1f731bddd272e9c",
      "name": "_assert",
      "code": "const _assert = (cond, msg) => { if (!cond) throw new Error(msg); }",
      "language": "javascript",
      "description": "Harvested function from . — examples/quicksort.test.js",
      "tags": [
        "_assert",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.88
    },
    {
      "id": "e950870a76b213ab",
      "name": "multi-file.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  ModulePattern,\n  DependencyGraph,\n  TemplateEngine,\n  ModuleStore,\n  scaffold,\n  compose,\n  detectFileLanguage,\n  inferFileRole,\n  extractImports,\n  resolveImport,\n} = require('../src/patterns/multi-file');\n\n// ─── ModulePattern ───\n\ndescribe('ModulePattern', () => {\n  it('creates a module pattern', () => {\n    const mod = new ModulePattern({\n      name: 'auth-module',\n      description: 'Authentication module',\n      files: [\n        { path: 'src/auth.js', code: 'module.exports = {}' },\n        { path: 'tests/auth.test.js', code: 'assert.ok(true)' },\n      ],\n      tags: ['auth', 'security'],\n    });\n    assert.ok(mod.id);\n    assert.equal(mod.name, 'auth-module');\n    assert.equal(mod.files.length, 2);\n    assert.equal(mod.files[0].language, 'javascript');\n    assert.equal(mod.files[0].role, 'source');\n    assert.equal(mod.files[1].role, 'test');\n  });\n\n  it('throws without name', () => {\n    assert.throws(() => new ModulePattern({ files: [{ path: 'a.js', code: '' }] }), /name required/i);\n  });\n\n  it('throws without files', () => {\n    assert.throws(() => new ModulePattern({ name: 'x', files: [] }), /At least one file/);\n  });\n\n  it('getMain returns first file or main role', () => {\n    const mod = new ModulePattern({\n      name: 'test',\n      files: [\n        { path: 'src/utils.js', code: 'helper' },\n        { path: 'src/index.js', code: 'main' },\n      ],\n    });\n    assert.equal(mod.getMain().path, 'src/index.js');\n  });\n\n  it('getTests returns test files', () => {\n    const mod = new ModulePattern({\n      name: 'test',\n      files: [\n        { path: 'src/lib.js', code: 'code' },\n        { path: 'tests/lib.test.js', code: 'test1' },\n        { path: 'tests/lib.spec.js', code: 'test2' },\n      ],\n    });\n    assert.equal(mod.getTests().length, 2);\n  });\n\n  it('serializes to/from JSON', () => {\n    const mod = new ModulePattern({\n      name: 'json-test',\n      description: 'Test JSON roundtrip',\n      files: [{ path: 'a.js', code: 'x' }],\n      tags: ['test'],\n      template: { name: 'default' },\n    });\n    const json = mod.toJSON();\n    assert.equal(json.type, 'module');\n    const restored = ModulePattern.fromJSON(json);\n    assert.equal(restored.name, 'json-test');\n    assert.equal(restored.id, mod.id);\n  });\n\n  it('getDependencyGraph detects internal imports', () => {\n    const mod = new ModulePattern({\n      name: 'graph-test',\n      files: [\n        { path: 'src/index.js', code: \"const utils = require('./utils');\" },\n        { path: 'src/utils.js', code: 'module.exports = {}' },\n      ],\n    });\n    const graph = mod.getDependencyGraph();\n    const deps = graph.dependenciesOf('src/index.js');\n    assert.equal(deps.length, 1);\n    assert.equal(deps[0], 'src/utils.js');\n  });\n});\n\n// ─── DependencyGraph ───\n\ndescribe('DependencyGraph', () => {\n  let graph;\n\n  beforeEach(() => {\n    graph = new DependencyGraph();\n    graph.addNode('A');\n    graph.addNode('B');\n    graph.addNode('C');\n    graph.addEdge('A', 'B');\n    graph.addEdge('B', 'C');\n  });\n\n  it('tracks nodes and edges', () => {\n    assert.equal(graph.nodes().length, 3);\n    assert.deepEqual(graph.dependenciesOf('A'), ['B']);\n    assert.deepEqual(graph.dependentsOf('C'), ['B']);\n  });\n\n  it('topological sort returns dependency order', () => {\n    const sorted = graph.topologicalSort();\n    assert.ok(sorted.indexOf('C') < sorted.indexOf('B'));\n    assert.ok(sorted.indexOf('B') < sorted.indexOf('A'));\n  });\n\n  it('detects cycles', () => {\n    graph.addEdge('C', 'A');\n    const cycles = graph.detectCycles();\n    assert.ok(cycles.length > 0);\n  });\n\n  it('throws on topological sort with cycle', () => {\n    graph.addEdge('C', 'A');\n    assert.throws(() => graph.topologicalSort(), /Circular dependency/);\n  });\n\n  it('impact analysis finds affected nodes', () => {\n    const affected = graph.impactOf('C');\n    assert.ok(affected.includes('B'));\n    assert.ok(affected.includes('A'));\n  });\n\n  it('leaves are nodes with no dependencies', () => {\n    const leaves = graph.leaves();\n    assert.deepEqual(leaves, ['C']);\n  });\n\n  it('roots are nodes nothing depends on', () => {\n    const roots = graph.roots();\n    assert.deepEqual(roots, ['A']);\n  });\n\n  it('computes depths', () => {\n    const depths = graph.depths();\n    assert.equal(depths['C'], 0);\n    assert.equal(depths['B'], 1);\n    assert.equal(depths['A'], 2);\n  });\n});\n\n// ─── TemplateEngine ───\n\ndescribe('TemplateEngine', () => {\n  it('renders simple variables', () => {\n    const result = TemplateEngine.render('Hello {{name}}!', { name: 'World' });\n    assert.equal(result, 'Hello World!');\n  });\n\n  it('handles conditionals', () => {\n    const tpl = '{{#if auth}}requireAuth();{{/if}}';\n    assert.equal(TemplateEngine.render(tpl, { auth: true }), 'requireAuth();');\n    assert.equal(TemplateEngine.render(tpl, { auth: false }), '');\n  });\n\n  it('handles each loops with strings', () => {\n    const tpl = '{{#each items}}import {{this}};\\n{{/each}}';\n    const result = TemplateEngine.render(tpl, { items: ['fs', 'path'] });\n    assert.equal(result, 'import fs;\\nimport path;\\n');\n  });\n\n  it('handles each loops with objects', () => {\n    const tpl = '{{#each fields}}{{name}}: {{type}},\\n{{/each}}';\n    const result = TemplateEngine.render(tpl, {\n      fields: [\n        { name: 'id', type: 'string' },\n        { name: 'count', type: 'number' },\n      ],\n    });\n    assert.ok(result.includes('id: string'));\n    assert.ok(result.includes('count: number'));\n  });\n\n  it('leaves unknown variables as-is', () => {\n    const result = TemplateEngine.render('{{known}} {{unknown}}', { known: 'yes' });\n    assert.equal(result, 'yes {{unknown}}');\n  });\n\n  it('extracts variables', () => {\n    const vars = TemplateEngine.extractVariables(\n      '{{name}} {{#if auth}}{{secret}}{{/if}} {{#each items}}{{this}}{{/each}}'\n    );\n    assert.ok(vars.includes('name'));\n    assert.ok(vars.includes('auth'));\n    assert.ok(vars.includes('secret'));\n    assert.ok(vars.includes('items'));\n    assert.ok(!vars.includes('this'));\n  });\n\n  it('validates variables', () => {\n    const result = TemplateEngine.validate('{{a}} {{b}} {{c}}', { a: 1, b: 2 });\n    assert.equal(result.valid, false);\n    assert.deepEqual(result.missing, ['c']);\n  });\n});\n\n// ─── ModuleStore ───\n\ndescribe('ModuleStore', () => {\n  let store;\n\n  beforeEach(() => {\n    store = new ModuleStore();\n  });\n\n  it('saves and retrieves modules', () => {\n    const mod = new ModulePattern({\n      name: 'test-mod',\n      files: [{ path: 'a.js', code: 'x' }],\n    });\n    store.save(mod);\n    const retrieved = store.get(mod.id);\n    assert.equal(retrieved.name, 'test-mod');\n  });\n\n  it('lists modules with tag filter', () => {\n    store.save(new ModulePattern({ name: 'a', files: [{ path: 'a.js', code: '' }], tags: ['auth'] }));\n    store.save(new ModulePattern({ name: 'b', files: [{ path: 'b.js', code: '' }], tags: ['util'] }));\n    assert.equal(store.list({ tag: 'auth' }).length, 1);\n  });\n\n  it('lists modules with search', () => {\n    store.save(new ModulePattern({ name: 'logger', description: 'Logging utility', files: [{ path: 'l.js', code: '' }] }));\n    store.save(new ModulePattern({ name: 'cache', description: 'Caching layer', files: [{ path: 'c.js', code: '' }] }));\n    assert.equal(store.list({ search: 'log' }).length, 1);\n  });\n\n  it('deletes modules', () => {\n    const mod = new ModulePattern({ name: 'del', files: [{ path: 'a.js', code: '' }] });\n    store.save(mod);\n    store.delete(mod.id);\n    assert.equal(store.get(mod.id), null);\n  });\n\n  it('computes stats', () => {\n    store.save(new ModulePattern({ name: 'a', files: [{ path: 'a.js', code: '' }, { path: 'b.py', code: '' }] }));\n    const stats = store.stats();\n    assert.equal(stats.totalModules, 1);\n    assert.equal(stats.totalFiles, 2);\n    assert.ok(stats.languages.includes('javascript'));\n    assert.ok(stats.languages.includes('python'));\n  });\n});\n\n// ─── Scaffold ───\n\ndescribe('scaffold', () => {\n  it('generates files from module pattern', () => {\n    const mod = new ModulePattern({\n      name: 'api',\n      files: [\n        { path: 'src/{{name}}.js', code: 'class {{name}} {}' },\n        { path: 'tests/{{name}}.test.js', code: 'test(\"{{name}}\")' },\n      ],\n      template: { name: 'UserService' },\n    });\n    const files = scaffold(mod, { name: 'UserService' });\n    assert.equal(files.length, 2);\n    assert.equal(files[0].path, 'src/UserService.js');\n    assert.ok(files[0].code.includes('class UserService'));\n  });\n\n  it('applies output directory prefix', () => {\n    const mod = new ModulePattern({\n      name: 'simple',\n      files: [{ path: 'index.js', code: '' }],\n    });\n    const files = scaffold(mod, {}, { outputDir: 'my-project' });\n    assert.equal(files[0].path, 'my-project/index.js');\n  });\n});\n\n// ─── Compose ───\n\ndescribe('compose', () => {\n  it('combines multiple modules', () => {\n    const modA = new ModulePattern({\n      name: 'utils',\n      files: [{ path: 'src/utils.js', code: 'export const add = (a,b) => a+b;' }],\n    });\n    const modB = new ModulePattern({\n      name: 'app',\n      files: [{ path: 'src/app.js', code: \"import { add } from './utils';\" }],\n      requires: [modA.id],\n    });\n    const result = compose([modA, modB]);\n    assert.equal(result.files.length, 2);\n    assert.ok(result.graph.nodes().includes(modA.id));\n  });\n\n  it('deduplicates files by path', () => {\n    const a = new ModulePattern({ name: 'a', files: [{ path: 'shared.js', code: 'v1' }] });\n    const b = new ModulePattern({ name: 'b', files: [{ path: 'shared.js', code: 'v2' }] });\n    const result = compose([a, b]);\n    assert.equal(result.files.length, 1);\n  });\n\n  it('throws on circular dependencies', () => {\n    const a = new ModulePattern({ name: 'a', files: [{ path: 'a.js', code: '' }] });\n    const b = new ModulePattern({ name: 'b', files: [{ path: 'b.js', code: '' }], requires: [a.id] });\n    a.requires = [b.id];\n    assert.throws(() => compose([a, b]), /Circular module dependencies/);\n  });\n});\n\n// ─── Helpers ───\n\ndescribe('detectFileLanguage', () => {\n  it('detects common languages', () => {\n    assert.equal(detectFileLanguage('app.js'), 'javascript');\n    assert.equal(detectFileLanguage('app.ts'), 'typescript');\n    assert.equal(detectFileLanguage('app.py'), 'python');\n    assert.equal(detectFileLanguage('app.go'), 'go');\n    assert.equal(detectFileLanguage('app.rs'), 'rust');\n    assert.equal(detectFileLanguage('app.rb'), 'ruby');\n    assert.equal(detectFileLanguage('app.java'), 'java');\n    assert.equal(detectFileLanguage('style.css'), 'css');\n    assert.equal(detectFileLanguage('data.json'), 'json');\n    assert.equal(detectFileLanguage('config.yaml'), 'yaml');\n  });\n});\n\ndescribe('inferFileRole', () => {\n  it('infers roles from paths', () => {\n    assert.equal(inferFileRole('tests/auth.test.js'), 'test');\n    assert.equal(inferFileRole('src/index.js'), 'main');\n    assert.equal(inferFileRole('types.d.ts'), 'types');\n    assert.equal(inferFileRole('README.md'), 'docs');\n    assert.equal(inferFileRole('package.json'), 'config');\n    assert.equal(inferFileRole('src/utils.js'), 'source');\n  });\n});\n\ndescribe('extractImports', () => {\n  it('extracts JS require imports', () => {\n    const code = \"const fs = require('fs');\\nconst lib = require('./lib');\";\n    const imports = extractImports(code, 'javascript');\n    assert.ok(imports.includes('fs'));\n    assert.ok(imports.includes('./lib'));\n  });\n\n  it('extracts ES module imports', () => {\n    const code = \"import { foo } from './foo';\\nimport bar from 'bar';\";\n    const imports = extractImports(code, 'javascript');\n    assert.ok(imports.includes('./foo'));\n    assert.ok(imports.includes('bar'));\n  });\n\n  it('extracts Python imports', () => {\n    const code = \"from os import path\\nimport sys\";\n    const imports = extractImports(code, 'python');\n    assert.ok(imports.includes('os'));\n    assert.ok(imports.includes('sys'));\n  });\n\n  it('extracts Go imports', () => {\n    const code = 'import (\\n  \"fmt\"\\n  \"os\"\\n)';\n    const imports = extractImports(code, 'go');\n    assert.ok(imports.includes('fmt'));\n    assert.ok(imports.includes('os'));\n  });\n});\n\ndescribe('resolveImport', () => {\n  const known = new Set(['src/utils.js', 'src/lib/helper.js', 'src/index.js']);\n\n  it('resolves relative import', () => {\n    assert.equal(resolveImport('./utils', 'src/main.js', known), 'src/utils.js');\n  });\n\n  it('resolves parent directory import', () => {\n    assert.equal(resolveImport('../utils', 'src/lib/deep.js', known), 'src/utils.js');\n  });\n\n  it('returns null for external packages', () => {\n    assert.equal(resolveImport('express', 'src/app.js', known), null);\n  });\n\n  it('resolves index file', () => {\n    assert.equal(resolveImport('./', 'src/main.js', known), 'src/index.js');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/multi-file.test.js (29 functions)",
      "tags": [
        "assert",
        "mod",
        "json",
        "restored",
        "utils",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.86
    },
    {
      "id": "397e45e8dab7ad8f",
      "name": "ast.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { parseCode, parseJavaScript, parsePython, astCoherencyBoost } = require('../src/core/parsers/ast');\n\ndescribe('parseJavaScript', () => {\n  it('parses valid JS and extracts functions', () => {\n    const result = parseJavaScript('function add(a, b) { return a + b; }\\nfunction sub(a, b) { return a - b; }');\n    assert.equal(result.valid, true);\n    assert.equal(result.functions.length, 2);\n    assert.equal(result.functions[0].name, 'add');\n    assert.deepEqual(result.functions[0].params, ['a', 'b']);\n  });\n\n  it('extracts arrow functions', () => {\n    const result = parseJavaScript('const add = (a, b) => a + b;');\n    assert.ok(result.functions.some(f => f.name === 'add'));\n  });\n\n  it('extracts classes', () => {\n    const result = parseJavaScript('class Animal { }\\nclass Dog extends Animal { }');\n    assert.equal(result.classes.length, 2);\n    assert.equal(result.classes[1].extends, 'Animal');\n  });\n\n  it('extracts require imports', () => {\n    const result = parseJavaScript(\"const fs = require('fs');\\nconst path = require('path');\");\n    assert.ok(result.imports.includes('fs'));\n    assert.ok(result.imports.includes('path'));\n  });\n\n  it('extracts exports', () => {\n    const result = parseJavaScript('module.exports = { add };');\n    assert.ok(result.exports.length > 0);\n  });\n\n  it('calculates cyclomatic complexity', () => {\n    const code = 'function f(x) { if (x > 0) { for (let i = 0; i < x; i++) { if (i % 2) { } } } }';\n    const result = parseJavaScript(code);\n    assert.ok(result.complexity.cyclomatic >= 4);\n  });\n\n  it('calculates nesting depth', () => {\n    const result = parseJavaScript('function f() { if (true) { if (true) { while (true) { } } } }');\n    assert.ok(result.complexity.maxDepth >= 4);\n  });\n\n  it('reports invalid syntax', () => {\n    const result = parseJavaScript('function { broken syntax !!!');\n    assert.equal(result.valid, false);\n    assert.ok(result.errors.length > 0);\n  });\n});\n\ndescribe('parsePython', () => {\n  it('extracts function definitions', () => {\n    const result = parsePython('def add(a, b):\\n    return a + b\\n\\ndef sub(a, b):\\n    return a - b');\n    assert.equal(result.functions.length, 2);\n    assert.equal(result.functions[0].name, 'add');\n  });\n\n  it('extracts class definitions', () => {\n    const result = parsePython('class Animal:\\n    pass\\n\\nclass Dog(Animal):\\n    pass');\n    assert.equal(result.classes.length, 2);\n    assert.equal(result.classes[1].extends, 'Animal');\n  });\n\n  it('extracts imports', () => {\n    const result = parsePython('import os\\nfrom pathlib import Path');\n    assert.ok(result.imports.includes('os'));\n    assert.ok(result.imports.includes('pathlib'));\n  });\n\n  it('calculates complexity', () => {\n    const result = parsePython('def f(x):\\n    if x > 0:\\n        for i in range(x):\\n            if i % 2:\\n                pass');\n    assert.ok(result.complexity.cyclomatic >= 4);\n  });\n});\n\ndescribe('parseCode', () => {\n  it('dispatches to JS parser', () => {\n    const result = parseCode('const x = 1;', 'javascript');\n    assert.ok('functions' in result);\n  });\n\n  it('dispatches to Python parser', () => {\n    const result = parseCode('x = 1', 'python');\n    assert.ok('functions' in result);\n  });\n\n  it('uses generic parser for unknown languages', () => {\n    const result = parseCode('int main() { return 0; }', 'c');\n    assert.ok('complexity' in result);\n  });\n});\n\ndescribe('astCoherencyBoost', () => {\n  it('boosts valid code with structure', () => {\n    const { boost } = astCoherencyBoost('function add(a, b) { return a + b; }\\nmodule.exports = { add };', 'javascript');\n    assert.ok(boost > 0);\n  });\n\n  it('penalizes highly complex code', () => {\n    const deepCode = 'function f() { ' + 'if (true) { '.repeat(10) + '}'.repeat(10) + ' }';\n    const { boost } = astCoherencyBoost(deepCode, 'javascript');\n    assert.ok(boost <= 0.05);\n  });\n\n  it('stays within -0.1 to 0.1 range', () => {\n    const { boost } = astCoherencyBoost('function x() {}', 'javascript');\n    assert.ok(boost >= -0.1 && boost <= 0.1);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/ast.test.js (12 functions)",
      "tags": [
        "assert",
        "result",
        "add",
        "sub",
        "fs",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.86
    },
    {
      "id": "0a227565adcaed71",
      "name": "tagsTest-ts",
      "code": "function tagsTest(x: any) {\\n  return x + 1;\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "tagsTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "353040ac339e112f",
      "name": "handleDispatch-ts",
      "code": "function handleDispatch() {\n  let input = '';\n  process.stdin.setEncoding('utf-8');\n  process.stdin.on('data', chunk => { input += chunk; });\n  process.stdin.on('end', () => {\n    try {\n      const payload = JSON.parse(input);\n      const command = payload.action\n        ? payload\n        : { action: payload.command || 'stats', params: payload.params || payload };\n\n      const result = connector.execute(command);\n      console.log(JSON.stringify(result, null, 2));\n    } catch (err) {\n      console.error('Failed to parse dispatch payload:', err.message);\n      process.exit(1);\n    }\n  });\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/connectors/github-handler.js (TypeScript variant)",
      "tags": [
        "handleDispatch",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "1772e234994e62a4",
      "name": "escapeHTML-ts",
      "code": "function escapeHTML(str: string) {\n  let map = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\n  return str.replace(/[&<>\"']/g, function(c) { return map[c]; });\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "escapeHTML",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "eece9d300aefae63",
      "name": "unescapeHTML-ts",
      "code": "function unescapeHTML(str: string) {\n  let map = {'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};\n  return str.replace(/&(?:amp|lt|gt|quot|#39);/g, function(m) { return map[m]; });\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "unescapeHTML",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "aa9b25f3acfb5d34",
      "name": "repeatString-ts",
      "code": "function repeatString(str: string, n: any) {\n  let result = '';\n  for (let i = 0; i < n; i++) result += str;\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "repeatString",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "b8a5626c9bd3a161",
      "name": "isPalindrome-ts",
      "code": "function isPalindrome(str: string) {\n  let clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return clean === clean.split('').reverse().join('');\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "isPalindrome",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "ad812c432d5522a4",
      "name": "countOccurrences-ts",
      "code": "function countOccurrences(str: string, sub: any[]) {\n  if (!sub.length) return 0;\n  let count = 0, pos = 0;\n  while ((pos = str.indexOf(sub, pos)) !== -1) { count++; pos += sub.length; }\n  return count;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "countOccurrences",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "75cb2e18a199e7b2",
      "name": "padString-ts",
      "code": "function padString(str: any[], len: number, ch: any, right: any) {\n  ch = ch || ' ';\n  while (str.length < len) {\n    str = right ? str + ch : ch + str;\n  }\n  return str;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "padString",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "1261f6f941513fc7",
      "name": "sampleArray-ts",
      "code": "function sampleArray(arr: any, n: any) {\n  let shuffled = arr.slice();\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    let tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;\n  }\n  return shuffled.slice(0, n || 1);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "sampleArray",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "2e0c054574ad5053",
      "name": "freezeDeep-ts",
      "code": "function freezeDeep(obj: any[]) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function(key) {\n    if (obj[key] && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {\n      freezeDeep(obj[key]);\n    }\n  });\n  return obj;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "freezeDeep",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "67ab75bf9443a0d0",
      "name": "hasPath-ts",
      "code": "function hasPath(obj: Record<string, any>, path: string) {\n  let keys = path.split('.');\n  let current = obj;\n  for (let i = 0; i < keys.length; i++) {\n    if (current == null || !current.hasOwnProperty(keys[i])) return false;\n    current = current[keys[i]];\n  }\n  return true;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "hasPath",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "9e274906ee6eb953",
      "name": "isPrime-ts",
      "code": "function isPrime(n: any) {\n  if (n < 2) return false;\n  if (n < 4) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "isPrime",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "c472ba0d63c35876",
      "name": "roundTo-ts",
      "code": "function roundTo(num: number, places: number) {\n  let factor = Math.pow(10, places);\n  return Math.round((num + Number.EPSILON) * factor) / factor;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "roundTo",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "960cc8fabf44863d",
      "name": "randomInt-ts",
      "code": "function randomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "randomInt",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "f20d627a23eda8cd",
      "name": "Stack-ts",
      "code": "function Stack() {\n  this.items = [];\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "Stack",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "e09d73f44f701dee",
      "name": "MinHeap-ts",
      "code": "function MinHeap() { this.data = []; }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "MinHeap",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "ea5004f52a314162",
      "name": "LinkedList-ts",
      "code": "function LinkedList() { this.head = null; this.length = 0; }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "LinkedList",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "954fe4715f567811",
      "name": "PriorityQueue-ts",
      "code": "function PriorityQueue() { this.heap = []; }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "PriorityQueue",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "8e00d6378ba06a13",
      "name": "isLeapYear-ts",
      "code": "function isLeapYear(year: any) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "isLeapYear",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "1137da79ae296c03",
      "name": "daysBetween-ts",
      "code": "function daysBetween(d1: any, d2: any) {\n  let ms = Math.abs(new Date(d1) - new Date(d2));\n  return Math.floor(ms / 86400000);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "daysBetween",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "799fd323870f1e25",
      "name": "daysInMonth-ts",
      "code": "function daysInMonth(year: any, month: any) {\n  return new Date(year, month, 0).getDate();\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "daysInMonth",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "af47b3798dc20d63",
      "name": "isURL-ts",
      "code": "function isURL(str: string) {\n  try {\n    let url = new URL(str);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch(e) { return false; }\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "isURL",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "a2b4ef8e5786d2be",
      "name": "isJSON-ts",
      "code": "function isJSON(str: string) {\n  try { JSON.parse(str); return true; } catch(e) { return false; }\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "isJSON",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "def526396fd110c6",
      "name": "buildQueryString-ts",
      "code": "function buildQueryString(obj: any[]) {\n  let pairs = Object.keys(obj).filter(function(k) {\n    return obj[k] !== undefined;\n  }).map(function(k) {\n    return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);\n  });\n  return pairs.length ? '?' + pairs.join('&') : '';\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "buildQueryString",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "55086f91b5bdc3c7",
      "name": "binarySearch-ts",
      "code": "function binarySearch(arr: any[], target: any) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "binarySearch",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "751a422d5a1a01e3",
      "name": "bfs-ts",
      "code": "function bfs(graph: any[], start: number) {\n  const visited = new Set([start]);\n  const queue = [start];\n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of (graph[node] || [])) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "bfs",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "6d6e985eba0cb5ca",
      "name": "fn-ts",
      "code": "const fn = async () => { attempts++; if (attempts < 3) throw new Error(\"fail\"); return \"ok\"; }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "fn",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "48c57afec2d65706",
      "name": "sort-ts",
      "code": "function sort(arr: any) { return arr.sort(); }",
      "language": "typescript",
      "description": "Harvested function from . — tests/covenant.test.js (TypeScript variant)",
      "tags": [
        "sort",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "d4d8439e99e69f81",
      "name": "realFunction-ts",
      "code": "function realFunction() { return 4; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "realFunction",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "9b83685188e4fd96",
      "name": "jsFunc-ts",
      "code": "function jsFunc() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "jsFunc",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "27a3e5af2f1c15c7",
      "name": "hidden-ts",
      "code": "function hidden() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "hidden",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "0fe8c2a41a5485e5",
      "name": "only-ts",
      "code": "function only() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "only",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "7ffb67e49ff5e0ff",
      "name": "evTest-ts",
      "code": "function evTest() { return 42; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "evTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "e65a8efd6b59826f",
      "name": "mcpTest-ts",
      "code": "function mcpTest() { return \"hello\"; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/harvest.test.js (TypeScript variant)",
      "tags": [
        "mcpTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "ef6b61e77711cf2e",
      "name": "testFunc-ts",
      "code": "function testFunc() { return 42; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/improvements.test.js (TypeScript variant)",
      "tags": [
        "testFunc",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "a290a85a438601de",
      "name": "dup-ts",
      "code": "function dup() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/improvements.test.js (TypeScript variant)",
      "tags": [
        "dup",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "b461dc0938602ded",
      "name": "dry-ts",
      "code": "function dry() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/improvements.test.js (TypeScript variant)",
      "tags": [
        "dry",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "35f0236173c991d0",
      "name": "roundTrip-ts",
      "code": "function roundTrip(x: any) { return x * 2; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/improvements.test.js (TypeScript variant)",
      "tags": [
        "roundTrip",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "8b988b0076f62012",
      "name": "b-ts",
      "code": "function b() { return 2; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "b",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "c5d40370b6466188",
      "name": "c-ts",
      "code": "function c() { return 3; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "c",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "00c6594c151a3fa5",
      "name": "good-ts",
      "code": "function good() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "good",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "b43a5329242f23ef",
      "name": "a-ts",
      "code": "function a() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "a",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "5e05c568b48d612c",
      "name": "compA-ts",
      "code": "function compA() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "compA",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "6d7a578dde5c0dea",
      "name": "compB-ts",
      "code": "function compB() { return 2; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "compB",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "4480232267064d72",
      "name": "base-ts",
      "code": "function base() { return 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "base",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "4cfa90c466ef14bf",
      "name": "custom-ts",
      "code": "function custom() { return base() + 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "custom",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "b66694821e8d6d14",
      "name": "makeTempDir-ts",
      "code": "function makeTempDir() {\n  const dir = path.join(os.tmpdir(), `recycler-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "makeTempDir",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "012e0eac32632c1f",
      "name": "square-ts",
      "code": "function square(n: any) { return n * n; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "square",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "ac3aa22579773e08",
      "name": "broken-ts",
      "code": "function broken(n: any) { return n + 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "broken",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "529f94e3251bf44b",
      "name": "uniqueFn-ts",
      "code": "function uniqueFn(x: any) { return x; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "uniqueFn",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "7661ac59eb24d3f0",
      "name": "inc-ts",
      "code": "function inc(n: any) { return n + 1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "inc",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "2cff8a5835c454a0",
      "name": "x-ts",
      "code": "function x() { return 42; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/sandbox.test.js (TypeScript variant)",
      "tags": [
        "x",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "4ce73d9294afbc23",
      "name": "safeCode-ts",
      "code": "function safeCode() { return 42; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "safeCode",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "6dbbe1ab4597c613",
      "name": "sub-ts",
      "code": "function sub(a: any, b: any) { return a - b; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "sub",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "f723fef249890355",
      "name": "mul-ts",
      "code": "function mul(a: any, b: any) { return a * b; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "mul",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "6647e7079c45e872",
      "name": "compute-ts",
      "code": "function compute(x: any) {\n  return x * 2 + 1;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "compute",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "0d943172de9e56c1",
      "name": "vectors.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { getVector, embedDocument, vectorSimilarity, nearestTerms, VOCABULARY, DIMENSIONS } = require('../src/core/vectors');\n\ndescribe('getVector', () => {\n  it('returns vector for known term', () => {\n    const v = getVector('sort');\n    assert.ok(v);\n    assert.equal(v.length, 32);\n  });\n\n  it('returns null for unknown term', () => {\n    assert.equal(getVector('xyznonexistent'), null);\n  });\n\n  it('handles hyphenated terms', () => {\n    const v = getVector('binary-search');\n    assert.ok(v);\n    assert.equal(v.length, 32);\n  });\n\n  it('is case-insensitive', () => {\n    const lower = getVector('sort');\n    const upper = getVector('SORT');\n    assert.deepStrictEqual(lower, upper);\n  });\n\n  it('normalizes spaces to hyphens', () => {\n    const v = getVector('binary search');\n    assert.ok(v);\n  });\n});\n\ndescribe('embedDocument', () => {\n  it('returns 32-dimensional vector', () => {\n    const v = embedDocument('sort an array using quicksort');\n    assert.equal(v.length, 32);\n  });\n\n  it('normalizes to unit vector', () => {\n    const v = embedDocument('binary search algorithm');\n    let mag = 0;\n    for (let i = 0; i < 32; i++) mag += v[i] * v[i];\n    mag = Math.sqrt(mag);\n    assert.ok(Math.abs(mag - 1.0) < 0.01, `expected unit vector, got magnitude ${mag}`);\n  });\n\n  it('returns zero vector for unknown text', () => {\n    const v = embedDocument('xyzxyz abcabc');\n    const allZero = v.every(x => x === 0);\n    assert.ok(allZero);\n  });\n\n  it('handles bigrams', () => {\n    const withBigram = embedDocument('binary search');\n    const withoutBigram = embedDocument('binary');\n    // They should differ since bigram adds signal\n    assert.notDeepStrictEqual(withBigram, withoutBigram);\n  });\n});\n\ndescribe('vectorSimilarity', () => {\n  it('returns high similarity for related concepts', () => {\n    const sim = vectorSimilarity('quicksort algorithm', 'merge sort array');\n    assert.ok(sim > 0.7, `expected > 0.7, got ${sim}`);\n  });\n\n  it('returns lower similarity for unrelated concepts', () => {\n    const sim = vectorSimilarity('sort array', 'http request network');\n    assert.ok(sim < 0.7, `expected < 0.7, got ${sim}`);\n  });\n\n  it('returns high for same text', () => {\n    const sim = vectorSimilarity('cache memoize', 'cache memoize');\n    assert.ok(sim > 0.99, `expected ~1.0, got ${sim}`);\n  });\n\n  it('handles intent queries', () => {\n    const sim = vectorSimilarity('prevent calling too often', 'throttle debounce rate limit');\n    assert.ok(sim > 0.5, `expected > 0.5, got ${sim}`);\n  });\n});\n\ndescribe('nearestTerms', () => {\n  it('returns sorted results for cache query', () => {\n    const results = nearestTerms('cache', 5);\n    assert.ok(results.length > 0);\n    assert.ok(results[0].similarity >= results[results.length - 1].similarity);\n  });\n\n  it('returns sort-related terms for sorting query', () => {\n    const results = nearestTerms('sort', 5);\n    const terms = results.map(r => r.term);\n    assert.ok(terms.some(t => t.includes('sort') || t === 'search' || t === 'pivot'));\n  });\n\n  it('returns empty for unknown terms', () => {\n    const results = nearestTerms('xyznonexistent', 5);\n    assert.equal(results.length, 0);\n  });\n});\n\ndescribe('VOCABULARY', () => {\n  it('has 150+ terms', () => {\n    assert.ok(Object.keys(VOCABULARY).length >= 150, `only ${Object.keys(VOCABULARY).length} terms`);\n  });\n\n  it('all vectors are 32-dimensional', () => {\n    for (const [term, vec] of Object.entries(VOCABULARY)) {\n      assert.equal(vec.length, 32, `${term} has ${vec.length} dimensions`);\n    }\n  });\n});\n\ndescribe('DIMENSIONS', () => {\n  it('has 32 named dimensions', () => {\n    assert.equal(DIMENSIONS.length, 32);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/vectors.test.js (12 functions)",
      "tags": [
        "assert",
        "v",
        "lower",
        "upper",
        "mag",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "5a62440480c2aa95",
      "name": "relevance.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  computeRelevance,\n  rankEntries,\n  tokenize,\n  cosineSimilarity,\n  computeTF,\n} = require('../src/core/relevance');\n\ndescribe('tokenize', () => {\n  it('lowercases and splits on non-alphanumeric', () => {\n    const tokens = tokenize('Hello World! foo_bar');\n    assert.deepEqual(tokens, ['hello', 'world', 'foo_bar']);\n  });\n\n  it('filters single-char tokens', () => {\n    const tokens = tokenize('a b cd ef');\n    assert.deepEqual(tokens, ['cd', 'ef']);\n  });\n});\n\ndescribe('cosineSimilarity', () => {\n  it('returns 1 for identical vectors', () => {\n    const tf = { a: 0.5, b: 0.5 };\n    assert.ok(Math.abs(cosineSimilarity(tf, tf) - 1) < 1e-10);\n  });\n\n  it('returns 0 for orthogonal vectors', () => {\n    const tfA = { a: 1 };\n    const tfB = { b: 1 };\n    assert.equal(cosineSimilarity(tfA, tfB), 0);\n  });\n});\n\ndescribe('computeRelevance', () => {\n  it('scores high for matching tags and language', () => {\n    const query = { description: 'sort array', tags: ['sort'], language: 'javascript' };\n    const entry = {\n      description: 'Sort array ascending',\n      tags: ['sort', 'array'],\n      language: 'javascript',\n      coherencyScore: { total: 0.9 },\n    };\n    const result = computeRelevance(query, entry);\n    assert.ok(result.relevance > 0.5);\n  });\n\n  it('scores low for unrelated entries', () => {\n    const query = { description: 'machine learning', tags: ['ml'], language: 'python' };\n    const entry = {\n      description: 'CSS flex layout',\n      tags: ['css', 'layout'],\n      language: 'css',\n      coherencyScore: { total: 0.5 },\n    };\n    const result = computeRelevance(query, entry);\n    assert.ok(result.relevance < 0.4);\n  });\n});\n\ndescribe('rankEntries', () => {\n  it('ranks more relevant entries first', () => {\n    const entries = [\n      { description: 'CSS styling', tags: ['css'], language: 'css', coherencyScore: { total: 0.9 } },\n      { description: 'Sort array', tags: ['sort', 'array'], language: 'javascript', coherencyScore: { total: 0.8 } },\n      { description: 'Random unrelated', tags: ['other'], language: 'go', coherencyScore: { total: 0.7 } },\n    ];\n    const ranked = rankEntries({ description: 'sort array', tags: ['sort'], language: 'javascript' }, entries);\n    assert.ok(ranked.length > 0);\n    assert.ok(ranked[0].description.toLowerCase().includes('sort'));\n  });\n\n  it('filters by minimum coherency', () => {\n    const entries = [\n      { description: 'Good code', tags: ['a'], language: 'js', coherencyScore: { total: 0.9 } },\n      { description: 'Bad code', tags: ['a'], language: 'js', coherencyScore: { total: 0.2 } },\n    ];\n    const ranked = rankEntries({ description: 'code', tags: ['a'] }, entries, { minCoherency: 0.5 });\n    assert.equal(ranked.length, 1);\n  });\n\n  it('respects limit', () => {\n    const entries = Array.from({ length: 20 }, (_, i) => ({\n      description: `Entry ${i}`, tags: ['test'], language: 'js', coherencyScore: { total: 0.8 },\n    }));\n    const ranked = rankEntries({ description: 'entry', tags: ['test'] }, entries, { limit: 3 });\n    assert.equal(ranked.length, 3);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/relevance.test.js (10 functions)",
      "tags": [
        "assert",
        "tokens",
        "tf",
        "tfA",
        "tfB",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "1dc69a4fccf7a641",
      "name": "colors",
      "code": "/**\n * Zero-dependency ANSI color helpers for CLI output.\n *\n * Colors are automatically disabled when:\n * - stdout is not a TTY (piped/redirected)\n * - NO_COLOR env var is set (https://no-color.org)\n * - --no-color flag is passed\n */\n\nconst enabled = process.stdout.isTTY && !process.env.NO_COLOR && !process.argv.includes('--no-color');\n\nconst codes = {\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underline: '\\x1b[4m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n  gray: '\\x1b[90m',\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n  bgBlue: '\\x1b[44m',\n};\n\nfunction wrap(code, text) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}\n\nconst c = {\n  bold: (t) => wrap(codes.bold, t),\n  dim: (t) => wrap(codes.dim, t),\n  red: (t) => wrap(codes.red, t),\n  green: (t) => wrap(codes.green, t),\n  yellow: (t) => wrap(codes.yellow, t),\n  blue: (t) => wrap(codes.blue, t),\n  magenta: (t) => wrap(codes.magenta, t),\n  cyan: (t) => wrap(codes.cyan, t),\n  white: (t) => wrap(codes.white, t),\n  gray: (t) => wrap(codes.gray, t),\n  boldGreen: (t) => wrap(codes.bold + codes.green, t),\n  boldRed: (t) => wrap(codes.bold + codes.red, t),\n  boldYellow: (t) => wrap(codes.bold + codes.yellow, t),\n  boldCyan: (t) => wrap(codes.bold + codes.cyan, t),\n  boldMagenta: (t) => wrap(codes.bold + codes.magenta, t),\n  boldBlue: (t) => wrap(codes.bold + codes.blue, t),\n};\n\n/**\n * Color a coherency score based on its value:\n *   >= 0.8  green (excellent)\n *   >= 0.6  yellow (decent)\n *   < 0.6   red (low)\n */\nfunction colorScore(score) {\n  if (score == null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}\n\n/**\n * Color a decision (PULL/EVOLVE/GENERATE).\n */\nfunction colorDecision(decision) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}\n\n/**\n * Color an accepted/rejected status.\n */\nfunction colorStatus(accepted) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}\n\n/**\n * Color a diff line.\n */\nfunction colorDiff(type, line) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}\n\n/**\n * Color a source tag (PAT/HIS).\n */\nfunction colorSource(source) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}\n\nmodule.exports = { c, colorScore, colorDecision, colorStatus, colorDiff, colorSource, enabled };\n",
      "language": "javascript",
      "description": "Harvested from . — src/cli/colors.js (12 functions)",
      "tags": [
        "enabled",
        "codes",
        "wrap",
        "c",
        "colorScore",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "20262b5ea1bdc2aa",
      "name": "big-ts",
      "code": "function big() {\\n${code}\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "big",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "015300c09eb11eba",
      "name": "clean-ts",
      "code": "function clean(s: any) {\\n  return s.replace(/[^a-z]/g, \"\");\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "clean",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "1915d546daeb5d38",
      "name": "init-ts",
      "code": "function init(options: Record<string, any>) {\\n  return options;\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "init",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "0b9313106bd548c4",
      "name": "analyticsTest-ts",
      "code": "function analyticsTest(data: any[]) {\\n  return data.map(x => x * 2).filter(x => x > 5);\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "analyticsTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "227693c382b8beca",
      "name": "distTest-ts",
      "code": "function distTest(arr: any) {\\n  return arr.sort((a, b) => a - b);\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "distTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "d1582b351cc97be6",
      "name": "langTest-ts",
      "code": "function langTest(s: any) {\\n  return s.toUpperCase();\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "langTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "850196a677f84814",
      "name": "healthTest-ts",
      "code": "function healthTest(n: any) {\\n  return n > 0 ? \"positive\" : \"negative\";\\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/upgrades.test.js (TypeScript variant)",
      "tags": [
        "healthTest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "43114fc48d4a2322",
      "name": "getInput-ts",
      "code": "function getInput(name: string) {\n  const envVar = `INPUT_${name.replace(/-/g, '_').toUpperCase()}`;\n  return process.env[envVar] || '';\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/action.js (TypeScript variant)",
      "tags": [
        "getInput",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "78e7abd1ea87ca1a",
      "name": "setOutput-ts",
      "code": "function setOutput(name: string, value: any) {\n  const filePath = process.env.GITHUB_OUTPUT;\n  if (filePath) {\n    fs.appendFileSync(filePath, `${name}=${typeof value === 'object' ? JSON.stringify(value) : value}\\n`);\n  }\n  console.log(`::set-output name=${name}::${typeof value === 'object' ? JSON.stringify(value) : value}`);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/action.js (TypeScript variant)",
      "tags": [
        "setOutput",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "b062a55a98122685",
      "name": "wrapWithTracking-ts",
      "code": "function wrapWithTracking(oracle: any) {\n  const reporter = new CIFeedbackReporter(oracle);\n\n  const origResolve = oracle.resolve.bind(oracle);\n  oracle.resolve = function (request) {\n    const result = origResolve(request);\n    if (result.pattern && result.decision === 'pull') {\n      reporter.trackPull({ id: result.pattern.id, name: result.pattern.name, source: 'pattern' });\n    }\n    return result;\n  };\n\n  const origQuery = oracle.query.bind(oracle);\n  oracle.query = function (query) {\n    const results = origQuery(query);\n    for (const r of results.slice(0, 1)) { // Track only the top result\n      reporter.trackPull({ id: r.id, name: r.description, source: 'history' });\n    }\n    return results;\n  };\n\n  oracle._feedbackReporter = reporter;\n  return reporter;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/ci/feedback.js (TypeScript variant)",
      "tags": [
        "wrapWithTracking",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "69b40393930a3ccb",
      "name": "wrap-ts",
      "code": "function wrap(code: any, text: string) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "wrap",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "612c83d86672937f",
      "name": "colorScore-ts",
      "code": "function colorScore(score: any) {\n  if (score == null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "colorScore",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "96a398cef7562c16",
      "name": "colorDecision-ts",
      "code": "function colorDecision(decision: any) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "colorDecision",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "e67d9566dc5e9d9c",
      "name": "colorStatus-ts",
      "code": "function colorStatus(accepted: any) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "colorStatus",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "e5f6013fc9edfcb5",
      "name": "colorDiff-ts",
      "code": "function colorDiff(type: any, line: any) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "colorDiff",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "d3e69fa72bcd26cd",
      "name": "colorSource-ts",
      "code": "function colorSource(source: any) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli/colors.js (TypeScript variant)",
      "tags": [
        "colorSource",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "3be8832a0fd856a3",
      "name": "parseArgs-ts",
      "code": "function parseArgs(args: any[]) {\n  const parsed = { _command: args[0] };\n  for (let i = 1; i < args.length; i++) {\n    if (args[i].startsWith('--')) {\n      const key = args[i].slice(2);\n      const val = args[i + 1] && !args[i + 1].startsWith('--') ? args[i + 1] : true;\n      parsed[key] = val;\n      if (val !== true) i++;\n    }\n  }\n  return parsed;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli.js (TypeScript variant)",
      "tags": [
        "parseArgs",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "72c456b69464262b",
      "name": "getCode-ts",
      "code": "function getCode(args: any) {\n  if (args.file) return fs.readFileSync(path.resolve(args.file), 'utf-8');\n  const stdin = readStdin();\n  if (stdin.trim()) return stdin;\n  return null;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/cli.js (TypeScript variant)",
      "tags": [
        "getCode",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "37bc8d7eda2df8fb",
      "name": "camelCase-ts",
      "code": "function camelCase(str: string) {\n  return str.replace(/[-_\\\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')\n            .replace(/^[A-Z]/, c => c.toLowerCase());\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "camelCase",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "1dbc30e20c27fec4",
      "name": "snakeCase-ts",
      "code": "function snakeCase(str: string) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\\\s]+/g, '_').toLowerCase();\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "snakeCase",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "5060d6f786d3ac17",
      "name": "kebabCase-ts",
      "code": "function kebabCase(str: string) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\\\s]+/g, '-').toLowerCase();\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "kebabCase",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "1e6a149cbf93bf16",
      "name": "wordCount-ts",
      "code": "function wordCount(str: string) {\n  let trimmed = str.trim();\n  if (!trimmed) return 0;\n  return trimmed.split(/\\\\s+/).length;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "wordCount",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "bc0b2879338f7520",
      "name": "titleCase-ts",
      "code": "function titleCase(str: string) {\n  return str.replace(/\\\\b\\\\w/g, function(c) { return c.toUpperCase(); });\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "titleCase",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "1a341effd78f013d",
      "name": "BloomFilter-ts",
      "code": "function BloomFilter(size: number) {\n  this.size = size || 256;\n  this.bits = new Uint8Array(this.size);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "BloomFilter",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "406c776bfcd29cf0",
      "name": "curried-ts",
      "code": "function curried() {\n    let args = Array.prototype.slice.call(arguments);\n    if (args.length >= fn.length) return fn.apply(this, args);\n    return function() {\n      return curried.apply(this, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "curried",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "6353d92e39414912",
      "name": "luhnCheck-ts",
      "code": "function luhnCheck(num: number) {\n  let str = String(num).replace(/\\\\D/g, '');\n  let sum = 0, alt = false;\n  for (let i = str.length - 1; i >= 0; i--) {\n    let n = parseInt(str[i], 10);\n    if (alt) { n *= 2; if (n > 9) n -= 9; }\n    sum += n;\n    alt = !alt;\n  }\n  return sum % 10 === 0;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "luhnCheck",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "700196518d9ca13a",
      "name": "validateEmail-ts",
      "code": "function validateEmail(email: any[]) {\n  if (typeof email !== 'string') return false;\n  const re = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n  return re.test(email) && email.length <= 254;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "validateEmail",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "11acc533dcea311e",
      "name": "seedLibrary-ts",
      "code": "function seedLibrary(oracle: any) {\n  const existing = oracle.patterns.getAll();\n  const existingNames = new Set(existing.map(p => p.name));\n\n  let registered = 0, skipped = 0, failed = 0;\n\n  for (const seed of SEEDS) {\n    if (existingNames.has(seed.name)) {\n      skipped++;\n      continue;\n    }\n\n    const result = oracle.registerPattern(seed);\n    if (result.registered) {\n      registered++;\n    } else {\n      failed++;\n      console.log(`  [FAIL] ${seed.name}: ${result.reason}`);\n    }\n  }\n\n  return { registered, skipped, failed, total: SEEDS.length };\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "seedLibrary",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "2ca833e40016b58c",
      "name": "mergeSort-ts",
      "code": "function mergeSort(arr: any[]) { if (arr.length <= 1) return arr; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/embeddings.test.js (TypeScript variant)",
      "tags": [
        "mergeSort",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "9d1c44a314c17248",
      "name": "bsearch-ts",
      "code": "function bsearch(arr: any[], t: any) { let lo = 0, hi = arr.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; if (arr[mid] === t) return mid; arr[mid] < t ? lo = mid + 1 : hi = mid - 1; } return -1; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/embeddings.test.js (TypeScript variant)",
      "tags": [
        "bsearch",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "3edd4f18b518d8e6",
      "name": "sortArray-ts",
      "code": "function sortArray(arr: any) { return arr.sort((a, b) => a - b); }",
      "language": "typescript",
      "description": "Harvested function from . — tests/oracle.test.js (TypeScript variant)",
      "tags": [
        "sortArray",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "d4180cca12c9858a",
      "name": "reverseString-ts",
      "code": "function reverseString(s: string) { return s.split(\"\").reverse().join(\"\"); }",
      "language": "typescript",
      "description": "Harvested function from . — tests/oracle.test.js (TypeScript variant)",
      "tags": [
        "reverseString",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "fc1533cc8ac62d97",
      "name": "quickSort-ts",
      "code": "function quickSort(arr: any) { return arr.sort(); }",
      "language": "typescript",
      "description": "Harvested function from . — tests/patterns.test.js (TypeScript variant)",
      "tags": [
        "quickSort",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "0c62ad27dc8d350b",
      "name": "fib-ts",
      "code": "function fib(n: any) { return fib(n-1) + fib(n-2); }",
      "language": "typescript",
      "description": "Harvested function from . — tests/recycler.test.js (TypeScript variant)",
      "tags": [
        "fib",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "ecdf57c622c5adef",
      "name": "calculateTotal-ts",
      "code": "function calculateTotal(items: any[]) {\n  let total = 0;\n  for (let i = 0; i < items.length; i++) {\n    total += items[i].price;\n  }\n  return total;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "calculateTotal",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "5845e97c859d4571",
      "name": "multiply-ts",
      "code": "function multiply(a: any, b: any) { return a * b; }",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "multiply",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "28277d609d2cf659",
      "name": "greet-ts",
      "code": "function greet(name: string) {\n  return 'Hello ' + name;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "greet",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "cb0c247966626b54",
      "name": "farewell-ts",
      "code": "function farewell(name: string) {\n  return 'Bye ' + name;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "farewell",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.85
    },
    {
      "id": "df19c4ae138d7e3d",
      "name": "buildUpgradeRequest-ts",
      "code": "function buildUpgradeRequest(key: any, path: string) {\n  return (\n    `GET ${path} HTTP/1.1\\r\\n` +\n    `Host: localhost\\r\\n` +\n    `Upgrade: websocket\\r\\n` +\n    `Connection: Upgrade\\r\\n` +\n    `Sec-WebSocket-Key: ${key}\\r\\n` +\n    `Sec-WebSocket-Version: 13\\r\\n` +\n    `\\r\\n`\n  );\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "buildUpgradeRequest",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "454d3323d598a9fd",
      "name": "encodeTextFrame-ts",
      "code": "function encodeTextFrame(text: string) {\n  const payload = Buffer.from(text, 'utf8');\n  const mask = crypto.randomBytes(4);\n  const masked = Buffer.from(payload);\n  for (let i = 0; i < masked.length; i++) {\n    masked[i] ^= mask[i & 3];\n  }\n\n  let header;\n  if (payload.length < 126) {\n    header = Buffer.allocUnsafe(2);\n    header[0] = 0x81; // FIN + text opcode\n    header[1] = 0x80 | payload.length; // masked bit + length\n  } else {\n    header = Buffer.allocUnsafe(4);\n    header[0] = 0x81;\n    header[1] = 0x80 | 126;\n    header.writeUInt16BE(payload.length, 2);\n  }\n\n  return Buffer.concat([header, mask, masked]);\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "encodeTextFrame",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "bf17fdd5823312bf",
      "name": "f",
      "code": "function f(){if(a){if(b){if(c){/* TODO */}}}}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "5d34bb5cca62d3a0",
      "name": "lru-cache-rs",
      "code": "use std::collections::HashMap;\n\nstruct LruCache<K: std::hash::Hash + Eq + Clone, V> {\n    capacity: usize,\n    map: HashMap<K, (V, usize)>,\n    counter: usize,\n}\n\nimpl<K: std::hash::Hash + Eq + Clone, V> LruCache<K, V> {\n    fn new(capacity: usize) -> Self {\n        LruCache { capacity, map: HashMap::new(), counter: 0 }\n    }\n\n    fn get(&mut self, key: &K) -> Option<&V> {\n        if let Some(entry) = self.map.get_mut(key) {\n            self.counter += 1;\n            entry.1 = self.counter;\n            Some(&entry.0)\n        } else {\n            None\n        }\n    }\n\n    fn put(&mut self, key: K, value: V) {\n        self.counter += 1;\n        if self.map.contains_key(&key) {\n            self.map.insert(key, (value, self.counter));\n            return;\n        }\n        if self.map.len() >= self.capacity {\n            let lru_key = self.map.iter()\n                .min_by_key(|(_, (_, ts))| *ts)\n                .map(|(k, _)| k.clone())\n                .unwrap();\n            self.map.remove(&lru_key);\n        }\n        self.map.insert(key, (value, self.counter));\n    }\n}",
      "language": "rust",
      "description": "Generic LRU cache with HashMap — evicts least recently used",
      "tags": [
        "data-structure",
        "cache",
        "lru",
        "hashmap",
        "eviction",
        "generic"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "1d4ff774cc4b919c",
      "name": "retry-rs",
      "code": "use std::thread;\nuse std::time::Duration;\n\nfn retry<F, T, E>(attempts: u32, initial_delay: Duration, mut f: F) -> Result<T, E>\nwhere\n    F: FnMut() -> Result<T, E>,\n{\n    let mut delay = initial_delay;\n    for i in 0..attempts {\n        match f() {\n            Ok(val) => return Ok(val),\n            Err(e) => {\n                if i == attempts - 1 { return Err(e); }\n                thread::sleep(delay);\n                delay *= 2;\n            }\n        }\n    }\n    unreachable!()\n}",
      "language": "rust",
      "description": "Generic retry with exponential backoff — works with any Result<T, E>",
      "tags": [
        "utility",
        "async",
        "retry",
        "backoff",
        "error-handling",
        "generic"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.85
    },
    {
      "id": "cbddee203e130f1a",
      "name": "binary-search-rs",
      "code": "fn binary_search(arr: &[i32], target: i32) -> Option<usize> {\n    let (mut lo, mut hi) = (0usize, arr.len());\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        match arr[mid].cmp(&target) {\n            std::cmp::Ordering::Equal => return Some(mid),\n            std::cmp::Ordering::Less => lo = mid + 1,\n            std::cmp::Ordering::Greater => hi = mid,\n        }\n    }\n    None\n}",
      "language": "rust",
      "description": "Binary search returning Option<usize> — idiomatic Rust",
      "tags": [
        "search",
        "algorithm",
        "slice",
        "sorted",
        "binary-search"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "111dfbbcfc3b9cb6",
      "name": "retry-go",
      "code": "func Retry(attempts int, delay time.Duration, fn func() error) error {\n\tvar err error\n\tfor i := 0; i < attempts; i++ {\n\t\terr = fn()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif i < attempts-1 {\n\t\t\ttime.Sleep(delay)\n\t\t\tdelay *= 2\n\t\t}\n\t}\n\treturn fmt.Errorf(\"failed after %d attempts: %w\", attempts, err)\n}",
      "language": "go",
      "description": "Retry with exponential backoff — robust error recovery",
      "tags": [
        "utility",
        "async",
        "retry",
        "backoff",
        "error-handling"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "5030605388b436e9",
      "name": "binary-search-go",
      "code": "func BinarySearch(arr []int, target int) int {\n\tlo, hi := 0, len(arr)-1\n\tfor lo <= hi {\n\t\tmid := lo + (hi-lo)/2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tlo = mid + 1\n\t\t} else {\n\t\t\thi = mid - 1\n\t\t}\n\t}\n\treturn -1\n}",
      "language": "go",
      "description": "Binary search on sorted slice — O(log n)",
      "tags": [
        "search",
        "algorithm",
        "slice",
        "sorted",
        "binary-search"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.85
    },
    {
      "id": "e8d3ad437c76ea33",
      "name": "colors-refined-ts",
      "code": "/**\n * Zero-dependency ANSI color helpers for CLI output.\n *\n * Colors are automatically disabled when:\n * - stdout is not a TTY (piped/redirected)\n * - NO_COLOR env let is set (https://no-color.org)\n * - --no-color flag is passed\n */\n\nconst enabled = process.stdout.isTTY && !process.env.NO_COLOR && !process.argv.includes('--no-color');\n\nconst codes = {\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underline: '\\x1b[4m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n  gray: '\\x1b[90m',\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n  bgBlue: '\\x1b[44m',\n};\n\nfunction wrap(code: any, text: string) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}\n\nconst c = {\n  bold: (t) => wrap(codes.bold, t),\n  dim: (t) => wrap(codes.dim, t),\n  red: (t) => wrap(codes.red, t),\n  green: (t) => wrap(codes.green, t),\n  yellow: (t) => wrap(codes.yellow, t),\n  blue: (t) => wrap(codes.blue, t),\n  magenta: (t) => wrap(codes.magenta, t),\n  cyan: (t) => wrap(codes.cyan, t),\n  white: (t) => wrap(codes.white, t),\n  gray: (t) => wrap(codes.gray, t),\n  boldGreen: (t) => wrap(codes.bold + codes.green, t),\n  boldRed: (t) => wrap(codes.bold + codes.red, t),\n  boldYellow: (t) => wrap(codes.bold + codes.yellow, t),\n  boldCyan: (t) => wrap(codes.bold + codes.cyan, t),\n  boldMagenta: (t) => wrap(codes.bold + codes.magenta, t),\n  boldBlue: (t) => wrap(codes.bold + codes.blue, t),\n};\n\n/**\n * Color a coherency score based on its value:\n *   >= 0.8  green (excellent)\n *   >= 0.6  yellow (decent)\n *   < 0.6   red (low)\n */\nfunction colorScore(score) {\n  if (score === null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}\n\n/**\n * Color a decision (PULL/EVOLVE/GENERATE).\n */\nfunction colorDecision(decision) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}\n\n/**\n * Color an accepted/rejected status.\n */\nfunction colorStatus(accepted) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}\n\n/**\n * Color a diff line.\n */\nfunction colorDiff(type, line) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}\n\n/**\n * Color a source tag (PAT/HIS).\n */\nfunction colorSource(source) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}\n\nmodule.exports = { c, colorScore, colorDecision, colorStatus, colorDiff, colorSource, enabled };\n",
      "testCode": "if (wrap(1, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(0, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(\"\", \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \" \") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"a\") === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested from . — src/cli/colors.js (12 functions) (refined) (TypeScript variant)",
      "tags": [
        "enabled",
        "codes",
        "wrap",
        "c",
        "colorScore",
        "javascript",
        "harvested",
        "auto-refined",
        "auto-generated",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.845
    },
    {
      "id": "1400131de710477d",
      "name": "colors-ts",
      "code": "/**\n * Zero-dependency ANSI color helpers for CLI output.\n *\n * Colors are automatically disabled when:\n * - stdout is not a TTY (piped/redirected)\n * - NO_COLOR env let is set (https://no-color.org)\n * - --no-color flag is passed\n */\n\nconst enabled = process.stdout.isTTY && !process.env.NO_COLOR && !process.argv.includes('--no-color');\n\nconst codes = {\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underline: '\\x1b[4m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n  gray: '\\x1b[90m',\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n  bgBlue: '\\x1b[44m',\n};\n\nfunction wrap(code: any, text: string) {\n  if (!enabled) return text;\n  return `${code}${text}${codes.reset}`;\n}\n\nconst c = {\n  bold: (t) => wrap(codes.bold, t),\n  dim: (t) => wrap(codes.dim, t),\n  red: (t) => wrap(codes.red, t),\n  green: (t) => wrap(codes.green, t),\n  yellow: (t) => wrap(codes.yellow, t),\n  blue: (t) => wrap(codes.blue, t),\n  magenta: (t) => wrap(codes.magenta, t),\n  cyan: (t) => wrap(codes.cyan, t),\n  white: (t) => wrap(codes.white, t),\n  gray: (t) => wrap(codes.gray, t),\n  boldGreen: (t) => wrap(codes.bold + codes.green, t),\n  boldRed: (t) => wrap(codes.bold + codes.red, t),\n  boldYellow: (t) => wrap(codes.bold + codes.yellow, t),\n  boldCyan: (t) => wrap(codes.bold + codes.cyan, t),\n  boldMagenta: (t) => wrap(codes.bold + codes.magenta, t),\n  boldBlue: (t) => wrap(codes.bold + codes.blue, t),\n};\n\n/**\n * Color a coherency score based on its value:\n *   >= 0.8  green (excellent)\n *   >= 0.6  yellow (decent)\n *   < 0.6   red (low)\n */\nfunction colorScore(score) {\n  if (score == null || score === '?') return c.gray('?');\n  const num = typeof score === 'string' ? parseFloat(score) : score;\n  if (isNaN(num)) return c.gray(String(score));\n  const text = typeof score === 'number' ? score.toFixed(3) : String(score);\n  if (num >= 0.8) return c.boldGreen(text);\n  if (num >= 0.6) return c.boldYellow(text);\n  return c.boldRed(text);\n}\n\n/**\n * Color a decision (PULL/EVOLVE/GENERATE).\n */\nfunction colorDecision(decision) {\n  const upper = decision.toUpperCase();\n  if (upper === 'PULL') return c.boldGreen(upper);\n  if (upper === 'EVOLVE') return c.boldYellow(upper);\n  if (upper === 'GENERATE') return c.boldMagenta(upper);\n  return c.bold(upper);\n}\n\n/**\n * Color an accepted/rejected status.\n */\nfunction colorStatus(accepted) {\n  return accepted ? c.boldGreen('Accepted') : c.boldRed('Rejected');\n}\n\n/**\n * Color a diff line.\n */\nfunction colorDiff(type, line) {\n  if (type === 'added') return c.green(`+ ${line}`);\n  if (type === 'removed') return c.red(`- ${line}`);\n  return c.gray(`  ${line}`);\n}\n\n/**\n * Color a source tag (PAT/HIS).\n */\nfunction colorSource(source) {\n  return source === 'pattern' ? c.cyan('PAT') : c.blue('HIS');\n}\n\nmodule.exports = { c, colorScore, colorDecision, colorStatus, colorDiff, colorSource, enabled };\n",
      "testCode": "if (wrap(1, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(0, \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(\"\", \"hello\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"\") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \" \") === undefined) throw new Error(\"returned undefined\");\nif (wrap(1, \"a\") === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested from . — src/cli/colors.js (12 functions) (TypeScript variant)",
      "tags": [
        "enabled",
        "codes",
        "wrap",
        "c",
        "colorScore",
        "javascript",
        "harvested",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.845
    },
    {
      "id": "d1b8b43d158e7266",
      "name": "save_data",
      "code": "function save_data() {}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "save_data",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.84
    },
    {
      "id": "155ec399d6c39563",
      "name": "process_data",
      "code": "function process_data() {}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "process_data",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.84
    },
    {
      "id": "ac977c087f5f1382",
      "name": "saveData",
      "code": "function saveData() {}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "saveData",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.84
    },
    {
      "id": "cc33cd90d0420b51",
      "name": "processData",
      "code": "function processData() {}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "processData",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.84
    },
    {
      "id": "401a7c0f84dc1c35",
      "name": "captureKeys",
      "code": "function captureKeys() {}",
      "language": "javascript",
      "description": "Harvested function from . — tests/covenant.test.js",
      "tags": [
        "captureKeys",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.84
    },
    {
      "id": "60ce783ec7637937",
      "name": "groupBy",
      "code": "function groupBy(arr, keyFn) {\n  const groups = {};\n  for (const item of arr) {\n    const key = typeof keyFn === 'function' ? keyFn(item) : item[keyFn];\n    (groups[key] = groups[key] || []).push(item);\n  }\n  return groups;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "groupBy",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "2abd9eaad3e005c3",
      "name": "deepClone",
      "code": "function deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) {\n    cloned[key] = deepClone(obj[key]);\n  }\n  return cloned;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "deepClone",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "b1ca17ea9ba7b6e4",
      "name": "parseCookie",
      "code": "function parseCookie(str) {\n  if (!str) return {};\n  return str.split(';').reduce(function(obj, pair) {\n    var parts = pair.trim().split('=');\n    var key = parts[0].trim();\n    obj[key] = parts.slice(1).join('=').trim();\n    return obj;\n  }, {});\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "parseCookie",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "b626c3c9379d92a4",
      "name": "renameKeys",
      "code": "function renameKeys(obj, keyMap) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    var newKey = keyMap[keys[i]] || keys[i];\n    result[newKey] = obj[keys[i]];\n  }\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "renameKeys",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "183d5f9e53165129",
      "name": "mapKeys",
      "code": "function mapKeys(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[fn(keys[i], obj[keys[i]])] = obj[keys[i]];\n  }\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "mapKeys",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "afcfd1a8adbaad29",
      "name": "mapValues",
      "code": "function mapValues(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = fn(obj[keys[i]], keys[i]);\n  }\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "mapValues",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "857b01b21f3a4daa",
      "name": "deepMerge",
      "code": "function deepMerge(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        target[key] = deepMerge(target[key] || {}, source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "deepMerge",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "1b96117c7348b6d6",
      "name": "mcp.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { MCPServer, TOOLS } = require('../src/mcp/server');\n\ndescribe('MCPServer', () => {\n  let server;\n\n  it('initializes', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 1, method: 'initialize' });\n    assert.equal(res.jsonrpc, '2.0');\n    assert.equal(res.id, 1);\n    assert.ok(res.result.protocolVersion);\n    assert.ok(res.result.serverInfo.name);\n  });\n\n  it('responds to ping', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 2, method: 'ping' });\n    assert.equal(res.id, 2);\n    assert.ok(res.result);\n  });\n\n  it('lists tools', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 3, method: 'tools/list' });\n    assert.ok(res.result.tools.length > 0);\n    const names = res.result.tools.map(t => t.name);\n    assert.ok(names.includes('oracle_search'));\n    assert.ok(names.includes('oracle_stats'));\n  });\n\n  it('tools have valid schemas', () => {\n    for (const tool of TOOLS) {\n      assert.ok(tool.name, 'tool must have name');\n      assert.ok(tool.description, `${tool.name} must have description`);\n      assert.ok(tool.inputSchema, `${tool.name} must have inputSchema`);\n      assert.equal(tool.inputSchema.type, 'object');\n    }\n  });\n\n  it('handles oracle_stats', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 4,\n      method: 'tools/call',\n      params: { name: 'oracle_stats', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    assert.equal(res.result.content[0].type, 'text');\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('store' in data);\n    assert.ok('patterns' in data);\n  });\n\n  it('handles oracle_search', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 5,\n      method: 'tools/call',\n      params: { name: 'oracle_search', arguments: { query: 'sort' } },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(Array.isArray(data));\n  });\n\n  it('handles oracle_submit', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 6,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_submit',\n        arguments: {\n          code: 'function add(a, b) { return a + b; }',\n          language: 'javascript',\n          description: 'Add two numbers',\n          tags: ['math'],\n        },\n      },\n    });\n    assert.ok(res.result.content);\n  });\n\n  it('handles oracle_nearest', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 7,\n      method: 'tools/call',\n      params: { name: 'oracle_nearest', arguments: { query: 'cache', limit: 3 } },\n    });\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(Array.isArray(data));\n    assert.ok(data.length <= 3);\n  });\n\n  it('handles unknown tool', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 8,\n      method: 'tools/call',\n      params: { name: 'nonexistent_tool', arguments: {} },\n    });\n    assert.ok(res.result.isError);\n  });\n\n  it('handles unknown method', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 9, method: 'unknown/method' });\n    assert.ok(res.error);\n    assert.equal(res.error.code, -32601);\n  });\n\n  it('handles notifications silently', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ method: 'notifications/initialized' });\n    assert.equal(res, null);\n  });\n\n  it('handles oracle_resolve', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 10,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_resolve',\n        arguments: { description: 'sort an array', tags: ['sort'] },\n      },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(data.decision);\n  });\n\n  it('handles oracle_candidates', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 11,\n      method: 'tools/call',\n      params: { name: 'oracle_candidates', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('stats' in data);\n    assert.ok('candidates' in data);\n    assert.ok(Array.isArray(data.candidates));\n  });\n\n  it('handles oracle_generate', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 12,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_generate',\n        arguments: { languages: ['typescript'], methods: ['variant'], maxPatterns: 2 },\n      },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('generated' in data);\n    assert.ok('stored' in data);\n  });\n\n  it('handles oracle_auto_promote', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 13,\n      method: 'tools/call',\n      params: { name: 'oracle_auto_promote', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('attempted' in data);\n    assert.ok('promoted' in data);\n  });\n\n  it('handles oracle_promote with missing candidate', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 14,\n      method: 'tools/call',\n      params: { name: 'oracle_promote', arguments: { candidateId: 'nonexistent' } },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.equal(data.promoted, false);\n  });\n\n  it('lists all tools including candidate and community tools', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 15, method: 'tools/list' });\n    const names = res.result.tools.map(t => t.name);\n    assert.ok(names.includes('oracle_candidates'));\n    assert.ok(names.includes('oracle_generate'));\n    assert.ok(names.includes('oracle_promote'));\n    assert.ok(names.includes('oracle_auto_promote'));\n    assert.ok(names.includes('oracle_share'));\n    assert.ok(names.includes('oracle_community'));\n    assert.ok(names.includes('oracle_debug_capture'));\n    assert.ok(names.includes('oracle_debug_search'));\n    assert.ok(names.includes('oracle_debug_feedback'));\n    assert.ok(names.includes('oracle_debug_grow'));\n    assert.ok(names.includes('oracle_debug_stats'));\n    assert.ok(names.includes('oracle_debug_share'));\n    assert.ok(names.includes('oracle_smart_search'));\n    assert.ok(names.includes('oracle_llm_status'));\n    assert.ok(names.includes('oracle_llm_transpile'));\n    assert.ok(names.includes('oracle_llm_analyze'));\n    assert.equal(res.result.tools.length, 36);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/mcp.test.js (5 functions)",
      "tags": [
        "assert",
        "res",
        "names",
        "data",
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "b6de372b69406f1b",
      "name": "connectors.test",
      "code": "const { describe, it, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst { AIConnector } = require('../src/connectors/connector');\nconst {\n  OPENAI_TOOLS, ANTHROPIC_TOOLS, GEMINI_TOOLS, MCP_TOOLS,\n  fromOpenAI, toOpenAI,\n  fromAnthropic, toAnthropic,\n  fromGemini, toGemini,\n  fromMCP, toMCP,\n} = require('../src/connectors/providers');\nconst {\n  parseIssueCommand,\n  parseNaturalLanguage,\n  formatAsComment,\n} = require('../src/connectors/github-bridge');\n\ndescribe('AIConnector', () => {\n  let tmpDir;\n  let connector;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'connector-test-'));\n    connector = new AIConnector({ baseDir: tmpDir, provider: 'test', modelId: 'test-model' });\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  it('executes submit command', () => {\n    const result = connector.execute({\n      action: 'submit',\n      params: {\n        code: 'function add(a, b) { return a + b; }',\n        language: 'javascript',\n        description: 'Add numbers',\n        tags: ['math'],\n      },\n    });\n    assert.equal(result.action, 'submit');\n    assert.equal(result.accepted, true);\n    assert.ok(result.id);\n    assert.ok(result.coherencyScore > 0);\n  });\n\n  it('executes query command', () => {\n    connector.execute({\n      action: 'submit',\n      params: { code: 'function add(a, b) { return a + b; }', tags: ['math'] },\n    });\n    const result = connector.execute({\n      action: 'query',\n      params: { description: 'math', tags: ['math'] },\n    });\n    assert.equal(result.action, 'query');\n    assert.ok(result.count >= 1);\n    assert.ok(result.results[0].code.includes('add'));\n  });\n\n  it('executes stats command', () => {\n    const result = connector.execute({ action: 'stats', params: {} });\n    assert.equal(result.action, 'stats');\n    assert.ok('totalEntries' in result);\n  });\n\n  it('executes feedback command', () => {\n    const { id } = connector.execute({\n      action: 'submit',\n      params: { code: 'function x() { return 1; }', tags: ['test'] },\n    });\n    const result = connector.execute({\n      action: 'feedback',\n      params: { id, succeeded: true },\n    });\n    assert.equal(result.action, 'feedback');\n    assert.equal(result.success, true);\n  });\n\n  it('returns error for unknown action', () => {\n    const result = connector.execute({ action: 'nonexistent' });\n    assert.ok(result.error);\n    assert.ok(result.availableActions.includes('query'));\n  });\n});\n\ndescribe('Provider: OpenAI', () => {\n  it('has tool definitions', () => {\n    assert.ok(OPENAI_TOOLS.length >= 4);\n    assert.equal(OPENAI_TOOLS[0].type, 'function');\n    assert.equal(OPENAI_TOOLS[0].function.name, 'oracle_submit');\n  });\n\n  it('translates from OpenAI format', () => {\n    const cmd = fromOpenAI({\n      function: {\n        name: 'oracle_query',\n        arguments: JSON.stringify({ description: 'sorting', language: 'javascript' }),\n      },\n    });\n    assert.equal(cmd.action, 'query');\n    assert.equal(cmd.params.description, 'sorting');\n  });\n\n  it('translates to OpenAI format', () => {\n    const msg = toOpenAI({ action: 'query', count: 1 }, 'call_123');\n    assert.equal(msg.role, 'tool');\n    assert.equal(msg.tool_call_id, 'call_123');\n    assert.ok(msg.content.includes('query'));\n  });\n});\n\ndescribe('Provider: Anthropic', () => {\n  it('has tool definitions', () => {\n    assert.ok(ANTHROPIC_TOOLS.length >= 4);\n    assert.equal(ANTHROPIC_TOOLS[0].name, 'oracle_submit');\n    assert.ok(ANTHROPIC_TOOLS[0].input_schema);\n  });\n\n  it('translates from Anthropic format', () => {\n    const cmd = fromAnthropic({ name: 'oracle_submit', input: { code: 'x = 1' } });\n    assert.equal(cmd.action, 'submit');\n    assert.equal(cmd.params.code, 'x = 1');\n  });\n\n  it('translates to Anthropic format', () => {\n    const msg = toAnthropic({ action: 'submit', accepted: true }, 'tu_456');\n    assert.equal(msg.type, 'tool_result');\n    assert.equal(msg.tool_use_id, 'tu_456');\n  });\n});\n\ndescribe('Provider: Gemini', () => {\n  it('has tool definitions', () => {\n    assert.ok(GEMINI_TOOLS[0].functionDeclarations.length >= 4);\n  });\n\n  it('translates from Gemini format', () => {\n    const cmd = fromGemini({ name: 'oracle_stats', args: {} });\n    assert.equal(cmd.action, 'stats');\n  });\n\n  it('translates to Gemini format', () => {\n    const msg = toGemini({ action: 'stats', totalEntries: 5 });\n    assert.ok(msg.functionResponse);\n    assert.equal(msg.functionResponse.response.totalEntries, 5);\n  });\n});\n\ndescribe('Provider: MCP', () => {\n  it('has tool definitions', () => {\n    assert.ok(MCP_TOOLS.length >= 4);\n    assert.ok(MCP_TOOLS[0].inputSchema);\n  });\n\n  it('translates from MCP format', () => {\n    const cmd = fromMCP({ name: 'oracle_query', arguments: { description: 'test' } });\n    assert.equal(cmd.action, 'query');\n  });\n\n  it('translates to MCP format', () => {\n    const msg = toMCP({ action: 'query', count: 0, results: [] });\n    assert.ok(msg.content[0].type === 'text');\n  });\n});\n\ndescribe('GitHub Bridge', () => {\n  it('parses JSON code block from issue body', () => {\n    const body = 'Hello\\n```json\\n{\"action\":\"query\",\"params\":{\"description\":\"sorting\"}}\\n```\\nThanks';\n    const cmd = parseIssueCommand(body);\n    assert.equal(cmd.action, 'query');\n    assert.equal(cmd.params.description, 'sorting');\n  });\n\n  it('parses raw JSON from issue body', () => {\n    const body = '{\"action\":\"stats\"}';\n    const cmd = parseIssueCommand(body);\n    assert.equal(cmd.action, 'stats');\n  });\n\n  it('parses natural language query', () => {\n    const cmd = parseNaturalLanguage('I need a sorting algorithm in javascript');\n    assert.equal(cmd.action, 'query');\n    assert.equal(cmd.params.language, 'javascript');\n  });\n\n  it('parses natural language stats', () => {\n    const cmd = parseNaturalLanguage('show me the stats');\n    assert.equal(cmd.action, 'stats');\n  });\n\n  it('formats query result as markdown comment', () => {\n    const comment = formatAsComment({\n      action: 'query',\n      count: 1,\n      results: [{\n        id: 'abc123',\n        code: 'function sort() {}',\n        language: 'javascript',\n        description: 'Sort function',\n        coherencyScore: 0.85,\n        relevanceScore: 0.9,\n        tags: ['sort'],\n      }],\n    });\n    assert.ok(comment.includes('## Oracle Response'));\n    assert.ok(comment.includes('Sort function'));\n    assert.ok(comment.includes('function sort()'));\n    assert.ok(comment.includes('0.85'));\n  });\n\n  it('formats stats as markdown table', () => {\n    const comment = formatAsComment({\n      action: 'stats',\n      totalEntries: 42,\n      languages: ['javascript', 'python'],\n      avgCoherency: 0.78,\n    });\n    assert.ok(comment.includes('42'));\n    assert.ok(comment.includes('javascript'));\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/connectors.test.js (12 functions)",
      "tags": [
        "assert",
        "fs",
        "path",
        "os",
        "result",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "6c0148f4550ff4ca",
      "name": "auto-seed.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst { discoverPatterns, autoSeed, extractFunctionNames, extractImports, detectLanguage } = require('../src/ci/auto-seed');\n\ndescribe('detectLanguage', () => {\n  it('detects javascript', () => {\n    assert.equal(detectLanguage('foo.js'), 'javascript');\n  });\n\n  it('detects typescript', () => {\n    assert.equal(detectLanguage('bar.ts'), 'typescript');\n  });\n\n  it('detects python', () => {\n    assert.equal(detectLanguage('baz.py'), 'python');\n  });\n\n  it('detects go', () => {\n    assert.equal(detectLanguage('main.go'), 'go');\n  });\n\n  it('detects rust', () => {\n    assert.equal(detectLanguage('lib.rs'), 'rust');\n  });\n\n  it('returns null for unknown', () => {\n    assert.equal(detectLanguage('readme.md'), null);\n  });\n});\n\ndescribe('extractFunctionNames', () => {\n  it('extracts JS function declarations', () => {\n    const code = 'function add(a, b) { return a + b; }\\nfunction sub(a, b) { return a - b; }';\n    const fns = extractFunctionNames(code, 'javascript');\n    assert.ok(fns.includes('add'));\n    assert.ok(fns.includes('sub'));\n  });\n\n  it('extracts JS const arrow functions', () => {\n    const code = 'const multiply = (a, b) => a * b;';\n    const fns = extractFunctionNames(code, 'javascript');\n    assert.ok(fns.includes('multiply'));\n  });\n\n  it('extracts Python functions', () => {\n    const code = 'def hello():\\n    print(\"hello\")\\n\\ndef world():\\n    pass';\n    const fns = extractFunctionNames(code, 'python');\n    assert.ok(fns.includes('hello'));\n    assert.ok(fns.includes('world'));\n  });\n\n  it('extracts Go exported functions', () => {\n    const code = 'func Add(a, b int) int { return a + b }\\nfunc helper() {}';\n    const fns = extractFunctionNames(code, 'go');\n    assert.ok(fns.includes('Add'));\n    // helper is not exported (lowercase)\n  });\n\n  it('extracts Rust pub functions', () => {\n    const code = 'pub fn calculate(x: i32) -> i32 { x * 2 }';\n    const fns = extractFunctionNames(code, 'rust');\n    assert.ok(fns.includes('calculate'));\n  });\n\n  it('filters out test keywords', () => {\n    const code = 'function add() {}\\nfunction describe() {}';\n    const fns = extractFunctionNames(code, 'javascript');\n    assert.ok(fns.includes('add'));\n    assert.ok(!fns.includes('describe'));\n  });\n});\n\ndescribe('extractImports', () => {\n  it('extracts require statements', () => {\n    const code = \"const foo = require('./foo');\\nconst bar = require('./bar');\";\n    const imports = extractImports(code, 'javascript');\n    assert.ok(imports.includes('./foo'));\n    assert.ok(imports.includes('./bar'));\n  });\n\n  it('extracts import statements', () => {\n    const code = \"import { add } from './math';\";\n    const imports = extractImports(code, 'javascript');\n    assert.ok(imports.includes('./math'));\n  });\n\n  it('ignores non-relative imports', () => {\n    const code = \"const fs = require('fs');\\nconst foo = require('./foo');\";\n    const imports = extractImports(code, 'javascript');\n    assert.ok(!imports.includes('fs'));\n    assert.ok(imports.includes('./foo'));\n  });\n\n  it('extracts python relative imports', () => {\n    const code = 'from .module import func';\n    const imports = extractImports(code, 'python');\n    assert.ok(imports.length > 0);\n  });\n});\n\ndescribe('discoverPatterns', () => {\n  it('discovers patterns from this project', () => {\n    const baseDir = path.join(__dirname, '..');\n    const discovered = discoverPatterns(baseDir, { language: 'javascript' });\n    // Should find at least some source files with tests\n    assert.ok(Array.isArray(discovered));\n    // The project itself has test files that import source files\n    if (discovered.length > 0) {\n      const first = discovered[0];\n      assert.ok(first.sourceFile);\n      assert.ok(first.testFile);\n      assert.ok(first.language);\n      assert.ok(first.code);\n      assert.ok(Array.isArray(first.functions));\n    }\n  });\n});\n\ndescribe('autoSeed', () => {\n  it('dry run returns discovered patterns without registering', () => {\n    const { RemembranceOracle } = require('../src/api/oracle');\n    const oracle = new RemembranceOracle({ autoSeed: false });\n    const baseDir = path.join(__dirname, '..');\n    const result = autoSeed(oracle, baseDir, { dryRun: true, language: 'javascript' });\n    assert.ok(typeof result.discovered === 'number');\n    assert.ok(Array.isArray(result.patterns));\n    assert.equal(result.registered, 0);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/auto-seed.test.js (17 functions)",
      "tags": [
        "assert",
        "path",
        "declarations",
        "code",
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "1446ff19095229e7",
      "name": "quicksort",
      "code": "function quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\nmodule.exports = { quickSort };\n",
      "language": "javascript",
      "description": "Harvested from . — examples/quicksort.js (5 functions)",
      "tags": [
        "quickSort",
        "pivot",
        "left",
        "middle",
        "right",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "edf55f37ae42bd53",
      "name": "debounce",
      "code": "function debounce(fn, delay) {\n  let timer;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\nmodule.exports = { debounce };\n",
      "language": "javascript",
      "description": "Harvested from . — examples/debounce.js (1 functions)",
      "tags": [
        "debounce",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "7a926f378028e86d",
      "name": "mcp.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { MCPServer, TOOLS } = require('../src/mcp/server');\n\ndescribe('MCPServer', () => {\n  let server;\n\n  it('initializes', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 1, method: 'initialize' });\n    assert.equal(res.jsonrpc, '2.0');\n    assert.equal(res.id, 1);\n    assert.ok(res.result.protocolVersion);\n    assert.ok(res.result.serverInfo.name);\n  });\n\n  it('responds to ping', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 2, method: 'ping' });\n    assert.equal(res.id, 2);\n    assert.ok(res.result);\n  });\n\n  it('lists tools', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 3, method: 'tools/list' });\n    assert.ok(res.result.tools.length > 0);\n    const names = res.result.tools.map(t => t.name);\n    assert.ok(names.includes('oracle_search'));\n    assert.ok(names.includes('oracle_stats'));\n  });\n\n  it('tools have valid schemas', () => {\n    for (const tool of TOOLS) {\n      assert.ok(tool.name, 'tool must have name');\n      assert.ok(tool.description, `${tool.name} must have description`);\n      assert.ok(tool.inputSchema, `${tool.name} must have inputSchema`);\n      assert.equal(tool.inputSchema.type, 'object');\n    }\n  });\n\n  it('handles oracle_stats', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 4,\n      method: 'tools/call',\n      params: { name: 'oracle_stats', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    assert.equal(res.result.content[0].type, 'text');\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('store' in data);\n    assert.ok('patterns' in data);\n  });\n\n  it('handles oracle_search', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 5,\n      method: 'tools/call',\n      params: { name: 'oracle_search', arguments: { query: 'sort' } },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(Array.isArray(data));\n  });\n\n  it('handles oracle_submit', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 6,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_submit',\n        arguments: {\n          code: 'function add(a, b) { return a + b; }',\n          language: 'javascript',\n          description: 'Add two numbers',\n          tags: ['math'],\n        },\n      },\n    });\n    assert.ok(res.result.content);\n  });\n\n  it('handles oracle_nearest', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 7,\n      method: 'tools/call',\n      params: { name: 'oracle_nearest', arguments: { query: 'cache', limit: 3 } },\n    });\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(Array.isArray(data));\n    assert.ok(data.length <= 3);\n  });\n\n  it('handles unknown tool', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 8,\n      method: 'tools/call',\n      params: { name: 'nonexistent_tool', arguments: {} },\n    });\n    assert.ok(res.result.isError);\n  });\n\n  it('handles unknown method', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 9, method: 'unknown/method' });\n    assert.ok(res.error);\n    assert.equal(res.error.code, -32601);\n  });\n\n  it('handles notifications silently', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ method: 'notifications/initialized' });\n    assert.equal(res, null);\n  });\n\n  it('handles oracle_resolve', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 10,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_resolve',\n        arguments: { description: 'sort an array', tags: ['sort'] },\n      },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok(data.decision);\n  });\n\n  it('handles oracle_candidates', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 11,\n      method: 'tools/call',\n      params: { name: 'oracle_candidates', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('stats' in data);\n    assert.ok('candidates' in data);\n    assert.ok(Array.isArray(data.candidates));\n  });\n\n  it('handles oracle_generate', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 12,\n      method: 'tools/call',\n      params: {\n        name: 'oracle_generate',\n        arguments: { languages: ['typescript'], methods: ['variant'], maxPatterns: 2 },\n      },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('generated' in data);\n    assert.ok('stored' in data);\n  });\n\n  it('handles oracle_auto_promote', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 13,\n      method: 'tools/call',\n      params: { name: 'oracle_auto_promote', arguments: {} },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.ok('attempted' in data);\n    assert.ok('promoted' in data);\n  });\n\n  it('handles oracle_promote with missing candidate', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({\n      id: 14,\n      method: 'tools/call',\n      params: { name: 'oracle_promote', arguments: { candidateId: 'nonexistent' } },\n    });\n    assert.ok(res.result.content);\n    const data = JSON.parse(res.result.content[0].text);\n    assert.equal(data.promoted, false);\n  });\n\n  it('lists all tools including candidate and community tools', () => {\n    server = new MCPServer();\n    const res = server.handleRequest({ id: 15, method: 'tools/list' });\n    const names = res.result.tools.map(t => t.name);\n    assert.ok(names.includes('oracle_candidates'));\n    assert.ok(names.includes('oracle_generate'));\n    assert.ok(names.includes('oracle_promote'));\n    assert.ok(names.includes('oracle_auto_promote'));\n    assert.ok(names.includes('oracle_share'));\n    assert.ok(names.includes('oracle_community'));\n    assert.equal(res.result.tools.length, 22);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/mcp.test.js (5 functions)",
      "tags": [
        "assert",
        "res",
        "names",
        "data",
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "b26cb0650861a13d",
      "name": "mockRes",
      "code": "function mockRes() {\n  const res = { statusCode: 200, headers: {}, body: '' };\n  res.setHeader = (k, v) => { res.headers[k] = v; };\n  res.writeHead = (code) => { res.statusCode = code; };\n  res.end = (body) => { res.body = body; };\n  return res;\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/auth.test.js",
      "tags": [
        "mockRes",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "fbc11f38485d6eae",
      "name": "f",
      "code": "function f() { if (true) { if (true) { while (true) { } } } }",
      "language": "javascript",
      "description": "Harvested function from . — tests/ast.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "c98f2fba013d1f2f",
      "name": "f",
      "code": "function f(x) { if (x > 0) { for (let i = 0; i < x; i++) { if (i % 2) { } } } }",
      "language": "javascript",
      "description": "Harvested function from . — tests/ast.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "47af883a142a55be",
      "name": "countBy",
      "code": "function countBy(items, key) {\n  const counts = {};\n  for (const item of items) {\n    const val = item[key] || 'unknown';\n    counts[val] = (counts[val] || 0) + 1;\n  }\n  return counts;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/store/sqlite.js",
      "tags": [
        "countBy",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "039dec831042d9be",
      "name": "getTopTags",
      "code": "function getTopTags(entries, limit) {\n  const counts = {};\n  for (const e of entries) {\n    for (const tag of e.tags) {\n      const t = tag.toLowerCase();\n      counts[t] = (counts[t] || 0) + 1;\n    }\n  }\n  return Object.entries(counts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, limit)\n    .map(([tag, count]) => ({ tag, count }));\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/store/sqlite.js",
      "tags": [
        "getTopTags",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "312eb7f951eb65ee",
      "name": "tryLoadSQLite",
      "code": "function tryLoadSQLite() {\n  try {\n    const { DatabaseSync } = require('node:sqlite');\n    if (DatabaseSync) {\n      const { SQLiteStore } = require('./sqlite');\n      return SQLiteStore;\n    }\n  } catch {}\n  return null;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/store/history.js",
      "tags": [
        "tryLoadSQLite",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "composite",
      "coherency": 0.84
    },
    {
      "id": "08967f7325eda53a",
      "name": "parseQueryString",
      "code": "function parseQueryString(qs) {\n  if (!qs || qs === '?') return {};\n  return qs.replace(/^\\\\?/, '').split('&').reduce(function(obj, pair) {\n    var parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '');\n    return obj;\n  }, {});\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "parseQueryString",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.84
    },
    {
      "id": "08d4f09126b41bc2",
      "name": "versioning.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  VersionManager,\n  semanticDiff,\n  extractFunctions,\n} = require('../src/core/versioning');\n\n// ─── Shared test code snippets ──────────────────────────────────────────────\n\nconst jsCodeA = `function add(a, b) { return a + b; }\nfunction sub(a, b) { return a - b; }`;\n\nconst jsCodeB = `function add(a, b, c) { return a + b + c; }\nfunction sub(a, b) { return a - b; }\nfunction mul(a, b) { return a * b; }`;\n\n// ─── VersionManager (in-memory) ─────────────────────────────────────────────\n\ndescribe('VersionManager (in-memory)', () => {\n  it('saveSnapshot returns version 1 for first snapshot', () => {\n    const vm = new VersionManager();\n    const snap = vm.saveSnapshot('pattern-a', 'const x = 1;');\n    assert.equal(snap.version, 1);\n    assert.equal(snap.patternId, 'pattern-a');\n    assert.equal(snap.code, 'const x = 1;');\n    assert.ok(snap.timestamp);\n  });\n\n  it('saveSnapshot auto-increments versions', () => {\n    const vm = new VersionManager();\n    const snap1 = vm.saveSnapshot('pattern-a', 'v1 code');\n    const snap2 = vm.saveSnapshot('pattern-a', 'v2 code');\n    const snap3 = vm.saveSnapshot('pattern-a', 'v3 code');\n    assert.equal(snap1.version, 1);\n    assert.equal(snap2.version, 2);\n    assert.equal(snap3.version, 3);\n  });\n\n  it('getHistory returns versions newest first', () => {\n    const vm = new VersionManager();\n    vm.saveSnapshot('p1', 'code-v1');\n    vm.saveSnapshot('p1', 'code-v2');\n    vm.saveSnapshot('p1', 'code-v3');\n    const history = vm.getHistory('p1');\n    assert.equal(history.length, 3);\n    assert.equal(history[0].version, 3);\n    assert.equal(history[1].version, 2);\n    assert.equal(history[2].version, 1);\n  });\n\n  it('getVersion returns specific version', () => {\n    const vm = new VersionManager();\n    vm.saveSnapshot('p1', 'code-v1', { author: 'alice' });\n    vm.saveSnapshot('p1', 'code-v2', { author: 'bob' });\n    const snap = vm.getVersion('p1', 1);\n    assert.equal(snap.version, 1);\n    assert.equal(snap.code, 'code-v1');\n    assert.deepEqual(snap.metadata, { author: 'alice' });\n  });\n\n  it('getVersion returns null for nonexistent version', () => {\n    const vm = new VersionManager();\n    vm.saveSnapshot('p1', 'code-v1');\n    const result = vm.getVersion('p1', 99);\n    assert.equal(result, null);\n  });\n\n  it('getLatestVersion returns 0 for unknown pattern', () => {\n    const vm = new VersionManager();\n    assert.equal(vm.getLatestVersion('nonexistent'), 0);\n  });\n\n  it('rollback returns code from specific version', () => {\n    const vm = new VersionManager();\n    vm.saveSnapshot('p1', 'original code');\n    vm.saveSnapshot('p1', 'updated code');\n    vm.saveSnapshot('p1', 'latest code');\n    const code = vm.rollback('p1', 1);\n    assert.equal(code, 'original code');\n  });\n\n  it('rollback returns null for nonexistent version', () => {\n    const vm = new VersionManager();\n    vm.saveSnapshot('p1', 'some code');\n    const result = vm.rollback('p1', 42);\n    assert.equal(result, null);\n  });\n});\n\n// ─── extractFunctions ───────────────────────────────────────────────────────\n\ndescribe('extractFunctions', () => {\n  it('extracts JS function declarations', () => {\n    const code = `function greet(name) {\n  return 'Hello ' + name;\n}\nfunction farewell(name) {\n  return 'Bye ' + name;\n}`;\n    const funcs = extractFunctions(code, 'javascript');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'greet');\n    assert.equal(funcs[0].signature, 'greet(name)');\n    assert.equal(funcs[0].startLine, 1);\n    assert.equal(funcs[1].name, 'farewell');\n    assert.equal(funcs[1].signature, 'farewell(name)');\n  });\n\n  it('extracts JS arrow functions (const name = () =>)', () => {\n    const code = `const double = (n) => {\n  return n * 2;\n};\nconst triple = (n) => {\n  return n * 3;\n};`;\n    const funcs = extractFunctions(code, 'js');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'double');\n    assert.equal(funcs[0].signature, 'double(n)');\n    assert.equal(funcs[1].name, 'triple');\n  });\n\n  it('extracts JS methods', () => {\n    const code = `class Calculator {\n  add(a, b) {\n    return a + b;\n  }\n  subtract(a, b) {\n    return a - b;\n  }\n}`;\n    const funcs = extractFunctions(code, 'javascript');\n    const names = funcs.map(f => f.name);\n    assert.ok(names.includes('add'), 'should extract add method');\n    assert.ok(names.includes('subtract'), 'should extract subtract method');\n  });\n\n  it('extracts Python functions (def name())', () => {\n    const code = `def greet(name):\n    return f\"Hello {name}\"\n\ndef farewell(name):\n    return f\"Bye {name}\"`;\n    const funcs = extractFunctions(code, 'python');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'greet');\n    assert.equal(funcs[0].signature, 'greet(name)');\n    assert.equal(funcs[1].name, 'farewell');\n    assert.equal(funcs[1].signature, 'farewell(name)');\n  });\n\n  it('extracts Go functions (func name())', () => {\n    const code = `func Add(a int, b int) int {\n\treturn a + b\n}\nfunc Sub(a int, b int) int {\n\treturn a - b\n}`;\n    const funcs = extractFunctions(code, 'go');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'Add');\n    assert.equal(funcs[0].signature, 'Add(a int, b int)');\n    assert.equal(funcs[1].name, 'Sub');\n  });\n\n  it('extracts Rust functions (pub fn name())', () => {\n    const code = `pub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\nfn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}`;\n    const funcs = extractFunctions(code, 'rust');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'add');\n    assert.equal(funcs[0].signature, 'add(a: i32, b: i32)');\n    assert.equal(funcs[1].name, 'multiply');\n  });\n\n  it('returns empty for no functions', () => {\n    const code = `// just a comment\nconst x = 42;`;\n    const funcs = extractFunctions(code, 'javascript');\n    assert.equal(funcs.length, 0);\n  });\n});\n\n// ─── semanticDiff ───────────────────────────────────────────────────────────\n\ndescribe('semanticDiff', () => {\n  it('identical code has similarity 1.0 and changeType cosmetic', () => {\n    const code = `function add(a, b) { return a + b; }`;\n    const result = semanticDiff(code, code, 'javascript');\n    assert.equal(result.similarity, 1.0);\n    assert.equal(result.changeType, 'cosmetic');\n    assert.equal(result.summary.unchanged, 1);\n    assert.equal(result.summary.added, 0);\n    assert.equal(result.summary.removed, 0);\n    assert.equal(result.summary.modified, 0);\n  });\n\n  it('adding a function shows function-added structural change', () => {\n    const result = semanticDiff(jsCodeA, jsCodeB, 'javascript');\n    const addedChanges = result.structuralChanges.filter(c => c.type === 'function-added');\n    assert.ok(addedChanges.length > 0, 'should have function-added structural change');\n    const addedFunc = result.functions.find(f => f.name === 'mul');\n    assert.ok(addedFunc, 'mul function should be in functions list');\n    assert.equal(addedFunc.change, 'added');\n    assert.equal(result.summary.added, 1);\n  });\n\n  it('removing a function shows function-removed structural change', () => {\n    const result = semanticDiff(jsCodeB, jsCodeA, 'javascript');\n    const removedChanges = result.structuralChanges.filter(c => c.type === 'function-removed');\n    assert.ok(removedChanges.length > 0, 'should have function-removed structural change');\n    const removedFunc = result.functions.find(f => f.name === 'mul');\n    assert.ok(removedFunc, 'mul function should be in functions list');\n    assert.equal(removedFunc.change, 'removed');\n    assert.equal(result.summary.removed, 1);\n  });\n\n  it('modifying function body shows body-changed structural change', () => {\n    const codeOld = `function compute(x) {\n  return x * 2;\n}`;\n    const codeNew = `function compute(x) {\n  return x * 2 + 1;\n}`;\n    const result = semanticDiff(codeOld, codeNew, 'javascript');\n    const bodyChanges = result.structuralChanges.filter(c => c.type === 'body-changed');\n    assert.ok(bodyChanges.length > 0, 'should have body-changed structural change');\n    const modifiedFunc = result.functions.find(f => f.name === 'compute');\n    assert.equal(modifiedFunc.change, 'modified');\n    assert.equal(modifiedFunc.bodyChanged, true);\n  });\n\n  it('changing signature shows signature-changed structural change', () => {\n    const result = semanticDiff(jsCodeA, jsCodeB, 'javascript');\n    const sigChanges = result.structuralChanges.filter(c => c.type === 'signature-changed');\n    assert.ok(sigChanges.length > 0, 'should have signature-changed structural change');\n    const addFunc = result.functions.find(f => f.name === 'add');\n    assert.ok(addFunc, 'add function should be in functions list');\n    assert.equal(addFunc.change, 'modified');\n    assert.equal(addFunc.oldSignature, 'add(a, b)');\n    assert.equal(addFunc.newSignature, 'add(a, b, c)');\n  });\n\n  it('completely different code has changeType rewrite', () => {\n    const codeA = `function alpha() { return 1; }`;\n    const codeB = `def totally_different_python_function(xyz):\n    import os\n    import sys\n    result = xyz ** 3\n    return result`;\n    const result = semanticDiff(codeA, codeB, 'javascript');\n    assert.equal(result.changeType, 'rewrite');\n    assert.ok(result.similarity < 0.3, `similarity ${result.similarity} should be < 0.3`);\n  });\n\n  it('lineDiff contains added, removed, and same entries', () => {\n    const result = semanticDiff(jsCodeA, jsCodeB, 'javascript');\n    const types = new Set(result.lineDiff.map(d => d.type));\n    assert.ok(types.has('added'), 'lineDiff should contain added entries');\n    assert.ok(types.has('removed'), 'lineDiff should contain removed entries');\n    assert.ok(types.has('same'), 'lineDiff should contain same entries');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/versioning.test.js (41 functions)",
      "tags": [
        "assert",
        "jsCodeA",
        "add",
        "sub",
        "jsCodeB",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.835
    },
    {
      "id": "c8f0255de9c13d75",
      "name": "test-synth.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst {\n  synthesizeTests,\n  extractSignature,\n  inferParamType,\n  testValuesForType,\n  translateTestsToPython,\n  jsToPyExpr,\n  generateFromSignature,\n  synthesizeForCandidates,\n} = require('../src/core/test-synth');\nconst { RemembranceOracle } = require('../src/api/oracle');\n\nfunction makeTempDir() {\n  const dir = path.join(os.tmpdir(), `synth-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}\n\ndescribe('Test Synthesizer', () => {\n  describe('extractSignature', () => {\n    it('extracts JS function signature', () => {\n      const sig = extractSignature('function add(a, b) { return a + b; }', 'javascript');\n      assert.equal(sig.name, 'add');\n      assert.equal(sig.params.length, 2);\n      assert.equal(sig.params[0].name, 'a');\n      assert.equal(sig.params[1].name, 'b');\n    });\n\n    it('extracts Python function signature', () => {\n      const sig = extractSignature('def add(a, b):\\n    return a + b', 'python');\n      assert.equal(sig.name, 'add');\n      assert.equal(sig.params.length, 2);\n    });\n\n    it('extracts params with defaults', () => {\n      const sig = extractSignature('function greet(name = \"world\") { return \"hello \" + name; }', 'javascript');\n      assert.equal(sig.params[0].name, 'name');\n      assert.equal(sig.params[0].default, '\"world\"');\n    });\n\n    it('extracts TS typed params', () => {\n      const sig = extractSignature('function add(a: number, b: number) { return a + b; }', 'typescript');\n      assert.equal(sig.params[0].name, 'a');\n      assert.equal(sig.params[0].type, 'number');\n    });\n\n    it('returns null for non-function code', () => {\n      const sig = extractSignature('const x = 42;', 'javascript');\n      assert.equal(sig, null);\n    });\n  });\n\n  describe('inferParamType', () => {\n    it('infers number from name patterns', () => {\n      assert.equal(inferParamType('n', ''), 'number');\n      assert.equal(inferParamType('count', ''), 'number');\n      assert.equal(inferParamType('index', ''), 'number');\n      assert.equal(inferParamType('size', ''), 'number');\n    });\n\n    it('infers string from name patterns', () => {\n      assert.equal(inferParamType('str', ''), 'string');\n      assert.equal(inferParamType('text', ''), 'string');\n      assert.equal(inferParamType('name', ''), 'string');\n    });\n\n    it('infers array from name patterns', () => {\n      assert.equal(inferParamType('arr', ''), 'array');\n      assert.equal(inferParamType('items', ''), 'array');\n      assert.equal(inferParamType('nums', ''), 'array');\n    });\n\n    it('infers function from name patterns', () => {\n      assert.equal(inferParamType('fn', ''), 'function');\n      assert.equal(inferParamType('callback', ''), 'function');\n      assert.equal(inferParamType('predicate', ''), 'function');\n    });\n\n    it('infers from code usage', () => {\n      assert.equal(inferParamType('x', 'x.length'), 'array');\n      assert.equal(inferParamType('x', 'x.split(\"\")'), 'string');\n    });\n  });\n\n  describe('jsToPyExpr', () => {\n    it('converts JSON.stringify', () => {\n      assert.equal(jsToPyExpr('JSON.stringify(arr)'), 'arr');\n    });\n\n    it('converts .length to len()', () => {\n      assert.equal(jsToPyExpr('arr.length'), 'len(arr)');\n    });\n\n    it('converts Math builtins', () => {\n      assert.equal(jsToPyExpr('Math.max(a, b)'), 'max(a, b)');\n      assert.equal(jsToPyExpr('Math.abs(x)'), 'abs(x)');\n    });\n\n    it('converts booleans and null', () => {\n      assert.equal(jsToPyExpr('true'), 'True');\n      assert.equal(jsToPyExpr('false'), 'False');\n      assert.equal(jsToPyExpr('null'), 'None');\n    });\n\n    it('converts operators', () => {\n      assert.equal(jsToPyExpr('a === b'), 'a == b');\n      assert.equal(jsToPyExpr('a !== b'), 'a != b');\n    });\n\n    it('strips string-wrapped arrays', () => {\n      assert.equal(jsToPyExpr(\"'[1,2,3]'\"), '[1,2,3]');\n    });\n  });\n\n  describe('translateTestsToPython', () => {\n    it('translates if (!==) throw to assert ==', () => {\n      const js = 'if (add(1, 2) !== 3) throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'add', 'add');\n      assert.ok(py.includes('assert add(1, 2) == 3'));\n    });\n\n    it('translates if (===) throw to assert !=', () => {\n      const js = 'if (isEmpty(\"\") === false) throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'isEmpty', 'is_empty');\n      assert.ok(py.includes('assert is_empty(\"\")'));\n      assert.ok(py.includes('!= False'));\n    });\n\n    it('translates if (!expr) throw to assert expr', () => {\n      const js = 'if (!isValid(\"test\")) throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'isValid', 'is_valid');\n      assert.ok(py.includes('assert is_valid(\"test\")'));\n    });\n\n    it('renames function calls', () => {\n      const js = 'if (myFunc(1) !== 2) throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'myFunc', 'my_func');\n      assert.ok(py.includes('my_func(1)'));\n      assert.ok(!py.includes('myFunc'));\n    });\n\n    it('removes JSON.stringify', () => {\n      const js = 'if (JSON.stringify(chunk([1,2,3], 2)) !== \"[[1,2],[3]]\") throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'chunk', 'chunk');\n      assert.ok(!py.includes('JSON.stringify'));\n      assert.ok(py.includes('chunk([1,2,3], 2)'));\n    });\n\n    it('converts booleans', () => {\n      const js = 'if (check(true) !== false) throw new Error(\"fail\");';\n      const py = translateTestsToPython(js, 'check', 'check');\n      assert.ok(py.includes('True'));\n      assert.ok(py.includes('False'));\n    });\n  });\n\n  describe('synthesizeTests', () => {\n    it('generates tests for simple JS function', () => {\n      const code = 'function add(a, b) { return a + b; }';\n      const tests = synthesizeTests(code, 'javascript');\n      assert.ok(tests.length > 0);\n      assert.ok(tests.includes('add('));\n    });\n\n    it('generates tests for Python function', () => {\n      const code = 'def multiply(n, factor):\\n    return n * factor';\n      const tests = synthesizeTests(code, 'python');\n      assert.ok(tests.length > 0);\n      assert.ok(tests.includes('multiply('));\n    });\n\n    it('uses parent tests when available', () => {\n      const code = 'def add(a, b):\\n    return a + b';\n      const parentTest = 'if (add(1, 2) !== 3) throw new Error(\"fail\");';\n      const tests = synthesizeTests(code, 'python', {\n        parentTestCode: parentTest,\n        parentFuncName: 'add',\n      });\n      assert.ok(tests.includes('assert'));\n      assert.ok(tests.includes('add(1, 2)'));\n      assert.ok(tests.includes('== 3'));\n    });\n\n    it('returns empty string for non-function code', () => {\n      const tests = synthesizeTests('const x = 42;', 'javascript');\n      assert.equal(tests, '');\n    });\n  });\n\n  describe('synthesizeForCandidates', () => {\n    let oracle, tmpDir;\n\n    beforeEach(() => {\n      tmpDir = makeTempDir();\n      oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, generateVariants: false, autoGrow: false });\n    });\n\n    it('synthesizes tests for candidates', () => {\n      // Register a parent pattern\n      oracle.registerPattern({\n        name: 'synth-parent',\n        code: 'function synthParent(n) { return n * 2; }',\n        testCode: 'if (synthParent(5) !== 10) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Double',\n        tags: ['math'],\n        patternType: 'utility',\n      });\n\n      // Add a Python candidate without proper test\n      oracle.patterns.addCandidate({\n        name: 'synth-parent-py',\n        code: 'def synth_parent(n):\\n    return n * 2',\n        language: 'python',\n        coherencyTotal: 0.8,\n        parentPattern: 'synth-parent',\n        generationMethod: 'variant',\n      });\n\n      const report = synthesizeForCandidates(oracle);\n      assert.equal(report.processed, 1);\n      assert.equal(report.synthesized, 1);\n    });\n\n    it('preserves existing good tests', () => {\n      // Add a candidate that already has longer test code\n      oracle.patterns.addCandidate({\n        name: 'has-tests',\n        code: 'function hasTests(n) { return n + 1; }',\n        language: 'javascript',\n        coherencyTotal: 0.8,\n        testCode: 'if (hasTests(0) !== 1) throw new Error(\"a\");\\nif (hasTests(1) !== 2) throw new Error(\"b\");\\nif (hasTests(-1) !== 0) throw new Error(\"c\");\\nif (hasTests(100) !== 101) throw new Error(\"d\");',\n        generationMethod: 'variant',\n      });\n\n      const report = synthesizeForCandidates(oracle);\n      assert.equal(report.processed, 1);\n      // Should keep existing since it's comprehensive\n    });\n\n    it('dry run does not modify candidates', () => {\n      oracle.patterns.addCandidate({\n        name: 'dry-run-test',\n        code: 'def dry_test(n):\\n    return n + 1',\n        language: 'python',\n        coherencyTotal: 0.8,\n        generationMethod: 'variant',\n      });\n\n      const report = synthesizeForCandidates(oracle, { dryRun: true });\n      assert.equal(report.processed, 1);\n      // Verify candidate still has no test code\n      const cand = oracle.candidates()[0];\n      assert.equal(cand.testCode, null);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/test-synth.test.js (22 functions)",
      "tags": [
        "assert",
        "path",
        "fs",
        "os",
        "makeTempDir",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.83
    },
    {
      "id": "99cd6098ab5b0b1b",
      "name": "action",
      "code": "/**\n * GitHub Action entry point for the Remembrance Oracle.\n *\n * This allows anyone to use the Oracle as a GitHub Action in their workflows:\n *\n *   - uses: Crackedcoder5TH/remembrance-oracle-toolkit@main\n *     with:\n *       command: query\n *       description: \"sorting algorithm\"\n *       language: javascript\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Lightweight core-compatible action runner (no @actions/core dependency needed)\nfunction getInput(name) {\n  const envVar = `INPUT_${name.replace(/-/g, '_').toUpperCase()}`;\n  return process.env[envVar] || '';\n}\n\nfunction setOutput(name, value) {\n  const filePath = process.env.GITHUB_OUTPUT;\n  if (filePath) {\n    fs.appendFileSync(filePath, `${name}=${typeof value === 'object' ? JSON.stringify(value) : value}\\n`);\n  }\n  console.log(`::set-output name=${name}::${typeof value === 'object' ? JSON.stringify(value) : value}`);\n}\n\nasync function run() {\n  const { RemembranceOracle } = require('./api/oracle');\n  const oracle = new RemembranceOracle();\n\n  const command = getInput('command') || 'stats';\n\n  try {\n    if (command === 'submit') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for submit');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const result = oracle.submit(code, {\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        testCode,\n        author: process.env.GITHUB_ACTOR || 'github-action',\n      });\n\n      setOutput('result', result);\n      setOutput('accepted', result.accepted);\n      setOutput('coherency-score', result.validation?.coherencyScore?.total || 0);\n\n      if (result.accepted) {\n        console.log(`Code accepted with coherency score: ${result.entry.coherencyScore.total}`);\n      } else {\n        console.log(`Code rejected: ${result.reason}`);\n        process.exitCode = 1;\n      }\n    }\n\n    else if (command === 'query') {\n      const results = oracle.query({\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        limit: parseInt(getInput('limit')) || 5,\n        minCoherency: parseFloat(getInput('min-coherency')) || 0.5,\n      });\n\n      setOutput('result', results);\n      console.log(`Found ${results.length} result(s)`);\n      for (const r of results) {\n        console.log(`\\n[${r.id}] coherency=${r.coherencyScore} relevance=${r.relevanceScore}`);\n        console.log(`  ${r.language} | ${r.tags.join(', ')}`);\n        console.log(`  ${r.description}`);\n      }\n    }\n\n    else if (command === 'validate') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for validate');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const { validateCode } = require('./core/validator');\n      const result = validateCode(code, {\n        language: getInput('language'),\n        testCode,\n      });\n\n      setOutput('result', result);\n      setOutput('coherency-score', result.coherencyScore?.total || 0);\n      console.log(`Valid: ${result.valid} | Coherency: ${result.coherencyScore?.total}`);\n    }\n\n    else if (command === 'feedback') {\n      const id = getInput('entry-id');\n      if (!id) throw new Error('Input \"entry-id\" is required for feedback');\n      const succeeded = getInput('success') === 'true';\n      const result = oracle.feedback(id, succeeded);\n      setOutput('result', result);\n      console.log(result.success ? `Reliability updated: ${result.newReliability}` : result.error);\n    }\n\n    else if (command === 'stats') {\n      const stats = oracle.stats();\n      setOutput('result', stats);\n      console.log('Remembrance Oracle Stats:');\n      console.log(`  Entries: ${stats.totalEntries}`);\n      console.log(`  Languages: ${stats.languages.join(', ') || 'none'}`);\n      console.log(`  Avg Coherency: ${stats.avgCoherency}`);\n    }\n\n    else if (command === 'prune') {\n      const min = parseFloat(getInput('min-coherency')) || 0.4;\n      const result = oracle.prune(min);\n      setOutput('result', result);\n      console.log(`Pruned ${result.removed} entries. ${result.remaining} remaining.`);\n    }\n\n    else {\n      throw new Error(`Unknown command: ${command}`);\n    }\n\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n    process.exitCode = 1;\n  }\n}\n\nrun();\n",
      "language": "javascript",
      "description": "Harvested from . — src/action.js (18 functions)",
      "tags": [
        "fs",
        "path",
        "getInput",
        "envVar",
        "setOutput",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.83
    },
    {
      "id": "694124a0a978dcc8",
      "name": "run",
      "code": "async function run() {\n  const { RemembranceOracle } = require('./api/oracle');\n  const oracle = new RemembranceOracle();\n\n  const command = getInput('command') || 'stats';\n\n  try {\n    if (command === 'submit') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for submit');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const result = oracle.submit(code, {\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        testCode,\n        author: process.env.GITHUB_ACTOR || 'github-action',\n      });\n\n      setOutput('result', result);\n      setOutput('accepted', result.accepted);\n      setOutput('coherency-score', result.validation?.coherencyScore?.total || 0);\n\n      if (result.accepted) {\n        console.log(`Code accepted with coherency score: ${result.entry.coherencyScore.total}`);\n      } else {\n        console.log(`Code rejected: ${result.reason}`);\n        process.exitCode = 1;\n      }\n    }\n\n    else if (command === 'query') {\n      const results = oracle.query({\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        limit: parseInt(getInput('limit')) || 5,\n        minCoherency: parseFloat(getInput('min-coherency')) || 0.5,\n      });\n\n      setOutput('result', results);\n      console.log(`Found ${results.length} result(s)`);\n      for (const r of results) {\n        console.log(`\\n[${r.id}] coherency=${r.coherencyScore} relevance=${r.relevanceScore}`);\n        console.log(`  ${r.language} | ${r.tags.join(', ')}`);\n        console.log(`  ${r.description}`);\n      }\n    }\n\n    else if (command === 'validate') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for validate');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const { validateCode } = require('./core/validator');\n      const result = validateCode(code, {\n        language: getInput('language'),\n        testCode,\n      });\n\n      setOutput('result', result);\n      setOutput('coherency-score', result.coherencyScore?.total || 0);\n      console.log(`Valid: ${result.valid} | Coherency: ${result.coherencyScore?.total}`);\n    }\n\n    else if (command === 'feedback') {\n      const id = getInput('entry-id');\n      if (!id) throw new Error('Input \"entry-id\" is required for feedback');\n      const succeeded = getInput('success') === 'true';\n      const result = oracle.feedback(id, succeeded);\n      setOutput('result', result);\n      console.log(result.success ? `Reliability updated: ${result.newReliability}` : result.error);\n    }\n\n    else if (command === 'stats') {\n      const stats = oracle.stats();\n      setOutput('result', stats);\n      console.log('Remembrance Oracle Stats:');\n      console.log(`  Entries: ${stats.totalEntries}`);\n      console.log(`  Languages: ${stats.languages.join(', ') || 'none'}`);\n      console.log(`  Avg Coherency: ${stats.avgCoherency}`);\n    }\n\n    else if (command === 'prune') {\n      const min = parseFloat(getInput('min-coherency')) || 0.4;\n      const result = oracle.prune(min);\n      setOutput('result', result);\n      console.log(`Pruned ${result.removed} entries. ${result.remaining} remaining.`);\n    }\n\n    else {\n      throw new Error(`Unknown command: ${command}`);\n    }\n\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n    process.exitCode = 1;\n  }\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/action.js",
      "tags": [
        "run",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.83
    },
    {
      "id": "a6c64f2eb5c77aa9",
      "name": "promiseTimeout-ts",
      "code": "function promiseTimeout(promise: any, ms: any) {\n  let timeout = new Promise(function(_, reject) {\n    setTimeout(function() { reject(new Error('timeout')); }, ms);\n  });\n  return Promise.race([promise, timeout]);\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "promiseTimeout",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "e63fb2a9ede57079",
      "name": "pMap-ts",
      "code": "function pMap(items: any[], fn: Function, concurrency: any) {\n  concurrency = concurrency || Infinity;\n  let results = new Array(items.length);\n  let index = 0;\n  function worker() {\n    let work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }\n  let workers = [];\n  for (let i = 0; i < Math.min(concurrency, items.length); i++) workers.push(worker());\n  return Promise.all(workers).then(function() { return results; });\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "pMap",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "8b91591d9ab2f9b4",
      "name": "retry-ts",
      "code": "async function retry(fn: Function, maxRetries: number, delay: number) {\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));\n      }\n    }\n  }\n  throw lastError;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "retry",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "8a9e55c8dd2f1cec",
      "name": "flattenDeep",
      "code": "function flattenDeep(arr) {\n  const result = [];\n  const stack = [...arr];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    if (Array.isArray(item)) {\n      stack.push(...item);\n    } else {\n      result.unshift(item);\n    }\n  }\n  return result;\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "flattenDeep",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "bc4fbd2ceab621a5",
      "name": "extension.test",
      "code": "/**\n * VS Code Extension Tests\n *\n * Tests the extension components without requiring VS Code runtime.\n * Mocks the vscode module to test pure logic.\n */\n\nconst { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\n\n// Mock the vscode module for testing outside VS Code\nconst mockVscode = {\n  DiagnosticSeverity: { Error: 0, Warning: 1, Information: 2, Hint: 3 },\n  TreeItemCollapsibleState: { None: 0, Collapsed: 1, Expanded: 2 },\n  CodeActionKind: { QuickFix: 'quickfix', Refactor: 'refactor' },\n  StatusBarAlignment: { Left: 1, Right: 2 },\n  ThemeIcon: class ThemeIcon { constructor(id) { this.id = id; } },\n  TreeItem: class TreeItem {\n    constructor(label, collapsible) { this.label = label; this.collapsibleState = collapsible; }\n  },\n  MarkdownString: class MarkdownString {\n    constructor() { this.value = ''; this.isTrusted = false; }\n    appendMarkdown(s) { this.value += s; }\n  },\n  Range: class Range {\n    constructor(start, end) { this.start = start; this.end = end; }\n  },\n  Position: class Position {\n    constructor(line, char) { this.line = line; this.character = char; }\n  },\n  Diagnostic: class Diagnostic {\n    constructor(range, message, severity) {\n      this.range = range; this.message = message; this.severity = severity;\n    }\n  },\n  EventEmitter: class EventEmitter {\n    constructor() { this._listeners = []; }\n    get event() { return (fn) => this._listeners.push(fn); }\n    fire(data) { this._listeners.forEach(fn => fn(data)); }\n  },\n  window: {\n    activeTextEditor: null,\n    visibleTextEditors: [],\n    showInformationMessage: () => {},\n    showWarningMessage: () => {},\n    showInputBox: () => Promise.resolve(''),\n    showQuickPick: () => Promise.resolve(null),\n    createStatusBarItem: () => ({ text: '', show: () => {}, dispose: () => {} }),\n    registerTreeDataProvider: () => ({ dispose: () => {} }),\n  },\n  workspace: {\n    getConfiguration: () => ({\n      get: (key, def) => def,\n    }),\n    workspaceFolders: [],\n    onDidSaveTextDocument: () => ({ dispose: () => {} }),\n    openTextDocument: () => Promise.resolve({ getText: () => '' }),\n  },\n  languages: {\n    createDiagnosticCollection: () => ({\n      set: () => {},\n      clear: () => {},\n      dispose: () => {},\n    }),\n    registerHoverProvider: () => ({ dispose: () => {} }),\n    registerCodeActionsProvider: () => ({ dispose: () => {} }),\n    registerCompletionItemProvider: () => ({ dispose: () => {} }),\n  },\n  commands: {\n    registerCommand: () => ({ dispose: () => {} }),\n  },\n  CompletionItem: class CompletionItem {\n    constructor(label, kind) { this.label = label; this.kind = kind; }\n  },\n  CompletionItemKind: { Snippet: 15 },\n  SnippetString: class SnippetString {\n    constructor(value) { this.value = value; }\n  },\n  WorkspaceEdit: class WorkspaceEdit {\n    constructor() { this.edits = []; }\n    replace(uri, range, text) { this.edits.push({ uri, range, text }); }\n  },\n  CodeAction: class CodeAction {\n    constructor(title, kind) { this.title = title; this.kind = kind; }\n  },\n  Hover: class Hover {\n    constructor(contents, range) { this.contents = contents; this.range = range; }\n  },\n};\n\n// Override require to provide mock vscode\nconst Module = require('module');\nconst originalResolve = Module._resolveFilename;\nModule._resolveFilename = function(request, parent, ...rest) {\n  if (request === 'vscode') return 'vscode';\n  return originalResolve.call(this, request, parent, ...rest);\n};\nconst originalLoad = Module._cache;\nrequire.cache['vscode'] = { id: 'vscode', filename: 'vscode', loaded: true, exports: mockVscode };\n\n// Now require extension modules\nconst oraclePath = path.resolve(__dirname, '..', '..');\n\n// ─── resolveOraclePath ───\n\ndescribe('Extension', () => {\n  describe('resolveOraclePath', () => {\n    it('exports activate and deactivate', () => {\n      const ext = require('../src/extension');\n      assert.equal(typeof ext.activate, 'function');\n      assert.equal(typeof ext.deactivate, 'function');\n    });\n\n    it('exports resolveOraclePath', () => {\n      const ext = require('../src/extension');\n      assert.equal(typeof ext.resolveOraclePath, 'function');\n    });\n\n    it('resolveOraclePath finds the toolkit from extension location', () => {\n      const ext = require('../src/extension');\n      const result = ext.resolveOraclePath();\n      // Since we're running from within the toolkit, it should find it\n      assert.ok(result === null || typeof result === 'string');\n    });\n  });\n});\n\n// ─── Sidebar ───\n\ndescribe('Sidebar', () => {\n  const { SidebarProvider, PatternsTreeProvider, DebugTreeProvider, StatsTreeProvider, OracleTreeItem } = require('../src/sidebar');\n\n  describe('OracleTreeItem', () => {\n    it('creates a tree item with label and data', () => {\n      const item = new OracleTreeItem('test', 0, { description: 'desc', icon: 'bug' });\n      assert.equal(item.label, 'test');\n      assert.equal(item.description, 'desc');\n      assert.ok(item.iconPath);\n    });\n\n    it('handles empty data', () => {\n      const item = new OracleTreeItem('test', 0);\n      assert.equal(item.label, 'test');\n    });\n\n    it('sets command when provided', () => {\n      const cmd = { command: 'test.cmd', title: 'Test' };\n      const item = new OracleTreeItem('test', 0, { command: cmd });\n      assert.deepEqual(item.command, cmd);\n    });\n  });\n\n  describe('PatternsTreeProvider', () => {\n    it('creates with oracle path', () => {\n      const provider = new PatternsTreeProvider(oraclePath);\n      assert.ok(provider);\n      assert.equal(typeof provider.getChildren, 'function');\n      assert.equal(typeof provider.getTreeItem, 'function');\n    });\n\n    it('returns root language groups', () => {\n      const provider = new PatternsTreeProvider(oraclePath);\n      const children = provider.getChildren();\n      assert.ok(Array.isArray(children));\n      // May be empty in test environment with fresh oracle — just check it doesn't throw\n    });\n\n    it('getTreeItem returns the element', () => {\n      const provider = new PatternsTreeProvider(oraclePath);\n      const item = new OracleTreeItem('test', 0);\n      assert.equal(provider.getTreeItem(item), item);\n    });\n\n    it('refresh fires event', () => {\n      const provider = new PatternsTreeProvider(oraclePath);\n      let fired = false;\n      provider.onDidChangeTreeData(() => { fired = true; });\n      provider.refresh();\n      assert.ok(fired);\n    });\n  });\n\n  describe('DebugTreeProvider', () => {\n    it('creates with oracle path', () => {\n      const provider = new DebugTreeProvider(oraclePath);\n      assert.ok(provider);\n    });\n\n    it('returns children array', () => {\n      const provider = new DebugTreeProvider(oraclePath);\n      const children = provider.getChildren();\n      assert.ok(Array.isArray(children));\n    });\n  });\n\n  describe('StatsTreeProvider', () => {\n    it('creates with oracle path', () => {\n      const provider = new StatsTreeProvider(oraclePath);\n      assert.ok(provider);\n    });\n\n    it('returns stats items', () => {\n      const provider = new StatsTreeProvider(oraclePath);\n      const children = provider.getChildren();\n      assert.ok(Array.isArray(children));\n      assert.ok(children.length > 0);\n      // Should have total patterns\n      assert.ok(children.some(c => c.label.includes('Total Patterns')));\n    });\n\n    it('includes coherency stat', () => {\n      const provider = new StatsTreeProvider(oraclePath);\n      const children = provider.getChildren();\n      assert.ok(children.some(c => c.label.includes('Coherency')));\n    });\n  });\n\n  describe('SidebarProvider', () => {\n    it('creates all three views', () => {\n      const config = { get: (k, d) => d };\n      const provider = new SidebarProvider(oraclePath, config);\n      assert.ok(provider.patternsView);\n      assert.ok(provider.debugView);\n      assert.ok(provider.statsView);\n    });\n  });\n});\n\n// ─── Diagnostics ───\n\ndescribe('Diagnostics', () => {\n  const { DiagnosticsProvider } = require('../src/diagnostics');\n\n  it('creates provider', () => {\n    const config = { get: (k, d) => d };\n    const provider = new DiagnosticsProvider(oraclePath, config);\n    assert.ok(provider);\n  });\n\n  it('setCollection stores the collection', () => {\n    const config = { get: (k, d) => d };\n    const provider = new DiagnosticsProvider(oraclePath, config);\n    const mockCollection = { set: () => {}, clear: () => {} };\n    provider.setCollection(mockCollection);\n    assert.equal(provider.collection, mockCollection);\n  });\n\n  it('analyze does nothing without collection', () => {\n    const config = { get: (k, d) => d };\n    const provider = new DiagnosticsProvider(oraclePath, config);\n    // Should not throw\n    provider.analyze({ getText: () => 'const x = 1;', languageId: 'javascript', uri: { toString: () => 'test' } });\n  });\n\n  it('analyze processes a document with collection', () => {\n    const config = { get: (k, d) => d };\n    const provider = new DiagnosticsProvider(oraclePath, config);\n    let setCalled = false;\n    provider.setCollection({\n      set: () => { setCalled = true; },\n      clear: () => {},\n    });\n    const mockDoc = {\n      getText: () => 'function test() { return 42; }',\n      languageId: 'javascript',\n      uri: { toString: () => 'file:///test.js' },\n    };\n    provider.analyze(mockDoc);\n    assert.ok(setCalled);\n  });\n\n  it('refreshAll clears and re-analyzes', () => {\n    const config = { get: (k, d) => d };\n    const provider = new DiagnosticsProvider(oraclePath, config);\n    let cleared = false;\n    provider.setCollection({ set: () => {}, clear: () => { cleared = true; } });\n    provider.refreshAll();\n    assert.ok(cleared);\n  });\n});\n\n// ─── Hover ───\n\ndescribe('Hover', () => {\n  const { HoverProvider } = require('../src/hover');\n\n  it('creates provider', () => {\n    const provider = new HoverProvider(oraclePath);\n    assert.ok(provider);\n    assert.equal(typeof provider.provideHover, 'function');\n  });\n});\n\n// ─── Code Actions ───\n\ndescribe('CodeActions', () => {\n  const { CodeActionProvider } = require('../src/code-actions');\n\n  it('creates provider', () => {\n    const provider = new CodeActionProvider(oraclePath);\n    assert.ok(provider);\n    assert.equal(typeof provider.provideCodeActions, 'function');\n  });\n\n  it('returns empty array when no diagnostics', () => {\n    const provider = new CodeActionProvider(oraclePath);\n    const mockDoc = {\n      getText: () => 'function test() { return 42; }',\n      languageId: 'javascript',\n    };\n    const mockRange = { start: { line: 0, character: 0 }, end: { line: 0, character: 10 } };\n    const actions = provider.provideCodeActions(mockDoc, mockRange, { diagnostics: [] });\n    assert.ok(Array.isArray(actions));\n  });\n});\n\n// ─── Completions ───\n\ndescribe('Completions', () => {\n  const { CompletionProvider } = require('../src/completions');\n\n  it('creates provider', () => {\n    const provider = new CompletionProvider(oraclePath);\n    assert.ok(provider);\n    assert.equal(typeof provider.provideCompletionItems, 'function');\n  });\n});\n\n// ─── Commands ───\n\ndescribe('Commands', () => {\n  const { CommandHandler } = require('../src/commands');\n\n  it('creates handler', () => {\n    const config = { get: (k, d) => d };\n    const handler = new CommandHandler(oraclePath, config);\n    assert.ok(handler);\n    assert.equal(typeof handler.search, 'function');\n    assert.equal(typeof handler.smartSearch, 'function');\n    assert.equal(typeof handler.submitSelection, 'function');\n    assert.equal(typeof handler.debugCapture, 'function');\n    assert.equal(typeof handler.debugSearch, 'function');\n    assert.equal(typeof handler.resolve, 'function');\n    assert.equal(typeof handler.showStats, 'function');\n    assert.equal(typeof handler.insertPattern, 'function');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — vscode-extension/tests/extension.test.js (23 functions)",
      "tags": [
        "assert",
        "path",
        "mockVscode",
        "Module",
        "originalResolve",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "f238414d0be9a8da",
      "name": "index",
      "code": "/**\n * Remembrance Oracle Toolkit — Main Entry Point\n *\n * A code memory system that:\n * - Only stores code that PROVES itself (passes validation + coherency threshold)\n * - Scores all code on coherency (syntax, completeness, consistency, test proof)\n * - Serves the most relevant, highest-scoring code to any AI that queries it\n * - Tracks historical reliability so quality improves over time\n */\n\nconst { RemembranceOracle } = require('./api/oracle');\nconst { computeCoherencyScore, detectLanguage } = require('./core/coherency');\nconst { validateCode } = require('./core/validator');\nconst { rankEntries, computeRelevance } = require('./core/relevance');\nconst { VerifiedHistoryStore } = require('./store/history');\nconst { SQLiteStore } = require('./store/sqlite');\nconst { AIConnector } = require('./connectors/connector');\nconst providers = require('./connectors/providers');\nconst githubBridge = require('./connectors/github-bridge');\nconst { PatternLibrary, classifyPattern, inferComplexity, THRESHOLDS } = require('./patterns/library');\nconst { parseCode, astCoherencyBoost } = require('./core/parsers/ast');\nconst { sandboxExecute, sandboxGo, sandboxRust } = require('./core/sandbox');\nconst { semanticSearch, semanticSimilarity, expandQuery, identifyConcepts } = require('./core/embeddings');\nconst { CIFeedbackReporter, wrapWithTracking } = require('./ci/feedback');\nconst { vectorSimilarity, embedDocument, nearestTerms } = require('./core/vectors');\nconst { MCPServer, startMCPServer } = require('./mcp/server');\nconst { createDashboardServer, startDashboard, createRateLimiter } = require('./dashboard/server');\nconst { WebSocketServer } = require('./core/websocket');\nconst { VersionManager, semanticDiff, extractFunctions } = require('./core/versioning');\nconst { AuthManager, authMiddleware, ROLES, canWrite, canManageUsers, canRead } = require('./auth/auth');\nconst { TeamManager, TEAM_ROLES, TEAM_ROLE_HIERARCHY } = require('./auth/teams');\nconst { generateAnalytics, computeTagCloud } = require('./core/analytics');\nconst { discoverPatterns, autoSeed } = require('./ci/auto-seed');\nconst { harvest, harvestFunctions, splitFunctions } = require('./ci/harvest');\nconst { installHooks, uninstallHooks, runPreCommitCheck } = require('./ci/hooks');\nconst { covenantCheck, getCovenant, formatCovenantResult, COVENANT_PRINCIPLES } = require('./core/covenant');\nconst { reflectionLoop, formatReflectionResult, observeCoherence, reflectionScore, generateCandidates, STRATEGIES, DIMENSION_WEIGHTS } = require('./core/reflection');\nconst { DebugOracle, fingerprint: debugFingerprint, normalizeError, classifyError, computeConfidence, ERROR_CATEGORIES } = require('./core/debug-oracle');\nconst { IDEBridge, SEVERITY: IDE_SEVERITY } = require('./ide/bridge');\nconst { parseIntent, rewriteQuery, editDistance, applyIntentRanking, expandLanguages, smartSearch, INTENT_PATTERNS, CORRECTIONS, LANGUAGE_ALIASES, LANGUAGE_FAMILIES } = require('./core/search-intelligence');\nconst { CloudSyncServer, createToken, verifyToken } = require('./cloud/server');\nconst { LLMClient, LLMGenerator } = require('./core/llm-generator');\nconst { transpile: astTranspile, parseJS, tokenize: astTokenize, toSnakeCase } = require('./core/ast-transpiler');\nconst { ClaudeBridge, findClaudeCLI, extractCodeBlock: extractLLMCode } = require('./core/claude-bridge');\nconst { ModulePattern, DependencyGraph, TemplateEngine, ModuleStore, scaffold, compose } = require('./patterns/multi-file');\n\nmodule.exports = {\n  // Core\n  RemembranceOracle,\n  computeCoherencyScore,\n  detectLanguage,\n  validateCode,\n  rankEntries,\n  computeRelevance,\n  VerifiedHistoryStore,\n  SQLiteStore,\n\n  // AI Connectors\n  AIConnector,\n\n  // Provider tool definitions (give these to the AI so it can call Oracle)\n  OPENAI_TOOLS: providers.OPENAI_TOOLS,\n  ANTHROPIC_TOOLS: providers.ANTHROPIC_TOOLS,\n  GEMINI_TOOLS: providers.GEMINI_TOOLS,\n  MCP_TOOLS: providers.MCP_TOOLS,\n\n  // Provider translators\n  fromOpenAI: providers.fromOpenAI,\n  toOpenAI: providers.toOpenAI,\n  fromAnthropic: providers.fromAnthropic,\n  toAnthropic: providers.toAnthropic,\n  fromGemini: providers.fromGemini,\n  toGemini: providers.toGemini,\n  fromMCP: providers.fromMCP,\n  toMCP: providers.toMCP,\n\n  // GitHub bridge\n  parseIssueCommand: githubBridge.parseIssueCommand,\n  formatAsComment: githubBridge.formatAsComment,\n\n  // Pattern Library\n  PatternLibrary,\n  classifyPattern,\n  inferComplexity,\n  THRESHOLDS,\n\n  // AST parsing\n  parseCode,\n  astCoherencyBoost,\n\n  // Sandbox execution\n  sandboxExecute,\n  sandboxGo,\n  sandboxRust,\n\n  // Word vectors\n  vectorSimilarity,\n  embedDocument,\n  nearestTerms,\n\n  // MCP Server\n  MCPServer,\n  startMCPServer,\n\n  // Dashboard\n  createDashboardServer,\n  startDashboard,\n  createRateLimiter,\n\n  // WebSocket\n  WebSocketServer,\n\n  // Versioning\n  VersionManager,\n  semanticDiff,\n  extractFunctions,\n\n  // Auth\n  AuthManager,\n  authMiddleware,\n  ROLES,\n  canWrite,\n  canManageUsers,\n  canRead,\n\n  // Teams / Enterprise\n  TeamManager,\n  TEAM_ROLES,\n  TEAM_ROLE_HIERARCHY,\n\n  // Auto-seed\n  discoverPatterns,\n  autoSeed,\n\n  // Analytics\n  generateAnalytics,\n  computeTagCloud,\n\n  // Harvest\n  harvest,\n  harvestFunctions,\n  splitFunctions,\n\n  // Git Hooks\n  installHooks,\n  uninstallHooks,\n  runPreCommitCheck,\n\n  // Covenant\n  covenantCheck,\n  getCovenant,\n  formatCovenantResult,\n  COVENANT_PRINCIPLES,\n\n  // Reflection\n  reflectionLoop,\n  formatReflectionResult,\n  observeCoherence,\n  reflectionScore,\n  generateCandidates,\n  STRATEGIES,\n  DIMENSION_WEIGHTS,\n\n  // Semantic search\n  semanticSearch,\n  semanticSimilarity,\n  expandQuery,\n  identifyConcepts,\n\n  // CI Feedback\n  CIFeedbackReporter,\n  wrapWithTracking,\n\n  // Debug Oracle\n  DebugOracle,\n  debugFingerprint,\n  normalizeError,\n  classifyError,\n  computeConfidence,\n  ERROR_CATEGORIES,\n\n  // IDE Integration\n  IDEBridge,\n  IDE_SEVERITY,\n\n  // Search Intelligence\n  parseIntent,\n  rewriteQuery,\n  editDistance,\n  applyIntentRanking,\n  expandLanguages,\n  smartSearch,\n  INTENT_PATTERNS,\n  CORRECTIONS,\n  LANGUAGE_ALIASES,\n  LANGUAGE_FAMILIES,\n\n  // Cloud Sync\n  CloudSyncServer,\n  createToken,\n  verifyToken,\n\n  // LLM Generation\n  LLMClient,\n  LLMGenerator,\n\n  // AST Transpilation\n  astTranspile,\n  parseJS,\n  astTokenize,\n  toSnakeCase,\n\n  // Claude Bridge (Native LLM)\n  ClaudeBridge,\n  findClaudeCLI,\n  extractLLMCode,\n\n  // Multi-File Patterns\n  ModulePattern,\n  DependencyGraph,\n  TemplateEngine,\n  ModuleStore,\n  scaffold,\n  compose,\n};\n",
      "language": "javascript",
      "description": "Harvested from . — src/index.js (2 functions)",
      "tags": [
        "providers",
        "githubBridge",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "d8387ee935bad410",
      "name": "index",
      "code": "/**\n * Remembrance Oracle Toolkit — Main Entry Point\n *\n * A code memory system that:\n * - Only stores code that PROVES itself (passes validation + coherency threshold)\n * - Scores all code on coherency (syntax, completeness, consistency, test proof)\n * - Serves the most relevant, highest-scoring code to any AI that queries it\n * - Tracks historical reliability so quality improves over time\n */\n\nconst { RemembranceOracle } = require('./api/oracle');\nconst { computeCoherencyScore, detectLanguage } = require('./core/coherency');\nconst { validateCode } = require('./core/validator');\nconst { rankEntries, computeRelevance } = require('./core/relevance');\nconst { VerifiedHistoryStore } = require('./store/history');\nconst { SQLiteStore } = require('./store/sqlite');\nconst { AIConnector } = require('./connectors/connector');\nconst providers = require('./connectors/providers');\nconst githubBridge = require('./connectors/github-bridge');\nconst { PatternLibrary, classifyPattern, inferComplexity, THRESHOLDS } = require('./patterns/library');\nconst { parseCode, astCoherencyBoost } = require('./core/parsers/ast');\nconst { sandboxExecute, sandboxGo, sandboxRust } = require('./core/sandbox');\nconst { semanticSearch, semanticSimilarity, expandQuery, identifyConcepts } = require('./core/embeddings');\nconst { CIFeedbackReporter, wrapWithTracking } = require('./ci/feedback');\nconst { vectorSimilarity, embedDocument, nearestTerms } = require('./core/vectors');\nconst { MCPServer, startMCPServer } = require('./mcp/server');\nconst { createDashboardServer, startDashboard, createRateLimiter } = require('./dashboard/server');\nconst { WebSocketServer } = require('./core/websocket');\nconst { VersionManager, semanticDiff, extractFunctions } = require('./core/versioning');\nconst { AuthManager, authMiddleware, ROLES, canWrite, canManageUsers, canRead } = require('./auth/auth');\nconst { generateAnalytics, computeTagCloud } = require('./core/analytics');\nconst { discoverPatterns, autoSeed } = require('./ci/auto-seed');\nconst { harvest, harvestFunctions, splitFunctions } = require('./ci/harvest');\nconst { installHooks, uninstallHooks, runPreCommitCheck } = require('./ci/hooks');\nconst { covenantCheck, getCovenant, formatCovenantResult, COVENANT_PRINCIPLES } = require('./core/covenant');\nconst { reflectionLoop, formatReflectionResult, observeCoherence, reflectionScore, generateCandidates, STRATEGIES, DIMENSION_WEIGHTS } = require('./core/reflection');\n\nmodule.exports = {\n  // Core\n  RemembranceOracle,\n  computeCoherencyScore,\n  detectLanguage,\n  validateCode,\n  rankEntries,\n  computeRelevance,\n  VerifiedHistoryStore,\n  SQLiteStore,\n\n  // AI Connectors\n  AIConnector,\n\n  // Provider tool definitions (give these to the AI so it can call Oracle)\n  OPENAI_TOOLS: providers.OPENAI_TOOLS,\n  ANTHROPIC_TOOLS: providers.ANTHROPIC_TOOLS,\n  GEMINI_TOOLS: providers.GEMINI_TOOLS,\n  MCP_TOOLS: providers.MCP_TOOLS,\n\n  // Provider translators\n  fromOpenAI: providers.fromOpenAI,\n  toOpenAI: providers.toOpenAI,\n  fromAnthropic: providers.fromAnthropic,\n  toAnthropic: providers.toAnthropic,\n  fromGemini: providers.fromGemini,\n  toGemini: providers.toGemini,\n  fromMCP: providers.fromMCP,\n  toMCP: providers.toMCP,\n\n  // GitHub bridge\n  parseIssueCommand: githubBridge.parseIssueCommand,\n  formatAsComment: githubBridge.formatAsComment,\n\n  // Pattern Library\n  PatternLibrary,\n  classifyPattern,\n  inferComplexity,\n  THRESHOLDS,\n\n  // AST parsing\n  parseCode,\n  astCoherencyBoost,\n\n  // Sandbox execution\n  sandboxExecute,\n  sandboxGo,\n  sandboxRust,\n\n  // Word vectors\n  vectorSimilarity,\n  embedDocument,\n  nearestTerms,\n\n  // MCP Server\n  MCPServer,\n  startMCPServer,\n\n  // Dashboard\n  createDashboardServer,\n  startDashboard,\n  createRateLimiter,\n\n  // WebSocket\n  WebSocketServer,\n\n  // Versioning\n  VersionManager,\n  semanticDiff,\n  extractFunctions,\n\n  // Auth\n  AuthManager,\n  authMiddleware,\n  ROLES,\n  canWrite,\n  canManageUsers,\n  canRead,\n\n  // Auto-seed\n  discoverPatterns,\n  autoSeed,\n\n  // Analytics\n  generateAnalytics,\n  computeTagCloud,\n\n  // Harvest\n  harvest,\n  harvestFunctions,\n  splitFunctions,\n\n  // Git Hooks\n  installHooks,\n  uninstallHooks,\n  runPreCommitCheck,\n\n  // Covenant\n  covenantCheck,\n  getCovenant,\n  formatCovenantResult,\n  COVENANT_PRINCIPLES,\n\n  // Reflection\n  reflectionLoop,\n  formatReflectionResult,\n  observeCoherence,\n  reflectionScore,\n  generateCandidates,\n  STRATEGIES,\n  DIMENSION_WEIGHTS,\n\n  // Semantic search\n  semanticSearch,\n  semanticSimilarity,\n  expandQuery,\n  identifyConcepts,\n\n  // CI Feedback\n  CIFeedbackReporter,\n  wrapWithTracking,\n};\n",
      "language": "javascript",
      "description": "Harvested from . — src/index.js (2 functions)",
      "tags": [
        "providers",
        "githubBridge",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "e347c602f8bbcc0c",
      "name": "worker-ts",
      "code": "function worker() {\n    let work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "worker",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "concurrency",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "faa3dc50fc103634",
      "name": "httpGet-ts",
      "code": "function httpGet(url: any) {\n  return new Promise((resolve, reject) => {\n    http.get(url, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data, headers: res.headers }));\n    }).on('error', reject);\n  });\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "httpGet",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "75c4606f89156a40",
      "name": "connectRawWebSocket-ts",
      "code": "function connectRawWebSocket(port: any, key: any) {\n  return new Promise((resolve, reject) => {\n    const socket = net.createConnection({ port, host: '127.0.0.1' }, () => {\n      socket.write(buildUpgradeRequest(key));\n    });\n\n    let buf = '';\n    const onData = (chunk) => {\n      buf += chunk.toString();\n      const endOfHeaders = buf.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders !== -1) {\n        socket.removeListener('data', onData);\n        const headerSection = buf.slice(0, endOfHeaders);\n        const remaining = Buffer.from(buf.slice(endOfHeaders + 4), 'binary');\n        resolve({ socket, headers: headerSection, remaining });\n      }\n    };\n\n    socket.on('data', onData);\n    socket.on('error', reject);\n  });\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "connectRawWebSocket",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "io",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "31233887d8c5beea",
      "name": "add",
      "code": "function add(...nums) { return nums.reduce((a, b) => a + b, 0); }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "93c6678ca3f7ef7a",
      "name": "quickSort",
      "code": "function quickSort(arr) { if (arr.length <= 1) return arr; const pivot = arr[0]; return [...quickSort(arr.filter(x => x < pivot)), pivot, ...quickSort(arr.filter(x => x > pivot))]; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "quickSort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "24d955f06d5de8b6",
      "name": "debounce",
      "code": "function debounce(fn, d) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), d); }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/patterns.test.js",
      "tags": [
        "debounce",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "86aa555c314dd6e1",
      "name": "truncate",
      "code": "function truncate(s, len) { return s.length > len ? s.slice(0, len) + '...' : s; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "truncate",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.82
    },
    {
      "id": "35ee873a4b1e1e94",
      "name": "memoize",
      "code": "function memoize(fn) { const cache = new Map(); return (...a) => { const k = JSON.stringify(a); if (cache.has(k)) return cache.get(k); const r = fn(...a); cache.set(k, r); return r; }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "memoize",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "59e6b3238436d5f5",
      "name": "memoize",
      "code": "function memoize(fn) { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const r = fn(...args); cache.set(key, r); return r; }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "memoize",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "2ee7e1a5f50d45cf",
      "name": "debounce",
      "code": "function debounce(fn, delay) { let timer; return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), delay); }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "debounce",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "135503ad7716b565",
      "name": "memoize",
      "code": "function memoize(fn) { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn(...args); cache.set(key, result); return result; }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "memoize",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "934a7227f86ebbdb",
      "name": "throttle",
      "code": "function throttle(fn, delay) { let last = 0; return (...args) => { const now = Date.now(); if (now - last >= delay) { last = now; fn(...args); } }; }",
      "language": "javascript",
      "description": "Harvested function from . — tests/embeddings.test.js",
      "tags": [
        "throttle",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "4ed96fefc9b2afc5",
      "name": "handleIssue",
      "code": "function handleIssue() {\n  const body = process.env.ISSUE_BODY;\n  const issueNumber = process.env.ISSUE_NUMBER;\n  const repo = process.env.REPO;\n\n  if (!body || !issueNumber) {\n    console.error('Missing ISSUE_BODY or ISSUE_NUMBER');\n    process.exit(1);\n  }\n\n  const command = parseIssueCommand(body);\n  console.log('Parsed command:', JSON.stringify(command));\n\n  const result = connector.execute(command);\n  console.log('Result:', JSON.stringify(result, null, 2));\n\n  const comment = formatAsComment(result);\n\n  // Post comment back to the issue\n  if (process.env.GITHUB_TOKEN && repo) {\n    try {\n      const escaped = comment.replace(/'/g, \"'\\\\''\");\n      execSync(\n        `gh issue comment ${issueNumber} --repo ${repo} --body '${escaped}'`,\n        { stdio: 'inherit', env: { ...process.env, GH_TOKEN: process.env.GITHUB_TOKEN } }\n      );\n      console.log('Comment posted successfully');\n    } catch (err) {\n      console.error('Failed to post comment:', err.message);\n      // Still output the result\n      console.log('\\n--- RESULT ---\\n' + comment);\n    }\n  } else {\n    console.log('\\n--- RESULT ---\\n' + comment);\n  }\n}",
      "language": "javascript",
      "description": "Harvested function from . — src/connectors/github-handler.js",
      "tags": [
        "handleIssue",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.82
    },
    {
      "id": "20a254b3fd6e4bc3",
      "name": "quickSort",
      "code": "function quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}",
      "language": "javascript",
      "description": "Harvested function from . — examples/quicksort.js",
      "tags": [
        "quickSort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "39d78748917785cd",
      "name": "merge-sort-rs",
      "code": "fn merge_sort(arr: &mut Vec<i32>) {\n    let len = arr.len();\n    if len <= 1 { return; }\n    let mid = len / 2;\n    let mut left = arr[..mid].to_vec();\n    let mut right = arr[mid..].to_vec();\n    merge_sort(&mut left);\n    merge_sort(&mut right);\n    let (mut i, mut j, mut k) = (0, 0, 0);\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] { arr[k] = left[i]; i += 1; }\n        else { arr[k] = right[j]; j += 1; }\n        k += 1;\n    }\n    while i < left.len() { arr[k] = left[i]; i += 1; k += 1; }\n    while j < right.len() { arr[k] = right[j]; j += 1; k += 1; }\n}",
      "language": "rust",
      "description": "In-place merge sort for Vec<i32> — stable O(n log n)",
      "tags": [
        "sort",
        "algorithm",
        "vec",
        "stable",
        "merge-sort"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.82
    },
    {
      "id": "9109a457a7a40c0d",
      "name": "deepMerge-ts",
      "code": "function deepMerge(target: any[]) {\n  for (let i = 1; i < arguments.length; i++) {\n    let source = arguments[i];\n    for (let key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        target[key] = deepMerge(target[key] || {}, source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "deepMerge",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.81
    },
    {
      "id": "481c8ae94292d759",
      "name": "mapValues-ts",
      "code": "function mapValues(obj: any[], fn: Function) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = fn(obj[keys[i]], keys[i]);\n  }\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "mapValues",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.81
    },
    {
      "id": "164c7f355916149c",
      "name": "mapKeys-ts",
      "code": "function mapKeys(obj: any[], fn: Function) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    result[fn(keys[i], obj[keys[i]])] = obj[keys[i]];\n  }\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "mapKeys",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.81
    },
    {
      "id": "7c7689f62c295489",
      "name": "renameKeys-ts",
      "code": "function renameKeys(obj: any[], keyMap: any[]) {\n  let result = {};\n  let keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    let newKey = keyMap[keys[i]] || keys[i];\n    result[newKey] = obj[keys[i]];\n  }\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "renameKeys",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "16207f73973baf02",
      "name": "parseCookie-ts",
      "code": "function parseCookie(str: string) {\n  if (!str) return {};\n  return str.split(';').reduce(function(obj, pair) {\n    let parts = pair.trim().split('=');\n    let key = parts[0].trim();\n    obj[key] = parts.slice(1).join('=').trim();\n    return obj;\n  }, {});\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "parseCookie",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "7b7a4e16f8c6498a",
      "name": "deepClone-ts",
      "code": "function deepClone(obj: any[]) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) {\n    cloned[key] = deepClone(obj[key]);\n  }\n  return cloned;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "deepClone",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "f72abd3c95e03406",
      "name": "groupBy-ts",
      "code": "function groupBy(arr: any, keyFn: any) {\n  const groups = {};\n  for (const item of arr) {\n    const key = typeof keyFn === 'function' ? keyFn(item) : item[keyFn];\n    (groups[key] = groups[key] || []).push(item);\n  }\n  return groups;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "groupBy",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "c3d5954810d40c20",
      "name": "captureKeys-ts",
      "code": "function captureKeys() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/covenant.test.js (TypeScript variant)",
      "tags": [
        "captureKeys",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "b860dfef6b3e54ee",
      "name": "processData-ts",
      "code": "function processData() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "processData",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "603a96b0c5d3ea31",
      "name": "saveData-ts",
      "code": "function saveData() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "saveData",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "98a58ccf80d7649d",
      "name": "getData-ts",
      "code": "function getData() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "getData",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "53b3a53c9ccf68d8",
      "name": "process_data-ts",
      "code": "function process_data() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "process_data",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "930aed7bb130e312",
      "name": "save_data-ts",
      "code": "function save_data() {}",
      "language": "typescript",
      "description": "Harvested function from . — tests/reflection.test.js (TypeScript variant)",
      "tags": [
        "save_data",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.81
    },
    {
      "id": "cd7b710aa28f297d",
      "name": "parseQueryString-ts",
      "code": "function parseQueryString(qs: any) {\n  if (!qs || qs === '?') return {};\n  return qs.replace(/^\\\\?/, '').split('&').reduce(function(obj, pair) {\n    let parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '');\n    return obj;\n  }, {});\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "parseQueryString",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.81
    },
    {
      "id": "2d032e6753eb1ee3",
      "name": "getTopTags-ts",
      "code": "function getTopTags(entries: any, limit: number) {\n  const counts = {};\n  for (const e of entries) {\n    for (const tag of e.tags) {\n      const t = tag.toLowerCase();\n      counts[t] = (counts[t] || 0) + 1;\n    }\n  }\n  return Object.entries(counts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, limit)\n    .map(([tag, count]) => ({ tag, count }));\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/store/sqlite.js (TypeScript variant)",
      "tags": [
        "getTopTags",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.81
    },
    {
      "id": "d541216a773c733c",
      "name": "countBy-ts",
      "code": "function countBy(items: any, key: any) {\n  const counts = {};\n  for (const item of items) {\n    const val = item[key] || 'unknown';\n    counts[val] = (counts[val] || 0) + 1;\n  }\n  return counts;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/store/sqlite.js (TypeScript variant)",
      "tags": [
        "countBy",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "39d0b6c0b370115a",
      "name": "lru-cache-go",
      "code": "type LRUCache struct {\n\tcapacity int\n\titems    map[string]*node\n\thead     *node\n\ttail     *node\n}\n\ntype node struct {\n\tkey        string\n\tvalue      interface{}\n\tprev, next *node\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n\thead := &node{}\n\ttail := &node{}\n\thead.next = tail\n\ttail.prev = head\n\treturn &LRUCache{capacity: capacity, items: make(map[string]*node), head: head, tail: tail}\n}\n\nfunc (c *LRUCache) Get(key string) (interface{}, bool) {\n\tif n, ok := c.items[key]; ok {\n\t\tc.moveToFront(n)\n\t\treturn n.value, true\n\t}\n\treturn nil, false\n}\n\nfunc (c *LRUCache) Put(key string, value interface{}) {\n\tif n, ok := c.items[key]; ok {\n\t\tn.value = value\n\t\tc.moveToFront(n)\n\t\treturn\n\t}\n\tn := &node{key: key, value: value}\n\tc.items[key] = n\n\tc.addToFront(n)\n\tif len(c.items) > c.capacity {\n\t\tback := c.tail.prev\n\t\tc.remove(back)\n\t\tdelete(c.items, back.key)\n\t}\n}\n\nfunc (c *LRUCache) moveToFront(n *node) { c.remove(n); c.addToFront(n) }\nfunc (c *LRUCache) addToFront(n *node) { n.prev = c.head; n.next = c.head.next; c.head.next.prev = n; c.head.next = n }\nfunc (c *LRUCache) remove(n *node) { n.prev.next = n.next; n.next.prev = n.prev }",
      "language": "go",
      "description": "LRU cache with O(1) get/put using doubly-linked list + hashmap",
      "tags": [
        "data-structure",
        "cache",
        "lru",
        "map",
        "eviction"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 0.81
    },
    {
      "id": "ac4427bf40380669",
      "name": "_assert-ts",
      "code": "const _assert = (cond, msg) => { if (!cond) throw new Error(msg); }",
      "language": "typescript",
      "description": "Harvested function from . — examples/quicksort.test.js (TypeScript variant)",
      "tags": [
        "_assert",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.8
    },
    {
      "id": "90bd27aee2939d1c",
      "name": "double-ts",
      "code": "const double = (n) => {\n  return n * 2;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "double",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.8
    },
    {
      "id": "7e6d988d372ec81a",
      "name": "triple-ts",
      "code": "const triple = (n) => {\n  return n * 3;\n}",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "triple",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.8
    },
    {
      "id": "32a0aecec674b9f0",
      "name": "onData-ts",
      "code": "const onData = (chunk) => {\n      buf += chunk.toString();\n      const endOfHeaders = buf.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders !== -1) {\n        socket.removeListener('data', onData);\n        const headerSection = buf.slice(0, endOfHeaders);\n        const remaining = Buffer.from(buf.slice(endOfHeaders + 4), 'binary');\n        resolve({ socket, headers: headerSection, remaining });\n      }\n    }",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "onData",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.8
    },
    {
      "id": "427c895a2c9e22c0",
      "name": "check-ts",
      "code": "const check = () => {\n        if (wss.clients.size >= count) resolve();\n        else setTimeout(check, 20);\n      }",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "check",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.8
    },
    {
      "id": "6dc02044e44a9da8",
      "name": "handler-ts",
      "code": "const handler = (chunk) => {\n        data.push(chunk);\n        clientSocket.removeListener('data', handler);\n        resolve();\n      }",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "handler",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.8
    },
    {
      "id": "72f05bf619dd9103",
      "name": "sandbox.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { sandboxExecute, sandboxJS, sandboxPython, sandboxGo, sandboxRust } = require('../src/core/sandbox');\n\ndescribe('sandboxJS', () => {\n  it('runs passing JS tests in sandbox', () => {\n    const result = sandboxJS(\n      'function add(a, b) { return a + b; }',\n      'if (add(2, 3) !== 5) throw new Error(\"FAIL\");'\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('catches failing JS tests', () => {\n    const result = sandboxJS(\n      'function add(a, b) { return a - b; }',\n      'if (add(2, 3) !== 5) throw new Error(\"FAIL\");'\n    );\n    assert.equal(result.passed, false);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('blocks dangerous modules', () => {\n    const result = sandboxJS(\n      '',\n      'const cp = require(\"child_process\"); cp.execSync(\"whoami\");'\n    );\n    assert.equal(result.passed, false);\n    assert.ok(result.output.includes('blocked'));\n  });\n\n  it('enforces timeout', () => {\n    const result = sandboxJS(\n      '',\n      'while(true) {}',\n      { timeout: 1000 }\n    );\n    assert.equal(result.passed, false);\n    assert.equal(result.timedOut, true);\n  });\n});\n\ndescribe('sandboxPython', () => {\n  it('runs passing Python tests in sandbox', () => {\n    const result = sandboxPython(\n      'def add(a, b):\\n    return a + b',\n      'assert add(2, 3) == 5, \"FAIL\"'\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('catches failing Python tests', () => {\n    const result = sandboxPython(\n      'def add(a, b):\\n    return a - b',\n      'assert add(2, 3) == 5, \"FAIL\"'\n    );\n    assert.equal(result.passed, false);\n  });\n});\n\ndescribe('sandboxExecute', () => {\n  it('dispatches to JS sandbox', () => {\n    const result = sandboxExecute(\n      'function x() { return 42; }',\n      'if (x() !== 42) throw new Error(\"FAIL\");',\n      'javascript'\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('dispatches to Python sandbox', () => {\n    const result = sandboxExecute(\n      'def x():\\n    return 42',\n      'assert x() == 42',\n      'python'\n    );\n    assert.equal(result.passed, true);\n  });\n\n  it('dispatches to Go sandbox', () => {\n    const result = sandboxExecute(\n      `package sandbox\n\nfunc Add(a, b int) int { return a + b }`,\n      `package sandbox\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n\tif Add(2, 3) != 5 { t.Fatal(\"FAIL\") }\n}`,\n      'go'\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('dispatches to Rust sandbox', () => {\n    const result = sandboxExecute(\n      'pub fn add(a: i32, b: i32) -> i32 { a + b }',\n      `    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }`,\n      'rust'\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('returns null for unsupported languages', () => {\n    const result = sandboxExecute('code', 'test', 'haskell');\n    assert.equal(result.passed, null);\n    assert.equal(result.sandboxed, false);\n  });\n});\n\ndescribe('sandboxGo', () => {\n  it('runs passing Go tests', () => {\n    const result = sandboxGo(\n      `package sandbox\n\nfunc Multiply(a, b int) int { return a * b }`,\n      `package sandbox\n\nimport \"testing\"\n\nfunc TestMultiply(t *testing.T) {\n\tif Multiply(3, 4) != 12 { t.Fatal(\"FAIL\") }\n\tif Multiply(0, 5) != 0 { t.Fatal(\"zero\") }\n}`,\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('catches failing Go tests', () => {\n    const result = sandboxGo(\n      `package sandbox\n\nfunc Multiply(a, b int) int { return a - b }`,\n      `package sandbox\n\nimport \"testing\"\n\nfunc TestMultiply(t *testing.T) {\n\tif Multiply(3, 4) != 12 { t.Fatal(\"FAIL\") }\n}`,\n    );\n    assert.equal(result.passed, false);\n    assert.equal(result.sandboxed, true);\n  });\n});\n\ndescribe('sandboxRust', () => {\n  it('runs passing Rust tests', () => {\n    const result = sandboxRust(\n      'pub fn multiply(a: i32, b: i32) -> i32 { a * b }',\n      `    use super::*;\n\n    #[test]\n    fn test_multiply() {\n        assert_eq!(multiply(3, 4), 12);\n        assert_eq!(multiply(0, 5), 0);\n    }`,\n    );\n    assert.equal(result.passed, true);\n    assert.equal(result.sandboxed, true);\n  });\n\n  it('catches failing Rust tests', () => {\n    const result = sandboxRust(\n      'pub fn multiply(a: i32, b: i32) -> i32 { a - b }',\n      `    use super::*;\n\n    #[test]\n    fn test_multiply() {\n        assert_eq!(multiply(3, 4), 12);\n    }`,\n    );\n    assert.equal(result.passed, false);\n    assert.equal(result.sandboxed, true);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/sandbox.test.js (5 functions)",
      "tags": [
        "assert",
        "result",
        "add",
        "cp",
        "x",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.795
    },
    {
      "id": "1efa4aaaabd47ce3",
      "name": "handleIssue-ts",
      "code": "function handleIssue() {\n  const body = process.env.ISSUE_BODY;\n  const issueNumber = process.env.ISSUE_NUMBER;\n  const repo = process.env.REPO;\n\n  if (!body || !issueNumber) {\n    console.error('Missing ISSUE_BODY or ISSUE_NUMBER');\n    process.exit(1);\n  }\n\n  const command = parseIssueCommand(body);\n  console.log('Parsed command:', JSON.stringify(command));\n\n  const result = connector.execute(command);\n  console.log('Result:', JSON.stringify(result, null, 2));\n\n  const comment = formatAsComment(result);\n\n  // Post comment back to the issue\n  if (process.env.GITHUB_TOKEN && repo) {\n    try {\n      const escaped = comment.replace(/'/g, \"'\\\\''\");\n      execSync(\n        `gh issue comment ${issueNumber} --repo ${repo} --body '${escaped}'`,\n        { stdio: 'inherit', env: { ...process.env, GH_TOKEN: process.env.GITHUB_TOKEN } }\n      );\n      console.log('Comment posted successfully');\n    } catch (err) {\n      console.error('Failed to post comment:', err.message);\n      // Still output the result\n      console.log('\\n--- RESULT ---\\n' + comment);\n    }\n  } else {\n    console.log('\\n--- RESULT ---\\n' + comment);\n  }\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/connectors/github-handler.js (TypeScript variant)",
      "tags": [
        "handleIssue",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "28984174c1b3cad7",
      "name": "flattenDeep-ts",
      "code": "function flattenDeep(arr: any) {\n  const result = [];\n  const stack = [...arr];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    if (Array.isArray(item)) {\n      stack.push(...item);\n    } else {\n      result.unshift(item);\n    }\n  }\n  return result;\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "flattenDeep",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "composite",
      "coherency": 0.79
    },
    {
      "id": "7e2d235a762db4c0",
      "name": "websocket.test",
      "code": "const { describe, it, after } = require('node:test');\nconst assert = require('node:assert/strict');\nconst http = require('http');\nconst net = require('net');\nconst crypto = require('crypto');\nconst { WebSocketServer } = require('../src/core/websocket');\n\nconst GUID = '258EAFA5-E914-47DA-95CA-5AB5DC11AD48';\n\n/**\n * Build a raw HTTP upgrade request for the WebSocket handshake.\n */\nfunction buildUpgradeRequest(key, path = '/') {\n  return (\n    `GET ${path} HTTP/1.1\\r\\n` +\n    `Host: localhost\\r\\n` +\n    `Upgrade: websocket\\r\\n` +\n    `Connection: Upgrade\\r\\n` +\n    `Sec-WebSocket-Key: ${key}\\r\\n` +\n    `Sec-WebSocket-Version: 13\\r\\n` +\n    `\\r\\n`\n  );\n}\n\n/**\n * Encode a masked WebSocket text frame (client-to-server must be masked per RFC 6455).\n */\nfunction encodeTextFrame(text) {\n  const payload = Buffer.from(text, 'utf8');\n  const mask = crypto.randomBytes(4);\n  const masked = Buffer.from(payload);\n  for (let i = 0; i < masked.length; i++) {\n    masked[i] ^= mask[i & 3];\n  }\n\n  let header;\n  if (payload.length < 126) {\n    header = Buffer.allocUnsafe(2);\n    header[0] = 0x81; // FIN + text opcode\n    header[1] = 0x80 | payload.length; // masked bit + length\n  } else {\n    header = Buffer.allocUnsafe(4);\n    header[0] = 0x81;\n    header[1] = 0x80 | 126;\n    header.writeUInt16BE(payload.length, 2);\n  }\n\n  return Buffer.concat([header, mask, masked]);\n}\n\n/**\n * Send a simple HTTP GET to the server and collect the response.\n */\nfunction httpGet(url) {\n  return new Promise((resolve, reject) => {\n    http.get(url, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => resolve({ status: res.statusCode, data, headers: res.headers }));\n    }).on('error', reject);\n  });\n}\n\n/**\n * Connect a raw TCP socket, send an upgrade request, and return\n * the socket plus the parsed handshake response.\n */\nfunction connectRawWebSocket(port, key) {\n  return new Promise((resolve, reject) => {\n    const socket = net.createConnection({ port, host: '127.0.0.1' }, () => {\n      socket.write(buildUpgradeRequest(key));\n    });\n\n    let buf = '';\n    const onData = (chunk) => {\n      buf += chunk.toString();\n      const endOfHeaders = buf.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders !== -1) {\n        socket.removeListener('data', onData);\n        const headerSection = buf.slice(0, endOfHeaders);\n        const remaining = Buffer.from(buf.slice(endOfHeaders + 4), 'binary');\n        resolve({ socket, headers: headerSection, remaining });\n      }\n    };\n\n    socket.on('data', onData);\n    socket.on('error', reject);\n  });\n}\n\ndescribe('WebSocket handshake crypto', { timeout: 10000 }, () => {\n  it('computes correct Sec-WebSocket-Accept per RFC 6455', () => {\n    // RFC 6455 Section 4.2.2 example key\n    const key = 'dGhlIHNhbXBsZSBub25jZQ==';\n    const expected = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    // Verified with both Node.js and Python SHA-1\n    assert.equal(expected, 'QTEF5tdGszPlUvhxOpHPeU89T0U=');\n  });\n\n  it('produces different accepts for different keys', () => {\n    const key1 = crypto.randomBytes(16).toString('base64');\n    const key2 = crypto.randomBytes(16).toString('base64');\n    const accept1 = crypto.createHash('sha1').update(key1 + GUID).digest('base64');\n    const accept2 = crypto.createHash('sha1').update(key2 + GUID).digest('base64');\n    assert.notEqual(accept1, accept2);\n  });\n});\n\ndescribe('WebSocketServer creation and lifecycle', { timeout: 10000 }, () => {\n  let httpServer;\n  let wss;\n  const sockets = [];\n\n  after(() => {\n    for (const s of sockets) {\n      if (!s.destroyed) s.destroy();\n    }\n    if (httpServer) httpServer.close();\n  });\n\n  it('can be created from an http server', () => {\n    httpServer = http.createServer((req, res) => {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('OK');\n    });\n    wss = new WebSocketServer(httpServer);\n\n    assert.ok(wss instanceof WebSocketServer);\n    assert.ok(wss.clients instanceof Set);\n    assert.equal(wss.clients.size, 0);\n  });\n\n  it('HTTP server still works for non-upgrade requests', async () => {\n    await new Promise(resolve => httpServer.listen(0, '127.0.0.1', resolve));\n    const port = httpServer.address().port;\n\n    const res = await httpGet(`http://127.0.0.1:${port}/`);\n    assert.equal(res.status, 200);\n    assert.equal(res.data, 'OK');\n  });\n\n  it('completes WebSocket handshake with correct Sec-WebSocket-Accept', async () => {\n    const port = httpServer.address().port;\n    const key = crypto.randomBytes(16).toString('base64');\n    const expectedAccept = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const { socket, headers } = await connectRawWebSocket(port, key);\n    sockets.push(socket);\n\n    assert.ok(headers.includes('HTTP/1.1 101 Switching Protocols'));\n    assert.ok(headers.includes('Upgrade: websocket'));\n    assert.ok(headers.includes('Connection: Upgrade'));\n    assert.ok(headers.includes(`Sec-WebSocket-Accept: ${expectedAccept}`));\n  });\n\n  it('tracks client in the clients Set on connection', async () => {\n    // The previous test connected one client; verify tracking\n    assert.ok(wss.clients.size >= 1, 'clients Set should contain at least 1 client');\n  });\n});\n\ndescribe('WebSocket frame encoding', { timeout: 10000 }, () => {\n  it('_sendFrame produces valid small text frame', () => {\n    const chunks = [];\n    const fakeSocket = {\n      destroyed: false,\n      write(buf) { chunks.push(Buffer.from(buf)); },\n    };\n\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n    wss._sendFrame(fakeSocket, 0x1, 'hello');\n\n    const frame = Buffer.concat(chunks);\n    // First byte: FIN (0x80) | text opcode (0x01) = 0x81\n    assert.equal(frame[0], 0x81);\n    // Second byte: unmasked, length 5\n    assert.equal(frame[1], 5);\n    // Payload\n    assert.equal(frame.subarray(2).toString('utf8'), 'hello');\n\n    httpServer.close();\n  });\n\n  it('_sendFrame produces valid medium frame (126-byte extended length)', () => {\n    const chunks = [];\n    const fakeSocket = {\n      destroyed: false,\n      write(buf) { chunks.push(Buffer.from(buf)); },\n    };\n\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n    const payload = 'A'.repeat(200);\n    wss._sendFrame(fakeSocket, 0x1, payload);\n\n    const frame = Buffer.concat(chunks);\n    assert.equal(frame[0], 0x81);\n    assert.equal(frame[1], 126);\n    assert.equal(frame.readUInt16BE(2), 200);\n    assert.equal(frame.subarray(4).toString('utf8'), payload);\n\n    httpServer.close();\n  });\n\n  it('_sendFrame skips destroyed sockets', () => {\n    const chunks = [];\n    const fakeSocket = {\n      destroyed: true,\n      write(buf) { chunks.push(buf); },\n    };\n\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n    wss._sendFrame(fakeSocket, 0x1, 'test');\n\n    assert.equal(chunks.length, 0, 'should not write to destroyed socket');\n\n    httpServer.close();\n  });\n});\n\ndescribe('WebSocket frame decoding', { timeout: 10000 }, () => {\n  it('handles masked text frames and emits message', () => {\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n\n    const received = [];\n    wss.on('message', (msg) => received.push(msg));\n\n    // Build a masked text frame for \"hi\"\n    const text = 'hi';\n    const payload = Buffer.from(text, 'utf8');\n    const mask = Buffer.from([0x37, 0xfa, 0x21, 0x3d]);\n    const masked = Buffer.from(payload);\n    for (let i = 0; i < masked.length; i++) {\n      masked[i] ^= mask[i & 3];\n    }\n\n    const frame = Buffer.alloc(2 + 4 + payload.length);\n    frame[0] = 0x81; // FIN + text\n    frame[1] = 0x80 | payload.length; // masked + length\n    mask.copy(frame, 2);\n    masked.copy(frame, 6);\n\n    const fakeSocket = { destroyed: false, end() {}, destroy() {} };\n    const remaining = wss._processBuffer(frame, fakeSocket);\n\n    assert.equal(received.length, 1);\n    assert.equal(received[0], 'hi');\n    assert.equal(remaining.length, 0);\n\n    httpServer.close();\n  });\n\n  it('handles unmasked text frames', () => {\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n\n    const received = [];\n    wss.on('message', (msg) => received.push(msg));\n\n    const text = 'world';\n    const payload = Buffer.from(text, 'utf8');\n    const frame = Buffer.alloc(2 + payload.length);\n    frame[0] = 0x81;\n    frame[1] = payload.length; // no mask bit\n    payload.copy(frame, 2);\n\n    const fakeSocket = { destroyed: false, end() {}, destroy() {} };\n    wss._processBuffer(frame, fakeSocket);\n\n    assert.equal(received.length, 1);\n    assert.equal(received[0], 'world');\n\n    httpServer.close();\n  });\n\n  it('returns partial buffer when frame is incomplete', () => {\n    const httpServer = http.createServer();\n    const wss = new WebSocketServer(httpServer);\n\n    // A frame header claiming 100 bytes, but only 5 bytes provided\n    const partial = Buffer.alloc(5);\n    partial[0] = 0x81;\n    partial[1] = 100;\n    partial[2] = 0x41;\n    partial[3] = 0x42;\n    partial[4] = 0x43;\n\n    const fakeSocket = { destroyed: false, end() {}, destroy() {} };\n    const remaining = wss._processBuffer(partial, fakeSocket);\n\n    assert.equal(remaining.length, 5, 'incomplete frame should be returned as-is');\n\n    httpServer.close();\n  });\n});\n\ndescribe('WebSocket broadcast and messaging', { timeout: 10000 }, () => {\n  let httpServer;\n  let wss;\n  let port;\n  const clientSockets = [];\n\n  after(() => {\n    for (const s of clientSockets) {\n      if (!s.destroyed) s.destroy();\n    }\n    if (httpServer) httpServer.close();\n  });\n\n  it('broadcast sends to all connected clients', async () => {\n    httpServer = http.createServer();\n    wss = new WebSocketServer(httpServer);\n\n    await new Promise(resolve => httpServer.listen(0, '127.0.0.1', resolve));\n    port = httpServer.address().port;\n\n    // Wait for server-side connection tracking before broadcasting\n    const connectionPromise = (count) => new Promise((resolve) => {\n      const check = () => {\n        if (wss.clients.size >= count) resolve();\n        else setTimeout(check, 20);\n      };\n      check();\n    });\n\n    // Connect two raw WebSocket clients\n    const key1 = crypto.randomBytes(16).toString('base64');\n    const key2 = crypto.randomBytes(16).toString('base64');\n\n    const conn1 = await connectRawWebSocket(port, key1);\n    clientSockets.push(conn1.socket);\n    await connectionPromise(1);\n\n    const conn2 = await connectRawWebSocket(port, key2);\n    clientSockets.push(conn2.socket);\n    await connectionPromise(2);\n\n    assert.equal(wss.clients.size, 2, 'should have 2 connected clients');\n\n    // Collect data from both client sockets\n    const data1 = [];\n    const data2 = [];\n    conn1.socket.on('data', (chunk) => data1.push(chunk));\n    conn2.socket.on('data', (chunk) => data2.push(chunk));\n\n    // Broadcast a message\n    wss.broadcast('ping-all');\n\n    // Wait a bit for data to arrive\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Parse the received WebSocket frames — expect unmasked text frame with \"ping-all\"\n    const frame1 = Buffer.concat(data1);\n    const frame2 = Buffer.concat(data2);\n\n    assert.ok(frame1.length > 0, 'client 1 should receive data');\n    assert.ok(frame2.length > 0, 'client 2 should receive data');\n\n    // Verify frame structure: 0x81 (FIN+text), length, then payload\n    assert.equal(frame1[0], 0x81);\n    const len1 = frame1[1] & 0x7F;\n    assert.equal(frame1.subarray(2, 2 + len1).toString('utf8'), 'ping-all');\n\n    assert.equal(frame2[0], 0x81);\n    const len2 = frame2[1] & 0x7F;\n    assert.equal(frame2.subarray(2, 2 + len2).toString('utf8'), 'ping-all');\n  });\n\n  it('send delivers a message to a single client', async () => {\n    // Use the already-connected clients; pick the first one\n    const [firstClient] = wss.clients;\n    assert.ok(firstClient, 'should have at least one client');\n\n    const data = [];\n    // Temporarily capture data; we need to set up listener before sending\n    const clientSocket = clientSockets[0];\n    const dataPromise = new Promise((resolve) => {\n      const handler = (chunk) => {\n        data.push(chunk);\n        clientSocket.removeListener('data', handler);\n        resolve();\n      };\n      clientSocket.on('data', handler);\n    });\n\n    wss.send(firstClient, 'just-you');\n    await dataPromise;\n\n    const frame = Buffer.concat(data);\n    assert.equal(frame[0], 0x81);\n    const len = frame[1] & 0x7F;\n    assert.equal(frame.subarray(2, 2 + len).toString('utf8'), 'just-you');\n  });\n});\n\ndescribe('WebSocket connection tracking', { timeout: 10000 }, () => {\n  let httpServer;\n  let wss;\n  let port;\n\n  after(() => {\n    if (httpServer) httpServer.close();\n  });\n\n  it('adds client on connection and removes on close', async () => {\n    httpServer = http.createServer();\n    wss = new WebSocketServer(httpServer);\n\n    await new Promise(resolve => httpServer.listen(0, '127.0.0.1', resolve));\n    port = httpServer.address().port;\n\n    assert.equal(wss.clients.size, 0, 'starts with no clients');\n\n    const closeEvents = [];\n    wss.on('close', (socket) => closeEvents.push(socket));\n\n    const key = crypto.randomBytes(16).toString('base64');\n    const { socket } = await connectRawWebSocket(port, key);\n\n    // Wait for server to register the client\n    await new Promise(resolve => setTimeout(resolve, 50));\n    assert.equal(wss.clients.size, 1, 'one client connected');\n\n    // Send a close frame to trigger proper close\n    // Close frame: FIN + opcode 0x8, masked, 0 payload\n    const maskKey = crypto.randomBytes(4);\n    const closeFrame = Buffer.alloc(6);\n    closeFrame[0] = 0x88; // FIN + close opcode\n    closeFrame[1] = 0x80; // MASK bit, 0 length\n    maskKey.copy(closeFrame, 2);\n    socket.write(closeFrame);\n\n    // Wait for close event propagation\n    await new Promise(resolve => setTimeout(resolve, 200));\n    assert.equal(wss.clients.size, 0, 'client removed after disconnect');\n    assert.ok(closeEvents.length >= 1, 'close event emitted at least once');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/websocket.test.js (56 functions)",
      "tags": [
        "assert",
        "http",
        "net",
        "crypto",
        "GUID",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "31aea888e0406c3d",
      "name": "recycler.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst { PatternRecycler, APPROACH_SWAPS } = require('../src/core/recycler');\nconst { RemembranceOracle } = require('../src/api/oracle');\n\nfunction makeTempDir() {\n  const dir = path.join(os.tmpdir(), `recycler-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}\n\ndescribe('PatternRecycler', () => {\n  let oracle, recycler, tmpDir;\n\n  beforeEach(() => {\n    tmpDir = makeTempDir();\n    oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false, generateVariants: false, autoGrow: false });\n    recycler = new PatternRecycler(oracle, { maxHealAttempts: 2, maxRefineLoops: 2, generateVariants: false });\n  });\n\n  describe('capture', () => {\n    it('captures a failed pattern', () => {\n      const entry = recycler.capture(\n        { name: 'test-fail', code: 'broken', language: 'javascript' },\n        'test failure',\n        null\n      );\n\n      assert.equal(entry.status, 'pending');\n      assert.equal(entry.pattern.name, 'test-fail');\n      assert.equal(entry.failureReason, 'test failure');\n      assert.equal(recycler.stats.captured, 1);\n    });\n\n    it('getCaptured returns all failures', () => {\n      recycler.capture({ name: 'a', code: 'x', language: 'javascript' }, 'reason a');\n      recycler.capture({ name: 'b', code: 'y', language: 'python' }, 'reason b');\n\n      assert.equal(recycler.getCaptured().length, 2);\n      assert.equal(recycler.getCaptured({ language: 'python' }).length, 1);\n      assert.equal(recycler.getCaptured({ status: 'pending' }).length, 2);\n    });\n  });\n\n  describe('heal', () => {\n    it('heals a pattern with fixable style issues', () => {\n      // Code that's valid but has low coherency due to style\n      const messyCode = `function   add(a,b){\nvar result=a+b;\nreturn result\n}`;\n      const testCode = 'if (add(2, 3) !== 5) throw new Error(\"fail\");';\n\n      recycler.capture(\n        { name: 'messy-add', code: messyCode, testCode, language: 'javascript', description: 'add', tags: ['math'], patternType: 'utility' },\n        'low coherency'\n      );\n\n      const report = recycler.recycleFailed();\n      // Reflection should clean it up (or it was already valid enough)\n      assert.ok(report.processed > 0);\n    });\n\n    it('marks exhausted when healing fails repeatedly', () => {\n      // Truly broken code that reflection can't fix\n      recycler.capture(\n        { name: 'broken', code: '}{}{}{', language: 'javascript', description: 'broken', tags: [], patternType: 'utility' },\n        'syntax error'\n      );\n\n      const report = recycler.recycleFailed();\n      assert.equal(report.exhausted, 1);\n      const captured = recycler.getCaptured({ status: 'exhausted' });\n      assert.equal(captured.length, 1);\n    });\n  });\n\n  describe('processSeeds', () => {\n    it('registers valid seeds', () => {\n      const seeds = [\n        {\n          name: 'test-add',\n          code: 'function add(a, b) { return a + b; }',\n          testCode: 'if (add(1, 2) !== 3) throw new Error(\"fail\");',\n          language: 'javascript',\n          description: 'Add two numbers',\n          tags: ['math'],\n          patternType: 'utility',\n        },\n        {\n          name: 'test-sub',\n          code: 'function sub(a, b) { return a - b; }',\n          testCode: 'if (sub(5, 3) !== 2) throw new Error(\"fail\");',\n          language: 'javascript',\n          description: 'Subtract two numbers',\n          tags: ['math'],\n          patternType: 'utility',\n        },\n      ];\n\n      const report = recycler.processSeeds(seeds, { depth: 0 });\n      assert.equal(report.registered, 2);\n      assert.equal(report.failed, 0);\n      assert.equal(report.waves.length, 1);\n      assert.ok(report.total >= 2);\n    });\n\n    it('captures and recycles failures', () => {\n      const seeds = [\n        {\n          name: 'good-one',\n          code: 'function square(n) { return n * n; }',\n          testCode: 'if (square(3) !== 9) throw new Error(\"fail\");',\n          language: 'javascript',\n          description: 'Square a number',\n          tags: ['math'],\n          patternType: 'utility',\n        },\n        {\n          name: 'bad-test',\n          code: 'function broken(n) { return n + 1; }',\n          testCode: 'if (broken(1) !== 999) throw new Error(\"wrong!\");',\n          language: 'javascript',\n          description: 'Intentionally failing test',\n          tags: ['broken'],\n          patternType: 'utility',\n        },\n      ];\n\n      const report = recycler.processSeeds(seeds, { depth: 0 });\n      assert.equal(report.registered, 1);\n      assert.equal(report.failed, 1);\n    });\n\n    it('skips already-registered seeds', () => {\n      const seed = {\n        name: 'unique-fn',\n        code: 'function uniqueFn(x) { return x; }',\n        testCode: 'if (uniqueFn(42) !== 42) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Identity function',\n        tags: ['utility'],\n        patternType: 'utility',\n      };\n\n      // Register first\n      oracle.registerPattern(seed);\n\n      // Process same seed again\n      const report = recycler.processSeeds([seed], { depth: 0 });\n      assert.equal(report.registered, 1); // counted as registered (already exists)\n      assert.equal(report.failed, 0);\n    });\n  });\n\n  describe('TypeScript variants', () => {\n    it('generates TS variant from JS pattern', () => {\n      const tsRecycler = new PatternRecycler(oracle, { generateVariants: true, variantLanguages: ['typescript'] });\n      const seed = {\n        name: 'double',\n        code: 'function double(n) { return n * 2; }',\n        testCode: 'if (double(5) !== 10) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Double a number',\n        tags: ['math'],\n        patternType: 'utility',\n      };\n\n      const report = tsRecycler.processSeeds([seed], { depth: 1 });\n      assert.equal(report.registered, 1);\n      assert.ok(report.variants.spawned >= 1);\n\n      // Check that the TS variant exists\n      const all = oracle.patterns.getAll();\n      const tsVariant = all.find(p => p.name === 'double-ts');\n      if (tsVariant) {\n        assert.equal(tsVariant.language, 'typescript');\n        assert.ok(tsVariant.code.includes(':'));  // Has type annotations\n      }\n    });\n  });\n\n  describe('Python variants', () => {\n    it('generates Python variant from simple JS pattern', () => {\n      const pyRecycler = new PatternRecycler(oracle, { generateVariants: true, variantLanguages: ['python'] });\n      const seed = {\n        name: 'triple',\n        code: 'function triple(n) {\\n  return n * 3;\\n}',\n        testCode: 'if (triple(4) !== 12) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Triple a number',\n        tags: ['math'],\n        patternType: 'utility',\n      };\n\n      const report = pyRecycler.processSeeds([seed], { depth: 1 });\n      assert.equal(report.registered, 1);\n\n      const all = oracle.patterns.getAll();\n      const pyVariant = all.find(p => p.name === 'triple-py');\n      if (pyVariant) {\n        assert.equal(pyVariant.language, 'python');\n        assert.ok(pyVariant.code.includes('def triple'));\n      }\n    });\n\n    it('skips complex patterns that cannot transpile to Python', () => {\n      const pyRecycler = new PatternRecycler(oracle, { generateVariants: true, variantLanguages: ['python'] });\n      const seed = {\n        name: 'regex-thing',\n        code: 'function clean(s) {\\n  return s.replace(/[^a-z]/g, \"\");\\n}',\n        testCode: 'if (clean(\"a1b2\") !== \"ab\") throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Clean string with regex',\n        tags: ['string'],\n        patternType: 'utility',\n      };\n\n      const report = pyRecycler.processSeeds([seed], { depth: 1 });\n      // Should register the JS seed but NOT create a Python variant (regex)\n      assert.equal(report.registered, 1);\n      const all = oracle.patterns.getAll();\n      const pyVariant = all.find(p => p.name === 'regex-thing-py');\n      assert.equal(pyVariant, undefined);\n    });\n  });\n\n  describe('report formatting', () => {\n    it('produces a readable report', () => {\n      const report = {\n        registered: 10, failed: 2, recycled: 1,\n        variants: { spawned: 5, accepted: 3 },\n        approaches: { spawned: 2, accepted: 1 },\n        depth: 2, total: 14,\n        waves: [\n          { wave: 0, label: 'seeds', registered: 10, failed: 2, healed: 1, variants: 0 },\n          { wave: 1, label: 'variants-depth-1', registered: 3, failed: 2, healed: 0, variants: 5 },\n        ],\n      };\n\n      const text = PatternRecycler.formatReport(report);\n      assert.ok(text.includes('Pattern Recycler Report'));\n      assert.ok(text.includes('Registered:         10'));\n      assert.ok(text.includes('Variants spawned:     5'));\n      assert.ok(text.includes('Total in library:     14'));\n      assert.ok(text.includes('[0] seeds'));\n      assert.ok(text.includes('[1] variants-depth-1'));\n    });\n  });\n\n  describe('approach swaps', () => {\n    it('detects recursive pattern', () => {\n      const recursiveSwap = APPROACH_SWAPS.find(s => s.from === 'recursive');\n      assert.ok(recursiveSwap);\n      assert.ok(recursiveSwap.detect('function fib(n) { return fib(n-1) + fib(n-2); }'));\n      assert.ok(!recursiveSwap.detect('function add(a, b) { return a + b; }'));\n    });\n\n    it('detects for-loop pattern', () => {\n      const forSwap = APPROACH_SWAPS.find(s => s.from === 'for-loop');\n      assert.ok(forSwap);\n      assert.ok(forSwap.detect('for (let i = 0; i < n; i++) { sum += arr[i]; }'));\n      assert.ok(!forSwap.detect('arr.map(x => x * 2)'));\n    });\n\n    it('detects mutable pattern', () => {\n      const mutSwap = APPROACH_SWAPS.find(s => s.from === 'mutable');\n      assert.ok(mutSwap);\n      assert.ok(mutSwap.detect('let a = 1; let b = 2; let c = 3;'));\n      assert.ok(!mutSwap.detect('const x = 42;'));\n    });\n  });\n\n  describe('stats tracking', () => {\n    it('tracks stats across operations', () => {\n      const seed = {\n        name: 'stat-test',\n        code: 'function inc(n) { return n + 1; }',\n        testCode: 'if (inc(0) !== 1) throw new Error(\"fail\");',\n        language: 'javascript', description: 'increment', tags: ['math'], patternType: 'utility',\n      };\n\n      recycler.processSeeds([seed], { depth: 0 });\n      assert.ok(recycler.stats.captured >= 0);\n    });\n  });\n\n  describe('candidates — two-tier system', () => {\n    it('addCandidate stores a coherent-but-unproven pattern', () => {\n      oracle.patterns.addCandidate({\n        name: 'candidate-add',\n        code: 'function add(a, b) { return a + b; }',\n        language: 'javascript',\n        description: 'Add two numbers',\n        tags: ['math', 'candidate'],\n        coherencyTotal: 0.75,\n        coherencyScore: { total: 0.75 },\n        parentPattern: 'parent-add',\n        generationMethod: 'variant',\n      });\n\n      const candidates = oracle.patterns.getCandidates();\n      assert.equal(candidates.length, 1);\n      assert.equal(candidates[0].name, 'candidate-add');\n      assert.equal(candidates[0].parentPattern, 'parent-add');\n      assert.equal(candidates[0].generationMethod, 'variant');\n      assert.equal(candidates[0].promotedAt, null);\n    });\n\n    it('getCandidates filters by language', () => {\n      oracle.patterns.addCandidate({\n        name: 'js-cand', code: 'function f() {}', language: 'javascript',\n        coherencyTotal: 0.7, generationMethod: 'variant',\n      });\n      oracle.patterns.addCandidate({\n        name: 'py-cand', code: 'def f(): pass', language: 'python',\n        coherencyTotal: 0.7, generationMethod: 'variant',\n      });\n\n      assert.equal(oracle.patterns.getCandidates().length, 2);\n      assert.equal(oracle.patterns.getCandidates({ language: 'python' }).length, 1);\n      assert.equal(oracle.patterns.getCandidates({ language: 'javascript' }).length, 1);\n    });\n\n    it('candidateSummary returns correct stats', () => {\n      oracle.patterns.addCandidate({\n        name: 'c1', code: 'function c1() { return 1; }', language: 'javascript',\n        coherencyTotal: 0.8, generationMethod: 'variant',\n      });\n      oracle.patterns.addCandidate({\n        name: 'c2', code: 'def c2(): return 2', language: 'python',\n        coherencyTotal: 0.6, generationMethod: 'iterative-refine',\n      });\n\n      const summary = oracle.patterns.candidateSummary();\n      assert.equal(summary.totalCandidates, 2);\n      assert.equal(summary.promoted, 0);\n      assert.equal(summary.byLanguage.javascript, 1);\n      assert.equal(summary.byLanguage.python, 1);\n      assert.ok(summary.avgCoherency > 0);\n    });\n\n    it('promoteCandidate marks candidate as promoted', () => {\n      const cand = oracle.patterns.addCandidate({\n        name: 'to-promote', code: 'function p() { return 42; }', language: 'javascript',\n        coherencyTotal: 0.85, generationMethod: 'variant',\n      });\n\n      const promoted = oracle.patterns.promoteCandidate(cand.id);\n      assert.ok(promoted);\n      assert.ok(promoted.promotedAt);\n\n      // Promoted candidates are no longer in the unpromoted list\n      const remaining = oracle.patterns.getCandidates();\n      assert.equal(remaining.length, 0);\n\n      // Summary should show 1 promoted\n      const summary = oracle.patterns.candidateSummary();\n      assert.equal(summary.promoted, 1);\n    });\n\n    it('generateCandidates creates candidates from proven patterns', () => {\n      // First, register a proven pattern\n      const seed = {\n        name: 'gen-double',\n        code: 'function genDouble(n) { return n * 2; }',\n        testCode: 'if (genDouble(5) !== 10) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Double a number',\n        tags: ['math'],\n        patternType: 'utility',\n      };\n      oracle.registerPattern(seed);\n\n      // Generate candidates from proven patterns\n      const genRecycler = new PatternRecycler(oracle, {\n        generateVariants: true,\n        variantLanguages: ['typescript'],\n      });\n\n      const report = genRecycler.generateCandidates({\n        languages: ['typescript'],\n        methods: ['variant'],\n      });\n\n      assert.ok(report.generated >= 1);\n      assert.ok(report.stored >= 1);\n\n      // Check candidates store has the TS variant\n      const candidates = oracle.patterns.getCandidates();\n      const tsCand = candidates.find(c => c.name === 'gen-double-ts');\n      if (tsCand) {\n        assert.equal(tsCand.language, 'typescript');\n        assert.equal(tsCand.parentPattern, 'gen-double');\n        assert.equal(tsCand.generationMethod, 'variant');\n        assert.ok(tsCand.coherencyTotal > 0);\n      }\n    });\n\n    it('generateCandidates skips duplicates', () => {\n      const seed = {\n        name: 'dup-test',\n        code: 'function dupTest(x) { return x; }',\n        testCode: 'if (dupTest(1) !== 1) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Identity',\n        tags: ['util'],\n        patternType: 'utility',\n      };\n      oracle.registerPattern(seed);\n\n      const genRecycler = new PatternRecycler(oracle, {\n        generateVariants: true,\n        variantLanguages: ['typescript'],\n      });\n\n      // Generate once\n      genRecycler.generateCandidates({ languages: ['typescript'], methods: ['variant'] });\n      const countAfterFirst = oracle.patterns.getCandidates().length;\n\n      // Generate again — should skip duplicates\n      const report2 = genRecycler.generateCandidates({ languages: ['typescript'], methods: ['variant'] });\n      const countAfterSecond = oracle.patterns.getCandidates().length;\n\n      assert.equal(countAfterFirst, countAfterSecond);\n      assert.ok(report2.duplicates >= 1);\n    });\n\n    it('promoteWithProof registers candidate as proven pattern', () => {\n      // Add a candidate with test code\n      const cand = oracle.patterns.addCandidate({\n        name: 'promote-me',\n        code: 'function promoteMe(n) { return n + 10; }',\n        language: 'javascript',\n        description: 'Add 10',\n        tags: ['math', 'candidate'],\n        coherencyTotal: 0.8,\n        testCode: 'if (promoteMe(5) !== 15) throw new Error(\"fail\");',\n        parentPattern: 'some-parent',\n        generationMethod: 'variant',\n      });\n\n      const result = recycler.promoteWithProof(cand.id, 'if (promoteMe(5) !== 15) throw new Error(\"fail\");');\n      assert.ok(result.promoted);\n      assert.ok(result.pattern);\n      assert.ok(result.coherency > 0);\n\n      // Should now exist as a proven pattern\n      const proven = oracle.patterns.getAll().find(p => p.name === 'promote-me');\n      assert.ok(proven);\n    });\n\n    it('autoPromote promotes candidates with test code', () => {\n      // Add candidate with test\n      oracle.patterns.addCandidate({\n        name: 'auto-promo',\n        code: 'function autoPromo(n) { return n * 3; }',\n        language: 'javascript',\n        description: 'Triple',\n        tags: ['math', 'candidate'],\n        coherencyTotal: 0.8,\n        testCode: 'if (autoPromo(3) !== 9) throw new Error(\"fail\");',\n        generationMethod: 'variant',\n      });\n\n      // Add candidate without test (should not be auto-promoted)\n      oracle.patterns.addCandidate({\n        name: 'no-test-cand',\n        code: 'function noTest() { return 1; }',\n        language: 'javascript',\n        coherencyTotal: 0.7,\n        generationMethod: 'variant',\n      });\n\n      const result = recycler.autoPromote();\n      assert.equal(result.attempted, 1);  // Only the one with test\n      assert.equal(result.promoted, 1);\n\n      // Candidate without test is still a candidate\n      const remaining = oracle.patterns.getCandidates();\n      assert.equal(remaining.length, 1);\n      assert.equal(remaining[0].name, 'no-test-cand');\n    });\n\n    it('oracle.candidates() returns candidates via API', () => {\n      oracle.patterns.addCandidate({\n        name: 'api-cand', code: 'function api() {}', language: 'javascript',\n        coherencyTotal: 0.7, generationMethod: 'variant',\n      });\n\n      const results = oracle.candidates();\n      assert.equal(results.length, 1);\n      assert.equal(results[0].name, 'api-cand');\n    });\n\n    it('oracle.candidateStats() returns summary via API', () => {\n      oracle.patterns.addCandidate({\n        name: 'stat-cand', code: 'function s() {}', language: 'javascript',\n        coherencyTotal: 0.7, generationMethod: 'iterative-refine',\n      });\n\n      const stats = oracle.candidateStats();\n      assert.equal(stats.totalCandidates, 1);\n      assert.equal(stats.byMethod['iterative-refine'], 1);\n    });\n  });\n\n  describe('auto-grow on register', () => {\n    it('registerPattern spawns candidates automatically', () => {\n      const growOracle = new RemembranceOracle({\n        baseDir: makeTempDir(),\n        autoSeed: false,\n        autoGrow: true,\n      });\n\n      const result = growOracle.registerPattern({\n        name: 'auto-grow-test',\n        code: 'function autoGrow(arr) { return arr.filter(x => x > 0); }',\n        testCode: 'if (autoGrow([1, -1, 2]).length !== 2) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Filter positive numbers',\n        tags: ['array', 'filter'],\n        patternType: 'utility',\n      });\n\n      assert.ok(result.registered);\n      assert.ok(result.growth);\n      assert.ok(result.growth.candidates >= 0);\n    });\n\n    it('autoGrow: false disables candidate spawning', () => {\n      const noGrowOracle = new RemembranceOracle({\n        baseDir: makeTempDir(),\n        autoSeed: false,\n        autoGrow: false,\n      });\n\n      const result = noGrowOracle.registerPattern({\n        name: 'no-grow-test',\n        code: 'function noGrow(n) { return n * 2; }',\n        testCode: 'if (noGrow(3) !== 6) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Double a number',\n        tags: ['math'],\n        patternType: 'utility',\n      });\n\n      assert.ok(result.registered);\n      assert.equal(result.growth.candidates, 0);\n    });\n\n    it('generateFromPattern spawns variants for a single pattern', () => {\n      const singleOracle = new RemembranceOracle({\n        baseDir: makeTempDir(),\n        autoSeed: false,\n        autoGrow: false,\n      });\n\n      singleOracle.registerPattern({\n        name: 'single-gen',\n        code: 'function identity(x) { return x; }',\n        testCode: 'if (identity(1) !== 1) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Identity function',\n        tags: ['utility'],\n        patternType: 'utility',\n      });\n\n      const pattern = singleOracle.patterns.getAll()[0];\n      const report = singleOracle.recycler.generateFromPattern(pattern);\n\n      assert.ok(report);\n      assert.ok(report.generated >= 0);\n      assert.ok(report.stored >= 0);\n      assert.ok(Array.isArray(report.candidates));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/recycler.test.js (68 functions)",
      "tags": [
        "assert",
        "path",
        "fs",
        "os",
        "makeTempDir",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "5c93cbd1bea33d8e",
      "name": "harvest.test",
      "code": "const { describe, it, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst { RemembranceOracle } = require('../src/api/oracle');\nconst { harvestFunctions, splitFunctions, extractBody, extractPythonBlock } = require('../src/ci/harvest');\n\ndescribe('GitHub Harvester', () => {\n  let tmpDir;\n  let oracle;\n  let srcDir;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'harvest-test-'));\n    oracle = new RemembranceOracle({ baseDir: tmpDir, threshold: 0.3, autoSeed: false });\n    srcDir = path.join(tmpDir, 'src');\n    fs.mkdirSync(srcDir, { recursive: true });\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('extractBody', () => {\n    it('extracts a brace-delimited function body', () => {\n      const code = 'function add(a, b) { return a + b; }';\n      const body = extractBody(code, 0);\n      assert.equal(body, code);\n    });\n\n    it('handles nested braces', () => {\n      const code = 'function f() { if (true) { return 1; } return 0; }';\n      const body = extractBody(code, 0);\n      assert.equal(body, code);\n    });\n\n    it('returns null when no opening brace', () => {\n      const body = extractBody('no brace here', 0);\n      assert.equal(body, null);\n    });\n\n    it('returns null for unbalanced braces', () => {\n      const body = extractBody('function f() { if (true) {', 0);\n      assert.equal(body, null);\n    });\n  });\n\n  describe('extractPythonBlock', () => {\n    it('extracts an indented block', () => {\n      const code = 'def greet(name):\\n    return f\"Hello {name}\"\\n\\ndef other():';\n      const body = extractPythonBlock(code, 0);\n      assert.ok(body.includes('def greet(name):'));\n      assert.ok(body.includes('return f\"Hello {name}\"'));\n    });\n\n    it('stops at dedented line', () => {\n      const code = 'def foo():\\n    x = 1\\n    return x\\nnot_part_of_foo()';\n      const body = extractPythonBlock(code, 0);\n      assert.ok(body.includes('x = 1'));\n      assert.ok(!body.includes('not_part_of_foo'));\n    });\n\n    it('returns null for def with no body', () => {\n      const body = extractPythonBlock('def empty():', 0);\n      assert.equal(body, null);\n    });\n  });\n\n  describe('splitFunctions', () => {\n    it('splits JavaScript functions', () => {\n      const code = `\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n`;\n      const fns = splitFunctions(code, 'javascript');\n      assert.ok(fns.length >= 2);\n      assert.ok(fns.some(f => f.name === 'add'));\n      assert.ok(fns.some(f => f.name === 'multiply'));\n    });\n\n    it('skips test/describe/it functions', () => {\n      const code = `\nfunction describe() { return 1; }\nfunction it() { return 2; }\nfunction test() { return 3; }\nfunction realFunction() { return 4; }\n`;\n      const fns = splitFunctions(code, 'javascript');\n      assert.ok(!fns.some(f => f.name === 'describe'));\n      assert.ok(!fns.some(f => f.name === 'it'));\n      assert.ok(!fns.some(f => f.name === 'test'));\n    });\n\n    it('splits Python functions', () => {\n      const code = `def hello(name):\\n    return f\"Hello {name}\"\\n\\ndef goodbye(name):\\n    return f\"Bye {name}\"\\n`;\n      const fns = splitFunctions(code, 'python');\n      assert.ok(fns.length >= 2);\n      assert.ok(fns.some(f => f.name === 'hello'));\n    });\n\n    it('skips private Python functions', () => {\n      const code = `def _private():\\n    pass\\n\\ndef public_fn():\\n    return \"hello world!!\"\\n`;\n      const fns = splitFunctions(code, 'python');\n      assert.ok(!fns.some(f => f.name === '_private'));\n    });\n\n    it('splits Go functions', () => {\n      const code = `func Add(a, b int) int {\\n\\treturn a + b\\n}\\n\\nfunc (s *Server) Start() {\\n\\ts.running = true\\n}\\n`;\n      const fns = splitFunctions(code, 'go');\n      assert.ok(fns.length >= 2);\n      assert.ok(fns.some(f => f.name === 'Add'));\n      assert.ok(fns.some(f => f.name === 'Start'));\n    });\n\n    it('splits Rust functions', () => {\n      const code = `pub fn add(a: i32, b: i32) -> i32 {\\n    a + b\\n}\\n\\nfn multiply(a: i32, b: i32) -> i32 {\\n    a * b\\n}\\n`;\n      const fns = splitFunctions(code, 'rust');\n      assert.ok(fns.length >= 2);\n      assert.ok(fns.some(f => f.name === 'add'));\n      assert.ok(fns.some(f => f.name === 'multiply'));\n    });\n\n    it('returns empty for unknown language', () => {\n      const fns = splitFunctions('some code', 'brainfuck');\n      assert.equal(fns.length, 0);\n    });\n  });\n\n  describe('harvestFunctions', () => {\n    it('harvests JavaScript files', () => {\n      fs.writeFileSync(path.join(srcDir, 'math.js'), `\nfunction add(a, b) { return a + b; }\nfunction sub(a, b) { return a - b; }\n`);\n      const results = harvestFunctions(tmpDir);\n      assert.ok(results.length >= 1);\n      assert.ok(results.some(r => r.language === 'javascript'));\n      assert.ok(results.some(r => r.functions.includes('add')));\n    });\n\n    it('filters by language', () => {\n      fs.writeFileSync(path.join(srcDir, 'code.js'), 'function jsFunc() { return 1; }');\n      fs.writeFileSync(path.join(srcDir, 'code.py'), 'def py_func():\\n    return 1\\n');\n      const jsOnly = harvestFunctions(tmpDir, { language: 'javascript' });\n      assert.ok(jsOnly.every(r => r.language === 'javascript'));\n    });\n\n    it('skips node_modules and .git', () => {\n      const nmDir = path.join(tmpDir, 'node_modules', 'pkg');\n      fs.mkdirSync(nmDir, { recursive: true });\n      fs.writeFileSync(path.join(nmDir, 'index.js'), 'function hidden() { return 1; }');\n      const results = harvestFunctions(tmpDir);\n      assert.ok(!results.some(r => r.file.includes('node_modules')));\n    });\n\n    it('respects maxFileSize', () => {\n      const big = 'function big() {\\n' + '// padding\\n'.repeat(10000) + '}\\n';\n      fs.writeFileSync(path.join(srcDir, 'big.js'), big);\n      const results = harvestFunctions(tmpDir, { maxFileSize: 100 });\n      assert.ok(!results.some(r => r.file.includes('big.js')));\n    });\n\n    it('respects minFunctions', () => {\n      fs.writeFileSync(path.join(srcDir, 'one.js'), 'function only() { return 1; }');\n      const none = harvestFunctions(tmpDir, { minFunctions: 3 });\n      assert.ok(!none.some(r => r.file.includes('one.js')));\n    });\n\n    it('handles non-existent directory', () => {\n      const results = harvestFunctions('/nonexistent/dir/abc');\n      assert.equal(results.length, 0);\n    });\n  });\n\n  describe('harvest integration', () => {\n    it('harvests from a local directory (dry run)', () => {\n      fs.writeFileSync(path.join(srcDir, 'util.js'), `\nfunction clamp(val, min, max) { return Math.min(Math.max(val, min), max); }\nfunction lerp(a, b, t) { return a + (b - a) * t; }\n`);\n      const { harvest } = require('../src/ci/harvest');\n      const result = harvest(oracle, tmpDir, { dryRun: true });\n      assert.ok(result.harvested >= 1);\n      assert.ok(result.patterns.length >= 1);\n      assert.equal(result.registered, 0); // dry run\n    });\n\n    it('registers harvested patterns', () => {\n      fs.writeFileSync(path.join(srcDir, 'helpers.js'), `\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\nfunction truncate(s, len) { return s.length > len ? s.slice(0, len) + '...' : s; }\n`);\n      const { harvest } = require('../src/ci/harvest');\n      const result = harvest(oracle, tmpDir, { splitMode: 'file' });\n      assert.ok(result.registered >= 1 || result.skipped >= 1);\n      assert.ok(result.harvested >= 1);\n    });\n\n    it('splits by function mode', () => {\n      fs.writeFileSync(path.join(srcDir, 'funcs.js'), `\nfunction alpha() {\n  return 'alpha function result';\n}\n\nfunction beta() {\n  return 'beta function result here';\n}\n`);\n      const { harvest } = require('../src/ci/harvest');\n      const result = harvest(oracle, tmpDir, { splitMode: 'function' });\n      assert.ok(result.harvested >= 1);\n    });\n\n    it('throws for nonexistent path', () => {\n      const { harvest } = require('../src/ci/harvest');\n      assert.throws(() => harvest(oracle, '/nonexistent/path/xyz'));\n    });\n\n    it('emits harvest_complete event', () => {\n      fs.writeFileSync(path.join(srcDir, 'ev.js'), 'function evTest() { return 42; }');\n      let emitted = false;\n      oracle.on(ev => { if (ev.type === 'harvest_complete') emitted = true; });\n      const { harvest } = require('../src/ci/harvest');\n      harvest(oracle, tmpDir);\n      assert.ok(emitted);\n    });\n  });\n\n  describe('MCP oracle_harvest', () => {\n    it('exposes harvest tool', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const server = new MCPServer(oracle);\n      const tools = server.handleRequest({ id: 1, method: 'tools/list' });\n      const harvestTool = tools.result.tools.find(t => t.name === 'oracle_harvest');\n      assert.ok(harvestTool, 'oracle_harvest tool should exist');\n      assert.ok(harvestTool.inputSchema.properties.path);\n    });\n\n    it('handles harvest via MCP', () => {\n      fs.writeFileSync(path.join(srcDir, 'mcp.js'), 'function mcpTest() { return \"hello\"; }');\n      const { MCPServer } = require('../src/mcp/server');\n      const server = new MCPServer(oracle);\n      const resp = server.handleRequest({\n        id: 2,\n        method: 'tools/call',\n        params: { name: 'oracle_harvest', arguments: { path: tmpDir, dryRun: true } },\n      });\n      const data = JSON.parse(resp.result.content[0].text);\n      assert.ok(data.harvested >= 0);\n      assert.ok(Array.isArray(data.patterns));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/harvest.test.js (36 functions)",
      "tags": [
        "assert",
        "fs",
        "path",
        "os",
        "body",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "2c6034aae7604ea4",
      "name": "auth.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  AuthManager,\n  authMiddleware,\n  ROLES,\n  canWrite,\n  canManageUsers,\n  canRead,\n  publicPaths,\n} = require('../src/auth/auth');\n\n// ─── Mock helpers ───\n\nfunction mockReq(headers = {}, url = '/api/test') {\n  return { headers, url };\n}\n\nfunction mockRes() {\n  const res = { statusCode: 200, headers: {}, body: '' };\n  res.setHeader = (k, v) => { res.headers[k] = v; };\n  res.writeHead = (code) => { res.statusCode = code; };\n  res.end = (body) => { res.body = body; };\n  return res;\n}\n\n// ─── AuthManager ───\n\ndescribe('AuthManager', () => {\n  let auth;\n\n  beforeEach(() => {\n    auth = new AuthManager();\n  });\n\n  it('creates with no args and uses memory backend', () => {\n    // The constructor should succeed and have already bootstrapped the default admin\n    const users = auth.listUsers();\n    assert.ok(users.length >= 1, 'should have at least the default admin');\n  });\n\n  it('createUser returns id, username, role, and apiKey', () => {\n    const user = auth.createUser('alice', 'password123', ROLES.CONTRIBUTOR);\n    assert.ok(user.id, 'should have an id');\n    assert.equal(user.username, 'alice');\n    assert.equal(user.role, ROLES.CONTRIBUTOR);\n    assert.ok(user.apiKey, 'should have an apiKey');\n  });\n\n  it('createUser throws on duplicate username', () => {\n    auth.createUser('bob', 'pass1', ROLES.VIEWER);\n    assert.throws(\n      () => auth.createUser('bob', 'pass2', ROLES.VIEWER),\n      (err) => err.message.includes('already exists')\n    );\n  });\n\n  it('createUser throws on invalid role', () => {\n    assert.throws(\n      () => auth.createUser('charlie', 'pass', 'superuser'),\n      (err) => err.message.includes('Invalid role')\n    );\n  });\n\n  it('authenticate returns token and user for valid credentials', () => {\n    auth.createUser('dana', 'secret', ROLES.CONTRIBUTOR);\n    const result = auth.authenticate('dana', 'secret');\n    assert.ok(result, 'should not be null');\n    assert.ok(result.token, 'should have a token');\n    assert.equal(result.user.username, 'dana');\n    assert.equal(result.user.role, ROLES.CONTRIBUTOR);\n  });\n\n  it('authenticate returns null for wrong password', () => {\n    auth.createUser('eve', 'correct', ROLES.VIEWER);\n    const result = auth.authenticate('eve', 'wrong');\n    assert.equal(result, null);\n  });\n\n  it('authenticate returns null for unknown user', () => {\n    const result = auth.authenticate('nonexistent', 'anything');\n    assert.equal(result, null);\n  });\n\n  it('validateToken returns user for valid token', () => {\n    auth.createUser('frank', 'pass', ROLES.CONTRIBUTOR);\n    const { token } = auth.authenticate('frank', 'pass');\n    const user = auth.validateToken(token);\n    assert.ok(user, 'should return user');\n    assert.equal(user.username, 'frank');\n  });\n\n  it('validateToken returns null for invalid token', () => {\n    const result = auth.validateToken('not-a-real-token');\n    assert.equal(result, null);\n  });\n\n  it('validateApiKey returns user for valid API key', () => {\n    const created = auth.createUser('grace', 'pass', ROLES.VIEWER);\n    const user = auth.validateApiKey(created.apiKey);\n    assert.ok(user, 'should return user');\n    assert.equal(user.username, 'grace');\n  });\n\n  it('listUsers returns all users without passwords', () => {\n    // Default admin is already present from beforeEach\n    auth.createUser('hank', 'pass', ROLES.CONTRIBUTOR);\n    auth.createUser('iris', 'pass', ROLES.VIEWER);\n    const users = auth.listUsers();\n    assert.ok(users.length >= 3, 'should have admin + 2 created users');\n    for (const u of users) {\n      assert.ok(u.id, 'each user should have id');\n      assert.ok(u.username, 'each user should have username');\n      assert.ok(u.role, 'each user should have role');\n      assert.equal(u.password_hash, undefined, 'should not expose password_hash');\n      assert.equal(u.salt, undefined, 'should not expose salt');\n    }\n  });\n\n  it('updateRole changes the user role', () => {\n    const created = auth.createUser('jack', 'pass', ROLES.VIEWER);\n    const updated = auth.updateRole(created.id, ROLES.ADMIN);\n    assert.ok(updated, 'should return updated user');\n    assert.equal(updated.role, ROLES.ADMIN);\n    // Confirm via getUser\n    const fetched = auth.getUser(created.id);\n    assert.equal(fetched.role, ROLES.ADMIN);\n  });\n\n  it('revokeApiKey generates a new key and old one stops working', () => {\n    const created = auth.createUser('karen', 'pass', ROLES.CONTRIBUTOR);\n    const oldKey = created.apiKey;\n\n    const updated = auth.revokeApiKey(created.id);\n    assert.ok(updated, 'should return updated user');\n    assert.notEqual(updated.apiKey, oldKey, 'new key should differ from old key');\n\n    // Old key no longer valid\n    const oldResult = auth.validateApiKey(oldKey);\n    assert.equal(oldResult, null, 'old API key should be invalid');\n\n    // New key works\n    const newResult = auth.validateApiKey(updated.apiKey);\n    assert.ok(newResult, 'new API key should be valid');\n    assert.equal(newResult.username, 'karen');\n  });\n\n  it('deleteUser removes the user and invalidates tokens', () => {\n    const created = auth.createUser('leo', 'pass', ROLES.VIEWER);\n    const { token } = auth.authenticate('leo', 'pass');\n\n    // Verify token works before deletion\n    assert.ok(auth.validateToken(token), 'token should work before delete');\n\n    const deleted = auth.deleteUser(created.id);\n    assert.equal(deleted, true);\n\n    // User no longer findable\n    assert.equal(auth.getUser(created.id), null);\n    // Token invalidated\n    assert.equal(auth.validateToken(token), null);\n  });\n\n  it('auto-creates default admin on first run', () => {\n    // A fresh AuthManager with no users should create 'admin' automatically\n    const fresh = new AuthManager();\n    const users = fresh.listUsers();\n    const admin = users.find((u) => u.username === 'admin');\n    assert.ok(admin, 'default admin should exist');\n    assert.equal(admin.role, ROLES.ADMIN);\n  });\n});\n\n// ─── Permission helpers ───\n\ndescribe('Permission helpers', () => {\n  it('canWrite returns true for admin', () => {\n    assert.equal(canWrite({ role: ROLES.ADMIN }), true);\n  });\n\n  it('canWrite returns true for contributor', () => {\n    assert.equal(canWrite({ role: ROLES.CONTRIBUTOR }), true);\n  });\n\n  it('canWrite returns false for viewer', () => {\n    assert.equal(canWrite({ role: ROLES.VIEWER }), false);\n  });\n\n  it('canManageUsers returns true only for admin', () => {\n    assert.equal(canManageUsers({ role: ROLES.ADMIN }), true);\n    assert.equal(canManageUsers({ role: ROLES.CONTRIBUTOR }), false);\n    assert.equal(canManageUsers({ role: ROLES.VIEWER }), false);\n  });\n\n  it('canRead returns true for all valid roles', () => {\n    assert.equal(canRead({ role: ROLES.ADMIN }), true);\n    assert.equal(canRead({ role: ROLES.CONTRIBUTOR }), true);\n    assert.equal(canRead({ role: ROLES.VIEWER }), true);\n  });\n\n  it('canRead returns false for null user', () => {\n    assert.equal(canRead(null), false);\n  });\n});\n\n// ─── authMiddleware ───\n\ndescribe('authMiddleware', () => {\n  let auth;\n  let mw;\n\n  beforeEach(() => {\n    auth = new AuthManager();\n    mw = authMiddleware(auth);\n  });\n\n  it('calls next with req.user set on valid Bearer token', (_, done) => {\n    const created = auth.createUser('mia', 'pass', ROLES.CONTRIBUTOR);\n    const { token } = auth.authenticate('mia', 'pass');\n\n    const req = mockReq({ authorization: `Bearer ${token}` });\n    const res = mockRes();\n\n    mw(req, res, () => {\n      assert.ok(req.user, 'req.user should be set');\n      assert.equal(req.user.username, 'mia');\n      done();\n    });\n  });\n\n  it('returns 401 on invalid auth', () => {\n    const req = mockReq({ authorization: 'Bearer invalid-token' });\n    const res = mockRes();\n    let nextCalled = false;\n\n    mw(req, res, () => { nextCalled = true; });\n\n    assert.equal(nextCalled, false, 'next should not be called');\n    assert.equal(res.statusCode, 401);\n    assert.ok(res.body.includes('Unauthorized'));\n  });\n\n  it('allows public paths through without auth', () => {\n    for (const pubPath of publicPaths) {\n      const req = mockReq({}, pubPath);\n      const res = mockRes();\n      let nextCalled = false;\n\n      mw(req, res, () => { nextCalled = true; });\n\n      assert.equal(nextCalled, true, `next should be called for public path ${pubPath}`);\n      assert.equal(req.user, null, `req.user should be null for public path ${pubPath}`);\n    }\n  });\n\n  it('authenticates via ApiKey header', () => {\n    const created = auth.createUser('nina', 'pass', ROLES.VIEWER);\n    const req = mockReq({ authorization: `ApiKey ${created.apiKey}` });\n    const res = mockRes();\n    let nextCalled = false;\n\n    mw(req, res, () => { nextCalled = true; });\n\n    assert.equal(nextCalled, true, 'next should be called');\n    assert.ok(req.user, 'req.user should be set');\n    assert.equal(req.user.username, 'nina');\n  });\n\n  it('returns 401 when no auth is provided on protected path', () => {\n    const req = mockReq({}, '/api/patterns');\n    const res = mockRes();\n    let nextCalled = false;\n\n    mw(req, res, () => { nextCalled = true; });\n\n    assert.equal(nextCalled, false, 'next should not be called');\n    assert.equal(res.statusCode, 401);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/auth.test.js (18 functions)",
      "tags": [
        "assert",
        "mockReq",
        "mockRes",
        "res",
        "users",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "79f9c1791bceda90",
      "name": "merge-sort-go",
      "code": "func MergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := MergeSort(arr[:mid])\n\tright := MergeSort(arr[mid:])\n\treturn merge(left, right)\n}\n\nfunc merge(a, b []int) []int {\n\tresult := make([]int, 0, len(a)+len(b))\n\ti, j := 0, 0\n\tfor i < len(a) && j < len(b) {\n\t\tif a[i] <= b[j] {\n\t\t\tresult = append(result, a[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, b[j])\n\t\t\tj++\n\t\t}\n\t}\n\tresult = append(result, a[i:]...)\n\tresult = append(result, b[j:]...)\n\treturn result\n}",
      "language": "go",
      "description": "Merge sort — stable O(n log n) sorting for slices",
      "tags": [
        "sort",
        "algorithm",
        "slice",
        "stable",
        "merge-sort"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.79
    },
    {
      "id": "e487cdb878545b6a",
      "name": "llm-generator.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { LLMClient, LLMGenerator } = require('../src/core/llm-generator');\n\n// ─── LLMClient ───\n\ndescribe('LLMClient', () => {\n  it('creates with default options', () => {\n    const client = new LLMClient();\n    assert.equal(client.provider, 'anthropic');\n    assert.equal(client.temperature, 0.3);\n    assert.equal(client.maxTokens, 2048);\n  });\n\n  it('creates with custom options', () => {\n    const client = new LLMClient({\n      provider: 'openai',\n      apiKey: 'test-key',\n      model: 'gpt-4',\n      temperature: 0.7,\n      maxTokens: 4096,\n    });\n    assert.equal(client.provider, 'openai');\n    assert.equal(client.apiKey, 'test-key');\n    assert.equal(client.model, 'gpt-4');\n    assert.equal(client.temperature, 0.7);\n    assert.equal(client.maxTokens, 4096);\n  });\n\n  it('isConfigured returns false without API key', () => {\n    // Temporarily clear env vars\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    assert.equal(client.isConfigured(), false);\n\n    // Restore\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isConfigured returns true with API key', () => {\n    const client = new LLMClient({ apiKey: 'test-key' });\n    assert.equal(client.isConfigured(), true);\n  });\n\n  it('complete throws without API key', async () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    await assert.rejects(\n      () => client.complete('system', 'user'),\n      { message: /API key not configured/ }\n    );\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('uses correct default model for anthropic', () => {\n    const client = new LLMClient({ provider: 'anthropic', apiKey: 'test' });\n    assert.ok(client.model.includes('claude'));\n  });\n\n  it('uses correct default model for openai', () => {\n    const client = new LLMClient({ provider: 'openai', apiKey: 'test' });\n    assert.ok(client.model.includes('gpt'));\n  });\n\n  it('accepts custom baseUrl', () => {\n    const client = new LLMClient({ baseUrl: 'http://localhost:8080' });\n    assert.equal(client.baseUrl, 'http://localhost:8080');\n  });\n\n  it('temperature can be set to 0', () => {\n    const client = new LLMClient({ temperature: 0 });\n    assert.equal(client.temperature, 0);\n  });\n});\n\n// ─── LLMGenerator ───\n\ndescribe('LLMGenerator', () => {\n  it('creates with default options', () => {\n    const gen = new LLMGenerator();\n    assert.ok(gen.client instanceof LLMClient);\n    assert.equal(gen.fallbackToRegex, true);\n    assert.equal(gen.verbose, false);\n  });\n\n  it('creates with custom client', () => {\n    const client = new LLMClient({ apiKey: 'test', provider: 'openai' });\n    const gen = new LLMGenerator({ client });\n    assert.equal(gen.client, client);\n  });\n\n  it('isAvailable returns false without key', () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const gen = new LLMGenerator();\n    assert.equal(gen.isAvailable(), false);\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isAvailable returns true with key', () => {\n    const gen = new LLMGenerator({ apiKey: 'test-key' });\n    assert.equal(gen.isAvailable(), true);\n  });\n\n  describe('_extractCode', () => {\n    const gen = new LLMGenerator();\n\n    it('extracts from markdown code block', () => {\n      const text = '```javascript\\nfunction test() { return 42; }\\n```';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('extracts from generic code block', () => {\n      const text = '```\\ndef test(): return 42\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def test(): return 42');\n    });\n\n    it('extracts from language-specific block', () => {\n      const text = '```python\\ndef hello():\\n    return \"world\"\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def hello():\\n    return \"world\"');\n    });\n\n    it('returns raw code when no blocks', () => {\n      const text = 'function test() { return 42; }';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('returns null for empty text', () => {\n      assert.equal(gen._extractCode('', 'javascript'), null);\n      assert.equal(gen._extractCode(null, 'javascript'), null);\n    });\n\n    it('rejects explanation-only text', () => {\n      const text = 'Here is the implementation...';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, null);\n    });\n\n    it('handles multiple code blocks — takes first', () => {\n      const text = '```js\\nconst a = 1;\\n```\\n\\n```js\\nconst b = 2;\\n```';\n      const code = gen._extractCode(text, 'js');\n      assert.equal(code, 'const a = 1;');\n    });\n  });\n\n  describe('_parseTranspileResponse', () => {\n    const gen = new LLMGenerator();\n    const pattern = {\n      name: 'quickSort',\n      code: 'function quickSort() {}',\n      language: 'javascript',\n      description: 'Quick sort',\n      tags: ['sort'],\n    };\n\n    it('parses code-only response', () => {\n      const response = '```python\\ndef quick_sort():\\n    pass\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.equal(result.language, 'python');\n      assert.ok(result.code.includes('quick_sort'));\n      assert.ok(result.tags.includes('python'));\n      assert.ok(result.tags.includes('llm-generated'));\n    });\n\n    it('parses code + tests response', () => {\n      const response = '```python\\ndef sort(arr):\\n    return sorted(arr)\\n```\\n---TESTS---\\n```python\\nassert sort([3,1,2]) == [1,2,3]\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.code.includes('sort'));\n      assert.ok(result.testCode.includes('assert'));\n    });\n\n    it('returns null for empty response', () => {\n      const result = gen._parseTranspileResponse('', pattern, 'python');\n      assert.equal(result, null);\n    });\n\n    it('applies python naming convention', () => {\n      const result = gen._parseTranspileResponse('def test(): pass', pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.name.includes('quick_sort'));\n    });\n\n    it('applies go naming convention', () => {\n      const result = gen._parseTranspileResponse('func Test() {}', pattern, 'go');\n      assert.ok(result);\n      // Go names start with uppercase\n      assert.ok(result.name.startsWith('Q') || result.name.startsWith('q'));\n    });\n\n    it('preserves parent pattern reference', () => {\n      const result = gen._parseTranspileResponse('code here', pattern, 'typescript');\n      assert.ok(result);\n      assert.equal(result.parentPattern, 'quickSort');\n    });\n  });\n\n  describe('transpile (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.transpile(\n        { code: 'function x() {}', language: 'javascript', name: 'x' },\n        'python'\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateTests (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateTests({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n        name: 'x',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateAlternative (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateAlternative({\n        code: 'function sort(arr) { return arr.sort(); }',\n        language: 'javascript',\n        name: 'sort',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('refine (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.refine(\n        { code: 'function x() {}', language: 'javascript' },\n        { correctness: 0.5, simplicity: 0.4 }\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateDocs (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateDocs({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n      });\n      assert.equal(result, null);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/llm-generator.test.js (15 functions)",
      "tags": [
        "assert",
        "client",
        "savedAnthropic",
        "savedOpenAI",
        "gen",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "3259f0905fd7a0f8",
      "name": "llm-generator.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { LLMClient, LLMGenerator } = require('../src/core/llm-generator');\n\n// ─── LLMClient ───\n\ndescribe('LLMClient', () => {\n  it('creates with default options', () => {\n    const client = new LLMClient();\n    assert.equal(client.provider, 'anthropic');\n    assert.equal(client.temperature, 0.3);\n    assert.equal(client.maxTokens, 2048);\n  });\n\n  it('creates with custom options', () => {\n    const client = new LLMClient({\n      provider: 'openai',\n      apiKey: 'test-key',\n      model: 'gpt-4',\n      temperature: 0.7,\n      maxTokens: 4096,\n    });\n    assert.equal(client.provider, 'openai');\n    assert.equal(client.apiKey, 'test-key');\n    assert.equal(client.model, 'gpt-4');\n    assert.equal(client.temperature, 0.7);\n    assert.equal(client.maxTokens, 4096);\n  });\n\n  it('isConfigured returns false without API key', () => {\n    // Temporarily clear env vars\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    assert.equal(client.isConfigured(), false);\n\n    // Restore\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isConfigured returns true with API key', () => {\n    const client = new LLMClient({ apiKey: 'test-key' });\n    assert.equal(client.isConfigured(), true);\n  });\n\n  it('complete throws without API key', async () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    await assert.rejects(\n      () => client.complete('system', 'user'),\n      { message: /API key not configured/ }\n    );\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('uses correct default model for anthropic', () => {\n    const client = new LLMClient({ provider: 'anthropic', apiKey: 'test' });\n    assert.ok(client.model.includes('claude'));\n  });\n\n  it('uses correct default model for openai', () => {\n    const client = new LLMClient({ provider: 'openai', apiKey: 'test' });\n    assert.ok(client.model.includes('gpt'));\n  });\n\n  it('accepts custom baseUrl', () => {\n    const client = new LLMClient({ baseUrl: 'http://localhost:8080' });\n    assert.equal(client.baseUrl, 'http://localhost:8080');\n  });\n\n  it('temperature can be set to 0', () => {\n    const client = new LLMClient({ temperature: 0 });\n    assert.equal(client.temperature, 0);\n  });\n});\n\n// ─── LLMGenerator ───\n\ndescribe('LLMGenerator', () => {\n  it('creates with default options', () => {\n    const gen = new LLMGenerator();\n    assert.ok(gen.client instanceof LLMClient);\n    assert.equal(gen.fallbackToRegex, true);\n    assert.equal(gen.verbose, false);\n  });\n\n  it('creates with custom client', () => {\n    const client = new LLMClient({ apiKey: 'test', provider: 'openai' });\n    const gen = new LLMGenerator({ client });\n    assert.equal(gen.client, client);\n  });\n\n  it('isAvailable returns false without key', () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const gen = new LLMGenerator();\n    assert.equal(gen.isAvailable(), false);\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isAvailable returns true with key', () => {\n    const gen = new LLMGenerator({ apiKey: 'test-key' });\n    assert.equal(gen.isAvailable(), true);\n  });\n\n  describe('_extractCode', () => {\n    const gen = new LLMGenerator();\n\n    it('extracts from markdown code block', () => {\n      const text = '```javascript\\nfunction test() { return 42; }\\n```';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('extracts from generic code block', () => {\n      const text = '```\\ndef test(): return 42\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def test(): return 42');\n    });\n\n    it('extracts from language-specific block', () => {\n      const text = '```python\\ndef hello():\\n    return \"world\"\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def hello():\\n    return \"world\"');\n    });\n\n    it('returns raw code when no blocks', () => {\n      const text = 'function test() { return 42; }';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('returns null for empty text', () => {\n      assert.equal(gen._extractCode('', 'javascript'), null);\n      assert.equal(gen._extractCode(null, 'javascript'), null);\n    });\n\n    it('rejects explanation-only text', () => {\n      const text = 'Here is the implementation...';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, null);\n    });\n\n    it('handles multiple code blocks — takes first', () => {\n      const text = '```js\\nconst a = 1;\\n```\\n\\n```js\\nconst b = 2;\\n```';\n      const code = gen._extractCode(text, 'js');\n      assert.equal(code, 'const a = 1;');\n    });\n  });\n\n  describe('_parseTranspileResponse', () => {\n    const gen = new LLMGenerator();\n    const pattern = {\n      name: 'quickSort',\n      code: 'function quickSort() {}',\n      language: 'javascript',\n      description: 'Quick sort',\n      tags: ['sort'],\n    };\n\n    it('parses code-only response', () => {\n      const response = '```python\\ndef quick_sort():\\n    pass\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.equal(result.language, 'python');\n      assert.ok(result.code.includes('quick_sort'));\n      assert.ok(result.tags.includes('python'));\n      assert.ok(result.tags.includes('llm-generated'));\n    });\n\n    it('parses code + tests response', () => {\n      const response = '```python\\ndef sort(arr):\\n    return sorted(arr)\\n```\\n---TESTS---\\n```python\\nassert sort([3,1,2]) == [1,2,3]\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.code.includes('sort'));\n      assert.ok(result.testCode.includes('assert'));\n    });\n\n    it('returns null for empty response', () => {\n      const result = gen._parseTranspileResponse('', pattern, 'python');\n      assert.equal(result, null);\n    });\n\n    it('applies python naming convention', () => {\n      const result = gen._parseTranspileResponse('def test(): pass', pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.name.includes('quick_sort'));\n    });\n\n    it('applies go naming convention', () => {\n      const result = gen._parseTranspileResponse('func Test() {}', pattern, 'go');\n      assert.ok(result);\n      // Go names start with uppercase\n      assert.ok(result.name.startsWith('Q') || result.name.startsWith('q'));\n    });\n\n    it('preserves parent pattern reference', () => {\n      const result = gen._parseTranspileResponse('code here', pattern, 'typescript');\n      assert.ok(result);\n      assert.equal(result.parentPattern, 'quickSort');\n    });\n  });\n\n  describe('transpile (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.transpile(\n        { code: 'function x() {}', language: 'javascript', name: 'x' },\n        'python'\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateTests (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateTests({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n        name: 'x',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateAlternative (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateAlternative({\n        code: 'function sort(arr) { return arr.sort(); }',\n        language: 'javascript',\n        name: 'sort',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('refine (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.refine(\n        { code: 'function x() {}', language: 'javascript' },\n        { correctness: 0.5, simplicity: 0.4 }\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateDocs (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateDocs({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n      });\n      assert.equal(result, null);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/llm-generator.test.js (15 functions)",
      "tags": [
        "assert",
        "client",
        "savedAnthropic",
        "savedOpenAI",
        "gen",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "1db151def6c5762e",
      "name": "llm-generator.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { LLMClient, LLMGenerator } = require('../src/core/llm-generator');\n\n// ─── LLMClient ───\n\ndescribe('LLMClient', () => {\n  it('creates with default options', () => {\n    const client = new LLMClient();\n    assert.equal(client.provider, 'anthropic');\n    assert.equal(client.temperature, 0.3);\n    assert.equal(client.maxTokens, 2048);\n  });\n\n  it('creates with custom options', () => {\n    const client = new LLMClient({\n      provider: 'openai',\n      apiKey: 'test-key',\n      model: 'gpt-4',\n      temperature: 0.7,\n      maxTokens: 4096,\n    });\n    assert.equal(client.provider, 'openai');\n    assert.equal(client.apiKey, 'test-key');\n    assert.equal(client.model, 'gpt-4');\n    assert.equal(client.temperature, 0.7);\n    assert.equal(client.maxTokens, 4096);\n  });\n\n  it('isConfigured returns false without API key', () => {\n    // Temporarily clear env vars\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    assert.equal(client.isConfigured(), false);\n\n    // Restore\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isConfigured returns true with API key', () => {\n    const client = new LLMClient({ apiKey: 'test-key' });\n    assert.equal(client.isConfigured(), true);\n  });\n\n  it('complete throws without API key', async () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    await assert.rejects(\n      () => client.complete('system', 'user'),\n      { message: /API key not configured/ }\n    );\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('uses correct default model for anthropic', () => {\n    const client = new LLMClient({ provider: 'anthropic', apiKey: 'test' });\n    assert.ok(client.model.includes('claude'));\n  });\n\n  it('uses correct default model for openai', () => {\n    const client = new LLMClient({ provider: 'openai', apiKey: 'test' });\n    assert.ok(client.model.includes('gpt'));\n  });\n\n  it('accepts custom baseUrl', () => {\n    const client = new LLMClient({ baseUrl: 'http://localhost:8080' });\n    assert.equal(client.baseUrl, 'http://localhost:8080');\n  });\n\n  it('temperature can be set to 0', () => {\n    const client = new LLMClient({ temperature: 0 });\n    assert.equal(client.temperature, 0);\n  });\n});\n\n// ─── LLMGenerator ───\n\ndescribe('LLMGenerator', () => {\n  it('creates with default options', () => {\n    const gen = new LLMGenerator();\n    assert.ok(gen.client instanceof LLMClient);\n    assert.equal(gen.fallbackToRegex, true);\n    assert.equal(gen.verbose, false);\n  });\n\n  it('creates with custom client', () => {\n    const client = new LLMClient({ apiKey: 'test', provider: 'openai' });\n    const gen = new LLMGenerator({ client });\n    assert.equal(gen.client, client);\n  });\n\n  it('isAvailable returns false without key', () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const gen = new LLMGenerator();\n    assert.equal(gen.isAvailable(), false);\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isAvailable returns true with key', () => {\n    const gen = new LLMGenerator({ apiKey: 'test-key' });\n    assert.equal(gen.isAvailable(), true);\n  });\n\n  describe('_extractCode', () => {\n    const gen = new LLMGenerator();\n\n    it('extracts from markdown code block', () => {\n      const text = '```javascript\\nfunction test() { return 42; }\\n```';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('extracts from generic code block', () => {\n      const text = '```\\ndef test(): return 42\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def test(): return 42');\n    });\n\n    it('extracts from language-specific block', () => {\n      const text = '```python\\ndef hello():\\n    return \"world\"\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def hello():\\n    return \"world\"');\n    });\n\n    it('returns raw code when no blocks', () => {\n      const text = 'function test() { return 42; }';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('returns null for empty text', () => {\n      assert.equal(gen._extractCode('', 'javascript'), null);\n      assert.equal(gen._extractCode(null, 'javascript'), null);\n    });\n\n    it('rejects explanation-only text', () => {\n      const text = 'Here is the implementation...';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, null);\n    });\n\n    it('handles multiple code blocks — takes first', () => {\n      const text = '```js\\nconst a = 1;\\n```\\n\\n```js\\nconst b = 2;\\n```';\n      const code = gen._extractCode(text, 'js');\n      assert.equal(code, 'const a = 1;');\n    });\n  });\n\n  describe('_parseTranspileResponse', () => {\n    const gen = new LLMGenerator();\n    const pattern = {\n      name: 'quickSort',\n      code: 'function quickSort() {}',\n      language: 'javascript',\n      description: 'Quick sort',\n      tags: ['sort'],\n    };\n\n    it('parses code-only response', () => {\n      const response = '```python\\ndef quick_sort():\\n    pass\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.equal(result.language, 'python');\n      assert.ok(result.code.includes('quick_sort'));\n      assert.ok(result.tags.includes('python'));\n      assert.ok(result.tags.includes('llm-generated'));\n    });\n\n    it('parses code + tests response', () => {\n      const response = '```python\\ndef sort(arr):\\n    return sorted(arr)\\n```\\n---TESTS---\\n```python\\nassert sort([3,1,2]) == [1,2,3]\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.code.includes('sort'));\n      assert.ok(result.testCode.includes('assert'));\n    });\n\n    it('returns null for empty response', () => {\n      const result = gen._parseTranspileResponse('', pattern, 'python');\n      assert.equal(result, null);\n    });\n\n    it('applies python naming convention', () => {\n      const result = gen._parseTranspileResponse('def test(): pass', pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.name.includes('quick_sort'));\n    });\n\n    it('applies go naming convention', () => {\n      const result = gen._parseTranspileResponse('func Test() {}', pattern, 'go');\n      assert.ok(result);\n      // Go names start with uppercase\n      assert.ok(result.name.startsWith('Q') || result.name.startsWith('q'));\n    });\n\n    it('preserves parent pattern reference', () => {\n      const result = gen._parseTranspileResponse('code here', pattern, 'typescript');\n      assert.ok(result);\n      assert.equal(result.parentPattern, 'quickSort');\n    });\n  });\n\n  describe('transpile (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.transpile(\n        { code: 'function x() {}', language: 'javascript', name: 'x' },\n        'python'\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateTests (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateTests({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n        name: 'x',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateAlternative (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateAlternative({\n        code: 'function sort(arr) { return arr.sort(); }',\n        language: 'javascript',\n        name: 'sort',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('refine (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.refine(\n        { code: 'function x() {}', language: 'javascript' },\n        { correctness: 0.5, simplicity: 0.4 }\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateDocs (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateDocs({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n      });\n      assert.equal(result, null);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/llm-generator.test.js (15 functions)",
      "tags": [
        "assert",
        "client",
        "savedAnthropic",
        "savedOpenAI",
        "gen",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "cc3ec099ebf6f0ef",
      "name": "llm-generator.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { LLMClient, LLMGenerator } = require('../src/core/llm-generator');\n\n// ─── LLMClient ───\n\ndescribe('LLMClient', () => {\n  it('creates with default options', () => {\n    const client = new LLMClient();\n    assert.equal(client.provider, 'anthropic');\n    assert.equal(client.temperature, 0.3);\n    assert.equal(client.maxTokens, 2048);\n  });\n\n  it('creates with custom options', () => {\n    const client = new LLMClient({\n      provider: 'openai',\n      apiKey: 'test-key',\n      model: 'gpt-4',\n      temperature: 0.7,\n      maxTokens: 4096,\n    });\n    assert.equal(client.provider, 'openai');\n    assert.equal(client.apiKey, 'test-key');\n    assert.equal(client.model, 'gpt-4');\n    assert.equal(client.temperature, 0.7);\n    assert.equal(client.maxTokens, 4096);\n  });\n\n  it('isConfigured returns false without API key', () => {\n    // Temporarily clear env vars\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    assert.equal(client.isConfigured(), false);\n\n    // Restore\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isConfigured returns true with API key', () => {\n    const client = new LLMClient({ apiKey: 'test-key' });\n    assert.equal(client.isConfigured(), true);\n  });\n\n  it('complete throws without API key', async () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const client = new LLMClient();\n    await assert.rejects(\n      () => client.complete('system', 'user'),\n      { message: /API key not configured/ }\n    );\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('uses correct default model for anthropic', () => {\n    const client = new LLMClient({ provider: 'anthropic', apiKey: 'test' });\n    assert.ok(client.model.includes('claude'));\n  });\n\n  it('uses correct default model for openai', () => {\n    const client = new LLMClient({ provider: 'openai', apiKey: 'test' });\n    assert.ok(client.model.includes('gpt'));\n  });\n\n  it('accepts custom baseUrl', () => {\n    const client = new LLMClient({ baseUrl: 'http://localhost:8080' });\n    assert.equal(client.baseUrl, 'http://localhost:8080');\n  });\n\n  it('temperature can be set to 0', () => {\n    const client = new LLMClient({ temperature: 0 });\n    assert.equal(client.temperature, 0);\n  });\n});\n\n// ─── LLMGenerator ───\n\ndescribe('LLMGenerator', () => {\n  it('creates with default options', () => {\n    const gen = new LLMGenerator();\n    assert.ok(gen.client instanceof LLMClient);\n    assert.equal(gen.fallbackToRegex, true);\n    assert.equal(gen.verbose, false);\n  });\n\n  it('creates with custom client', () => {\n    const client = new LLMClient({ apiKey: 'test', provider: 'openai' });\n    const gen = new LLMGenerator({ client });\n    assert.equal(gen.client, client);\n  });\n\n  it('isAvailable returns false without key', () => {\n    const savedAnthropic = process.env.ANTHROPIC_API_KEY;\n    const savedOpenAI = process.env.OPENAI_API_KEY;\n    delete process.env.ANTHROPIC_API_KEY;\n    delete process.env.OPENAI_API_KEY;\n\n    const gen = new LLMGenerator();\n    assert.equal(gen.isAvailable(), false);\n\n    if (savedAnthropic) process.env.ANTHROPIC_API_KEY = savedAnthropic;\n    if (savedOpenAI) process.env.OPENAI_API_KEY = savedOpenAI;\n  });\n\n  it('isAvailable returns true with key', () => {\n    const gen = new LLMGenerator({ apiKey: 'test-key' });\n    assert.equal(gen.isAvailable(), true);\n  });\n\n  describe('_extractCode', () => {\n    const gen = new LLMGenerator();\n\n    it('extracts from markdown code block', () => {\n      const text = '```javascript\\nfunction test() { return 42; }\\n```';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('extracts from generic code block', () => {\n      const text = '```\\ndef test(): return 42\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def test(): return 42');\n    });\n\n    it('extracts from language-specific block', () => {\n      const text = '```python\\ndef hello():\\n    return \"world\"\\n```';\n      const code = gen._extractCode(text, 'python');\n      assert.equal(code, 'def hello():\\n    return \"world\"');\n    });\n\n    it('returns raw code when no blocks', () => {\n      const text = 'function test() { return 42; }';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, 'function test() { return 42; }');\n    });\n\n    it('returns null for empty text', () => {\n      assert.equal(gen._extractCode('', 'javascript'), null);\n      assert.equal(gen._extractCode(null, 'javascript'), null);\n    });\n\n    it('rejects explanation-only text', () => {\n      const text = 'Here is the implementation...';\n      const code = gen._extractCode(text, 'javascript');\n      assert.equal(code, null);\n    });\n\n    it('handles multiple code blocks — takes first', () => {\n      const text = '```js\\nconst a = 1;\\n```\\n\\n```js\\nconst b = 2;\\n```';\n      const code = gen._extractCode(text, 'js');\n      assert.equal(code, 'const a = 1;');\n    });\n  });\n\n  describe('_parseTranspileResponse', () => {\n    const gen = new LLMGenerator();\n    const pattern = {\n      name: 'quickSort',\n      code: 'function quickSort() {}',\n      language: 'javascript',\n      description: 'Quick sort',\n      tags: ['sort'],\n    };\n\n    it('parses code-only response', () => {\n      const response = '```python\\ndef quick_sort():\\n    pass\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.equal(result.language, 'python');\n      assert.ok(result.code.includes('quick_sort'));\n      assert.ok(result.tags.includes('python'));\n      assert.ok(result.tags.includes('llm-generated'));\n    });\n\n    it('parses code + tests response', () => {\n      const response = '```python\\ndef sort(arr):\\n    return sorted(arr)\\n```\\n---TESTS---\\n```python\\nassert sort([3,1,2]) == [1,2,3]\\n```';\n      const result = gen._parseTranspileResponse(response, pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.code.includes('sort'));\n      assert.ok(result.testCode.includes('assert'));\n    });\n\n    it('returns null for empty response', () => {\n      const result = gen._parseTranspileResponse('', pattern, 'python');\n      assert.equal(result, null);\n    });\n\n    it('applies python naming convention', () => {\n      const result = gen._parseTranspileResponse('def test(): pass', pattern, 'python');\n      assert.ok(result);\n      assert.ok(result.name.includes('quick_sort'));\n    });\n\n    it('applies go naming convention', () => {\n      const result = gen._parseTranspileResponse('func Test() {}', pattern, 'go');\n      assert.ok(result);\n      // Go names start with uppercase\n      assert.ok(result.name.startsWith('Q') || result.name.startsWith('q'));\n    });\n\n    it('preserves parent pattern reference', () => {\n      const result = gen._parseTranspileResponse('code here', pattern, 'typescript');\n      assert.ok(result);\n      assert.equal(result.parentPattern, 'quickSort');\n    });\n  });\n\n  describe('transpile (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.transpile(\n        { code: 'function x() {}', language: 'javascript', name: 'x' },\n        'python'\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateTests (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateTests({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n        name: 'x',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateAlternative (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateAlternative({\n        code: 'function sort(arr) { return arr.sort(); }',\n        language: 'javascript',\n        name: 'sort',\n      });\n      assert.equal(result, null);\n    });\n  });\n\n  describe('refine (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.refine(\n        { code: 'function x() {}', language: 'javascript' },\n        { correctness: 0.5, simplicity: 0.4 }\n      );\n      assert.equal(result, null);\n    });\n  });\n\n  describe('generateDocs (without API)', () => {\n    it('returns null when API unavailable', async () => {\n      const gen = new LLMGenerator({ verbose: false });\n      const result = await gen.generateDocs({\n        code: 'function x() { return 42; }',\n        language: 'javascript',\n      });\n      assert.equal(result, null);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/llm-generator.test.js (15 functions)",
      "tags": [
        "assert",
        "client",
        "savedAnthropic",
        "savedOpenAI",
        "gen",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "cc89135f6388b42b",
      "name": "patterns.test",
      "code": "const { describe, it, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst { PatternLibrary, classifyPattern, inferComplexity, THRESHOLDS } = require('../src/patterns/library');\n\ndescribe('PatternLibrary', () => {\n  let tmpDir;\n  let lib;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'patterns-test-'));\n    lib = new PatternLibrary(tmpDir);\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('register', () => {\n    it('registers a pattern with coherency score', () => {\n      const p = lib.register({\n        name: 'quickSort',\n        code: 'function quickSort(arr) { if (arr.length <= 1) return arr; const pivot = arr[0]; return [...quickSort(arr.filter(x => x < pivot)), pivot, ...quickSort(arr.filter(x => x > pivot))]; }',\n        language: 'javascript',\n        description: 'Quicksort implementation',\n        tags: ['sort', 'algorithm'],\n      });\n      assert.ok(p.id);\n      assert.equal(p.name, 'quickSort');\n      assert.ok(p.coherencyScore.total > 0);\n      assert.equal(p.patternType, 'algorithm');\n    });\n\n    it('auto-classifies pattern type', () => {\n      const p = lib.register({\n        name: 'debounce',\n        code: 'function debounce(fn, d) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), d); }; }',\n        tags: ['utility'],\n      });\n      assert.equal(p.patternType, 'utility');\n    });\n\n    it('infers complexity tier', () => {\n      const small = lib.register({\n        name: 'add',\n        code: 'function add(a, b) { return a + b; }',\n      });\n      assert.equal(small.complexity, 'atomic');\n    });\n  });\n\n  describe('decide', () => {\n    it('returns generate when library is empty', () => {\n      const d = lib.decide({ description: 'sorting', tags: ['sort'] });\n      assert.equal(d.decision, 'generate');\n      assert.equal(d.confidence, 1.0);\n    });\n\n    it('returns pull for a strong match', () => {\n      lib.register({\n        name: 'quickSort',\n        code: 'function quickSort(arr) { if (arr.length <= 1) return arr; const pivot = arr[0]; return [...quickSort(arr.filter(x => x < pivot)), pivot, ...quickSort(arr.filter(x => x > pivot))]; }',\n        language: 'javascript',\n        description: 'Sort an array using quicksort algorithm',\n        tags: ['sort', 'algorithm', 'array'],\n        testPassed: true,\n      });\n\n      const d = lib.decide({\n        description: 'sort an array',\n        tags: ['sort', 'array'],\n        language: 'javascript',\n      });\n      assert.equal(d.decision, 'pull');\n      assert.ok(d.confidence >= THRESHOLDS.pull);\n      assert.equal(d.pattern.name, 'quickSort');\n    });\n\n    it('returns generate for unrelated requests', () => {\n      lib.register({\n        name: 'quickSort',\n        code: 'function quickSort(arr) { return arr.sort(); }',\n        description: 'Sorting',\n        tags: ['sort'],\n      });\n\n      const d = lib.decide({\n        description: 'machine learning neural network',\n        tags: ['ml', 'neural'],\n        language: 'python',\n      });\n      assert.ok(d.decision === 'generate' || d.decision === 'evolve');\n    });\n\n    it('includes alternatives', () => {\n      lib.register({ name: 'a', code: 'function a() { return 1; }', tags: ['test'] });\n      lib.register({ name: 'b', code: 'function b() { return 2; }', tags: ['test'] });\n      lib.register({ name: 'c', code: 'function c() { return 3; }', tags: ['test'] });\n\n      const d = lib.decide({ description: 'test function', tags: ['test'] });\n      assert.ok(Array.isArray(d.alternatives));\n    });\n  });\n\n  describe('recordUsage', () => {\n    it('tracks usage and success counts', () => {\n      const p = lib.register({ name: 'test', code: 'function x() { return 1; }', tags: ['t'] });\n      lib.recordUsage(p.id, true);\n      lib.recordUsage(p.id, true);\n      lib.recordUsage(p.id, false);\n      const updated = lib.recordUsage(p.id, true);\n      assert.equal(updated.usageCount, 4);\n      assert.equal(updated.successCount, 3);\n    });\n  });\n\n  describe('evolve', () => {\n    it('creates an evolved version linked to parent', () => {\n      const parent = lib.register({\n        name: 'add',\n        code: 'function add(a, b) { return a + b; }',\n        tags: ['math'],\n      });\n      const evolved = lib.evolve(parent.id, 'function add(...nums) { return nums.reduce((a, b) => a + b, 0); }', {\n        name: 'add (variadic)',\n        description: 'Add any number of values',\n      });\n      assert.ok(evolved);\n      assert.ok(evolved.id !== parent.id);\n      assert.ok(evolved.evolutionHistory.length > 0);\n    });\n\n    it('returns null for unknown parent', () => {\n      assert.equal(lib.evolve('nonexistent', 'code'), null);\n    });\n  });\n\n  describe('retire', () => {\n    it('removes low-performing patterns', () => {\n      lib.register({ name: 'good', code: 'function good() { return 1; }', tags: ['a'], testPassed: true });\n      const result = lib.retire(0.99);\n      assert.ok(result.retired >= 0);\n    });\n  });\n\n  describe('summary', () => {\n    it('returns library stats', () => {\n      lib.register({ name: 'a', code: 'function a() { return 1; }', tags: ['t'] });\n      const s = lib.summary();\n      assert.ok(s.totalPatterns >= 1);\n      assert.ok(s.byType);\n      assert.ok(s.byComplexity);\n      assert.ok(s.byLanguage);\n    });\n  });\n\n  describe('compose', () => {\n    it('creates a composed pattern from components', () => {\n      const a = lib.register({ name: 'comp-a', code: 'function compA() { return 1; }', tags: ['test'] });\n      const b = lib.register({ name: 'comp-b', code: 'function compB() { return 2; }', tags: ['test'] });\n      const result = lib.compose({ name: 'composed-ab', components: [a.id, b.id] });\n      assert.ok(result.composed);\n      assert.ok(result.pattern);\n      assert.ok(result.pattern.code.includes('compA'));\n      assert.ok(result.pattern.code.includes('compB'));\n      assert.ok(result.pattern.tags.includes('composed'));\n    });\n\n    it('fails for unknown component', () => {\n      const result = lib.compose({ name: 'bad', components: ['nonexistent'] });\n      assert.equal(result.composed, false);\n      assert.ok(result.reason.includes('not found'));\n    });\n\n    it('allows custom code', () => {\n      const a = lib.register({ name: 'custom-base', code: 'function base() { return 1; }', tags: ['t'] });\n      const result = lib.compose({\n        name: 'custom-composed',\n        components: [a.id],\n        code: 'function custom() { return base() + 1; }',\n      });\n      assert.ok(result.composed);\n      assert.ok(result.pattern.code.includes('custom'));\n    });\n  });\n\n  describe('resolveDependencies', () => {\n    it('resolves a dependency chain', () => {\n      const dep = lib.register({ name: 'dep-leaf', code: 'function leaf() {}', tags: ['t'] });\n      const parent = lib.register({ name: 'dep-parent', code: 'function parent() {}', tags: ['t'], requires: [dep.id] });\n      const deps = lib.resolveDependencies(parent.id);\n      assert.ok(deps.length >= 1);\n    });\n\n    it('returns single pattern for standalone', () => {\n      const p = lib.register({ name: 'standalone', code: 'function alone() {}', tags: ['t'] });\n      const deps = lib.resolveDependencies(p.id);\n      assert.equal(deps.length, 1);\n      assert.equal(deps[0].id, p.id);\n    });\n\n    it('returns empty for unknown id', () => {\n      const deps = lib.resolveDependencies('nonexistent-id');\n      assert.equal(deps.length, 0);\n    });\n  });\n});\n\ndescribe('classifyPattern', () => {\n  it('classifies sorting code as algorithm', () => {\n    assert.equal(classifyPattern('function quickSort() {}', 'quickSort'), 'algorithm');\n  });\n  it('classifies debounce as utility', () => {\n    assert.equal(classifyPattern('function debounce() {}', 'debounce'), 'utility');\n  });\n  it('classifies singleton as design-pattern', () => {\n    assert.equal(classifyPattern('class Singleton {}', 'singleton'), 'design-pattern');\n  });\n  it('classifies validator as validation', () => {\n    assert.equal(classifyPattern('function validateEmail() {}', 'validate'), 'validation');\n  });\n});\n\ndescribe('inferComplexity', () => {\n  it('classifies small functions as atomic', () => {\n    assert.equal(inferComplexity('function add(a, b) { return a + b; }'), 'atomic');\n  });\n  it('classifies medium code as composite', () => {\n    const code = Array(30).fill('  const x = 1;').join('\\n');\n    assert.equal(inferComplexity(`function big() {\\n${code}\\n}`), 'composite');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/patterns.test.js (32 functions)",
      "tags": [
        "assert",
        "fs",
        "path",
        "os",
        "p",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "1ccbe9b39b99dad3",
      "name": "claude-bridge.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { ClaudeBridge, extractCodeBlock, convertName, findClaudeCLI } = require('../src/core/claude-bridge');\n\n// ─── extractCodeBlock ───\n\ndescribe('extractCodeBlock', () => {\n  it('extracts language-specific code block', () => {\n    const response = 'Here is the code:\\n```javascript\\nfunction add(a, b) { return a + b; }\\n```';\n    const code = extractCodeBlock(response, 'javascript');\n    assert.equal(code, 'function add(a, b) { return a + b; }');\n  });\n\n  it('extracts generic code block', () => {\n    const response = '```\\nresult = a + b\\n```';\n    const code = extractCodeBlock(response, 'python');\n    assert.equal(code, 'result = a + b');\n  });\n\n  it('extracts python code block', () => {\n    const response = '```python\\ndef add(a, b):\\n    return a + b\\n```';\n    const code = extractCodeBlock(response, 'python');\n    assert.equal(code, 'def add(a, b):\\n    return a + b');\n  });\n\n  it('returns raw code when no blocks found', () => {\n    const response = 'function add(a, b) { return a + b; }';\n    const code = extractCodeBlock(response, 'javascript');\n    assert.equal(code, 'function add(a, b) { return a + b; }');\n  });\n\n  it('returns null for empty response', () => {\n    assert.equal(extractCodeBlock(null, 'js'), null);\n    assert.equal(extractCodeBlock('', 'js'), null);\n  });\n\n  it('rejects prose responses', () => {\n    assert.equal(extractCodeBlock('Here is what the code does...', 'js'), null);\n    assert.equal(extractCodeBlock('This function adds two numbers.', 'js'), null);\n    assert.equal(extractCodeBlock('I would suggest using map.', 'js'), null);\n  });\n\n  it('handles multiple code blocks (returns first)', () => {\n    const response = '```js\\nconst a = 1;\\n```\\nAnd also:\\n```js\\nconst b = 2;\\n```';\n    const code = extractCodeBlock(response, 'js');\n    assert.equal(code, 'const a = 1;');\n  });\n});\n\n// ─── convertName ───\n\ndescribe('convertName', () => {\n  it('converts camelCase to snake_case for Python', () => {\n    assert.equal(convertName('getUserData', 'python'), 'get_user_data');\n    assert.equal(convertName('parseJSON', 'python'), 'parse_json');\n    assert.equal(convertName('simple', 'python'), 'simple');\n  });\n\n  it('capitalizes first letter for Go', () => {\n    assert.equal(convertName('getUserData', 'go'), 'GetUserData');\n    assert.equal(convertName('Simple', 'go'), 'Simple');\n  });\n\n  it('keeps name unchanged for other languages', () => {\n    assert.equal(convertName('getUserData', 'typescript'), 'getUserData');\n    assert.equal(convertName('getUserData', 'javascript'), 'getUserData');\n  });\n});\n\n// ─── ClaudeBridge construction ───\n\ndescribe('ClaudeBridge', () => {\n  it('creates with default options', () => {\n    const bridge = new ClaudeBridge();\n    assert.equal(bridge.timeout, 60000);\n    assert.equal(bridge.model, null);\n    assert.equal(bridge.verbose, false);\n  });\n\n  it('creates with custom options', () => {\n    const bridge = new ClaudeBridge({\n      timeout: 30000,\n      model: 'claude-sonnet-4-5-20250929',\n      verbose: true,\n    });\n    assert.equal(bridge.timeout, 30000);\n    assert.equal(bridge.model, 'claude-sonnet-4-5-20250929');\n    assert.equal(bridge.verbose, true);\n  });\n\n  it('isAvailable detects CLI presence', () => {\n    const bridge = new ClaudeBridge();\n    const available = bridge.isAvailable();\n    // Should be boolean — true if claude is installed, false otherwise\n    assert.equal(typeof available, 'boolean');\n  });\n\n  it('caches availability result', () => {\n    const bridge = new ClaudeBridge();\n    const first = bridge.isAvailable();\n    const second = bridge.isAvailable();\n    assert.equal(first, second);\n  });\n\n  it('prompt returns null when CLI unavailable', () => {\n    const bridge = new ClaudeBridge({ cliPath: '/nonexistent/path/to/claude' });\n    bridge._available = false;\n    const result = bridge.prompt('test');\n    assert.equal(result, null);\n  });\n\n  it('promptAsync returns null when CLI unavailable', async () => {\n    const bridge = new ClaudeBridge({ cliPath: '/nonexistent/path/to/claude' });\n    bridge._available = false;\n    const result = await bridge.promptAsync('test');\n    assert.equal(result, null);\n  });\n});\n\n// ─── ClaudeBridge operations with mock ───\n\ndescribe('ClaudeBridge operations', () => {\n  let bridge;\n\n  beforeEach(() => {\n    bridge = new ClaudeBridge({ verbose: false });\n    // Mock prompt to return predictable responses\n    bridge._available = true;\n    bridge._mockResponses = new Map();\n    const origPrompt = bridge.prompt.bind(bridge);\n    bridge.prompt = function(prompt) {\n      // Check mock responses\n      for (const [key, response] of this._mockResponses) {\n        if (prompt.includes(key)) return response;\n      }\n      return null;\n    };\n  });\n\n  it('transpile returns structured result', () => {\n    bridge._mockResponses.set('Convert this', '```python\\ndef add(a, b):\\n    return a + b\\n```');\n    const result = bridge.transpile(\n      { name: 'add', code: 'function add(a, b) { return a + b; }', language: 'javascript', tags: ['math'] },\n      'python'\n    );\n    assert.ok(result);\n    assert.equal(result.language, 'python');\n    assert.ok(result.code.includes('def add'));\n    assert.ok(result.tags.includes('claude-generated'));\n    assert.ok(result.tags.includes('python'));\n  });\n\n  it('transpile returns null on empty response', () => {\n    const result = bridge.transpile(\n      { name: 'test', code: 'x', language: 'javascript', tags: [] },\n      'python'\n    );\n    assert.equal(result, null);\n  });\n\n  it('generateTests returns test code', () => {\n    bridge._mockResponses.set('Generate comprehensive tests', '```javascript\\nif (add(1, 2) !== 3) throw new Error(\"fail\");\\n```');\n    const result = bridge.generateTests({ code: 'function add(a, b) { return a + b; }', language: 'javascript' });\n    assert.ok(result);\n    assert.ok(result.includes('add(1, 2)'));\n  });\n\n  it('generateTests returns null on failure', () => {\n    const result = bridge.generateTests({ code: 'x', language: 'javascript' });\n    assert.equal(result, null);\n  });\n\n  it('generateAlternative returns structured result', () => {\n    bridge._mockResponses.set('alternative implementation', '```javascript\\nfunction add(a, b) { return a - (-b); }\\n```');\n    const result = bridge.generateAlternative(\n      { name: 'add', code: 'function add(a, b) { return a + b; }', language: 'javascript', tags: ['math'] }\n    );\n    assert.ok(result);\n    assert.equal(result.name, 'add-alt');\n    assert.ok(result.tags.includes('alternative'));\n    assert.ok(result.tags.includes('claude-generated'));\n  });\n\n  it('refine returns improved code', () => {\n    bridge._mockResponses.set('Improve this', '```javascript\\nfunction add(a, b) {\\n  if (typeof a !== \"number\") throw new TypeError();\\n  return a + b;\\n}\\n```');\n    const result = bridge.refine(\n      { code: 'function add(a, b) { return a + b; }', language: 'javascript' },\n      { correctness: 0.5, simplicity: 0.9 }\n    );\n    assert.ok(result);\n    assert.ok(result.includes('function add'));\n  });\n\n  it('refine includes weak dimensions in prompt', () => {\n    let capturedPrompt = '';\n    bridge.prompt = function(prompt) { capturedPrompt = prompt; return '```js\\ncode\\n```'; };\n    bridge.refine(\n      { code: 'x', language: 'javascript' },\n      { correctness: 0.3, simplicity: 0.9, total: 0.6 }\n    );\n    assert.ok(capturedPrompt.includes('correctness: 0.30'));\n    assert.ok(!capturedPrompt.includes('simplicity')); // Above 0.7 threshold\n    assert.ok(!capturedPrompt.includes('total')); // Skip 'total' field\n  });\n\n  it('generateDocs returns documentation', () => {\n    bridge._mockResponses.set('Write a', '/**\\n * Adds two numbers.\\n * @param {number} a\\n * @param {number} b\\n * @returns {number}\\n */');\n    const result = bridge.generateDocs({ code: 'function add(a, b) { return a + b; }', language: 'javascript' });\n    assert.ok(result);\n    assert.ok(result.includes('Adds two numbers'));\n  });\n\n  it('analyze returns structured JSON', () => {\n    bridge._mockResponses.set('Analyze this', '{\"issues\": [], \"suggestions\": [\"Add types\"], \"complexity\": \"low\", \"quality\": 0.85}');\n    const result = bridge.analyze('function add(a, b) { return a + b; }', 'javascript');\n    assert.ok(result);\n    assert.equal(result.quality, 0.85);\n    assert.equal(result.complexity, 'low');\n  });\n\n  it('analyze returns null on invalid JSON', () => {\n    bridge._mockResponses.set('Analyze this', 'This code is fine.');\n    const result = bridge.analyze('x', 'javascript');\n    assert.equal(result, null);\n  });\n\n  it('explain returns text', () => {\n    bridge._mockResponses.set('Explain what', 'This function adds two numbers together and returns the sum.');\n    const result = bridge.explain('function add(a, b) { return a + b; }', 'javascript');\n    assert.ok(result);\n    assert.ok(result.includes('adds'));\n  });\n\n  it('transpile converts name to Python snake_case', () => {\n    bridge._mockResponses.set('Convert this', '```python\\ndef get_user():\\n    pass\\n```');\n    const result = bridge.transpile(\n      { name: 'getUserData', code: 'function getUserData() {}', language: 'javascript', tags: [] },\n      'python'\n    );\n    assert.ok(result.name.startsWith('get_user_data'));\n  });\n\n  it('transpile converts name to Go PascalCase', () => {\n    bridge._mockResponses.set('Convert this', '```go\\nfunc GetUser() {}\\n```');\n    const result = bridge.transpile(\n      { name: 'getUser', code: 'function getUser() {}', language: 'javascript', tags: [] },\n      'go'\n    );\n    assert.ok(result.name.startsWith('GetUser'));\n  });\n});\n\n// ─── findClaudeCLI ───\n\ndescribe('findClaudeCLI', () => {\n  it('returns a string or null', () => {\n    const result = findClaudeCLI();\n    assert.ok(result === null || typeof result === 'string');\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/claude-bridge.test.js (16 functions)",
      "tags": [
        "assert",
        "response",
        "add",
        "code",
        "adds",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.78
    },
    {
      "id": "131e641e04063e9b",
      "name": "str-ts",
      "code": "const str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");`,\n    language: 'javascript',\n    description: 'Function pipe — compose left-to-right',\n    tags: ['utility', 'functional', 'pipe', 'compose', 'transform'],\n    patternType: 'utility',\n  },\n\n  // ─── Data Structures ───\n  {\n    name: 'lru-cache',\n    code: `class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}`,\n    testCode: `const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");`,\n    language: 'javascript',\n    description: 'LRU Cache using Map for O(1) get/set with eviction',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds.js (TypeScript variant)",
      "tags": [
        "str",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.775
    },
    {
      "id": "c1c830be08219551",
      "name": "run-ts",
      "code": "async function run() {\n  const { RemembranceOracle } = require('./api/oracle');\n  const oracle = new RemembranceOracle();\n\n  const command = getInput('command') || 'stats';\n\n  try {\n    if (command === 'submit') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for submit');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const result = oracle.submit(code, {\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        testCode,\n        author: process.env.GITHUB_ACTOR || 'github-action',\n      });\n\n      setOutput('result', result);\n      setOutput('accepted', result.accepted);\n      setOutput('coherency-score', result.validation?.coherencyScore?.total || 0);\n\n      if (result.accepted) {\n        console.log(`Code accepted with coherency score: ${result.entry.coherencyScore.total}`);\n      } else {\n        console.log(`Code rejected: ${result.reason}`);\n        process.exitCode = 1;\n      }\n    }\n\n    else if (command === 'query') {\n      const results = oracle.query({\n        description: getInput('description'),\n        tags: getInput('tags') ? getInput('tags').split(',').map(t => t.trim()) : [],\n        language: getInput('language'),\n        limit: parseInt(getInput('limit')) || 5,\n        minCoherency: parseFloat(getInput('min-coherency')) || 0.5,\n      });\n\n      setOutput('result', results);\n      console.log(`Found ${results.length} result(s)`);\n      for (const r of results) {\n        console.log(`\\n[${r.id}] coherency=${r.coherencyScore} relevance=${r.relevanceScore}`);\n        console.log(`  ${r.language} | ${r.tags.join(', ')}`);\n        console.log(`  ${r.description}`);\n      }\n    }\n\n    else if (command === 'validate') {\n      const filePath = getInput('file');\n      if (!filePath) throw new Error('Input \"file\" is required for validate');\n      const code = fs.readFileSync(path.resolve(filePath), 'utf-8');\n      const testFile = getInput('test-file');\n      const testCode = testFile ? fs.readFileSync(path.resolve(testFile), 'utf-8') : undefined;\n\n      const { validateCode } = require('./core/validator');\n      const result = validateCode(code, {\n        language: getInput('language'),\n        testCode,\n      });\n\n      setOutput('result', result);\n      setOutput('coherency-score', result.coherencyScore?.total || 0);\n      console.log(`Valid: ${result.valid} | Coherency: ${result.coherencyScore?.total}`);\n    }\n\n    else if (command === 'feedback') {\n      const id = getInput('entry-id');\n      if (!id) throw new Error('Input \"entry-id\" is required for feedback');\n      const succeeded = getInput('success') === 'true';\n      const result = oracle.feedback(id, succeeded);\n      setOutput('result', result);\n      console.log(result.success ? `Reliability updated: ${result.newReliability}` : result.error);\n    }\n\n    else if (command === 'stats') {\n      const stats = oracle.stats();\n      setOutput('result', stats);\n      console.log('Remembrance Oracle Stats:');\n      console.log(`  Entries: ${stats.totalEntries}`);\n      console.log(`  Languages: ${stats.languages.join(', ') || 'none'}`);\n      console.log(`  Avg Coherency: ${stats.avgCoherency}`);\n    }\n\n    else if (command === 'prune') {\n      const min = parseFloat(getInput('min-coherency')) || 0.4;\n      const result = oracle.prune(min);\n      setOutput('result', result);\n      console.log(`Pruned ${result.removed} entries. ${result.remaining} remaining.`);\n    }\n\n    else {\n      throw new Error(`Unknown command: ${command}`);\n    }\n\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n    process.exitCode = 1;\n  }\n}",
      "language": "typescript",
      "description": "Harvested function from . — src/action.js (TypeScript variant)",
      "tags": [
        "run",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.77
    },
    {
      "id": "bf19957e6ed0b142",
      "name": "history-ts",
      "code": "/**\n * Verified Code History Store\n *\n * Persistent store for code that has PROVEN itself (passed validation + coherency).\n *\n * Backend: SQLite (Node 22+ built-in) when available, falls back to flat JSON.\n *\n * Each entry includes:\n * - The code itself\n * - Coherency score breakdown\n * - Validation proof (test results)\n * - Metadata (language, tags, description, author)\n * - Timestamps and reliability tracking\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst DEFAULT_STORE_DIR = '.remembrance';\nconst HISTORY_FILE = 'verified-history.json';\n\n/**\n * Try to load SQLiteStore. Returns null if node:sqlite unavailable.\n */\nfunction tryLoadSQLite() {\n  try {\n    const { DatabaseSync } = require('node:sqlite');\n    if (DatabaseSync) {\n      const { SQLiteStore } = require('./sqlite');\n      return SQLiteStore;\n    }\n  } catch {}\n  return null;\n}\n\nclass VerifiedHistoryStore {\n  constructor(baseDir = process.cwd()) {\n    this.storeDir = path.join(baseDir, DEFAULT_STORE_DIR);\n    this._backend = 'json'; // default\n\n    const SQLiteStoreClass = tryLoadSQLite();\n    if (SQLiteStoreClass) {\n      try {\n        // Shared SQLite instance — keyed by storeDir\n        if (!VerifiedHistoryStore._sqliteInstances) {\n          VerifiedHistoryStore._sqliteInstances = new Map();\n        }\n        if (VerifiedHistoryStore._sqliteInstances.has(this.storeDir)) {\n          this._sqlite = VerifiedHistoryStore._sqliteInstances.get(this.storeDir);\n        } else {\n          this._sqlite = new SQLiteStoreClass(baseDir);\n          VerifiedHistoryStore._sqliteInstances.set(this.storeDir, this._sqlite);\n        }\n        this._backend = 'sqlite';\n      } catch {\n        this._ensureJSONStore();\n      }\n    } else {\n      this._ensureJSONStore();\n    }\n  }\n\n  get backend() { return this._backend; }\n\n  // ─── JSON fallback methods ───\n\n  _ensureJSONStore() {\n    this.historyPath = path.join(this.storeDir, HISTORY_FILE);\n    if (!fs.existsSync(this.storeDir)) {\n      fs.mkdirSync(this.storeDir, { recursive: true });\n    }\n    if (!fs.existsSync(this.historyPath)) {\n      this._writeJSON({ entries: [], meta: { created: new Date().toISOString(), version: 1 } });\n    }\n  }\n\n  _readJSON() {\n    return JSON.parse(fs.readFileSync(this.historyPath, 'utf-8'));\n  }\n\n  _writeJSON(data) {\n    fs.writeFileSync(this.historyPath, JSON.stringify(data, null, 2), 'utf-8');\n  }\n\n  _hash(code) {\n    return crypto.createHash('sha256').update(code).digest('hex').slice(0, 16);\n  }\n\n  // ─── Public API ───\n\n  add(entry) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.addEntry(entry);\n    }\n    return this._addJSON(entry);\n  }\n\n  getAll(filters = {}) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.getAllEntries(filters);\n    }\n    return this._getAllJSON(filters);\n  }\n\n  get(id) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.getEntry(id);\n    }\n    return this._getJSON(id);\n  }\n\n  recordUsage(id, succeeded) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.recordEntryUsage(id, succeeded);\n    }\n    return this._recordUsageJSON(id, succeeded);\n  }\n\n  prune(minCoherency = 0.4) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.pruneEntries(minCoherency);\n    }\n    return this._pruneJSON(minCoherency);\n  }\n\n  summary() {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.entrySummary();\n    }\n    return this._summaryJSON();\n  }\n\n  /**\n   * Get the shared SQLite store instance (for PatternLibrary to share).\n   */\n  getSQLiteStore() {\n    return this._sqlite || null;\n  }\n\n  // ─── JSON implementations (fallback) ───\n\n  _addJSON(entry) {\n    const data = this._readJSON();\n    const id = this._hash(entry.code + Date.now().toString());\n    const record = {\n      id,\n      code: entry.code,\n      language: entry.language || 'unknown',\n      description: entry.description || '',\n      tags: entry.tags || [],\n      author: entry.author || 'anonymous',\n      coherencyScore: entry.coherencyScore,\n      validation: {\n        testPassed: entry.testPassed ?? null,\n        testOutput: entry.testOutput || null,\n        validatedAt: new Date().toISOString(),\n      },\n      reliability: {\n        timesUsed: 0,\n        timesSucceeded: 0,\n        historicalScore: 1.0,\n      },\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    data.entries.push(record);\n    this._writeJSON(data);\n    return record;\n  }\n\n  _getAllJSON(filters = {}) {\n    const data = this._readJSON();\n    let entries = data.entries;\n    if (filters.language) {\n      entries = entries.filter(e => e.language.toLowerCase() === filters.language.toLowerCase());\n    }\n    if (filters.minCoherency != null) {\n      entries = entries.filter(e => (e.coherencyScore?.total ?? 0) >= filters.minCoherency);\n    }\n    if (filters.tags && filters.tags.length > 0) {\n      const filterTags = new Set(filters.tags.map(t => t.toLowerCase()));\n      entries = entries.filter(e => e.tags.some(t => filterTags.has(t.toLowerCase())));\n    }\n    return entries;\n  }\n\n  _getJSON(id) {\n    const data = this._readJSON();\n    return data.entries.find(e => e.id === id) || null;\n  }\n\n  _recordUsageJSON(id, succeeded) {\n    const data = this._readJSON();\n    const entry = data.entries.find(e => e.id === id);\n    if (!entry) return null;\n    entry.reliability.timesUsed += 1;\n    if (succeeded) entry.reliability.timesSucceeded += 1;\n    entry.reliability.historicalScore =\n      entry.reliability.timesUsed > 0\n        ? entry.reliability.timesSucceeded / entry.reliability.timesUsed\n        : 0.5;\n    entry.updatedAt = new Date().toISOString();\n    this._writeJSON(data);\n    return entry;\n  }\n\n  _pruneJSON(minCoherency = 0.4) {\n    const data = this._readJSON();\n    const before = data.entries.length;\n    data.entries = data.entries.filter(e => (e.coherencyScore?.total ?? 0) >= minCoherency);\n    this._writeJSON(data);\n    return { removed: before - data.entries.length, remaining: data.entries.length };\n  }\n\n  _summaryJSON() {\n    const entries = this.getAll();\n    return {\n      totalEntries: entries.length,\n      languages: [...new Set(entries.map(e => e.language))],\n      avgCoherency: entries.length > 0\n        ? Math.round(entries.reduce((s, e) => s + (e.coherencyScore?.total ?? 0), 0) / entries.length * 1000) / 1000\n        : 0,\n      topTags: getTopTags(entries, 10),\n    };\n  }\n}\n\nfunction getTopTags(entries, limit) {\n  const counts = {};\n  for (const e of entries) {\n    for (const tag of e.tags) {\n      const t = tag.toLowerCase();\n      counts[t] = (counts[t] || 0) + 1;\n    }\n  }\n  return Object.entries(counts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, limit)\n    .map(([tag, count]) => ({ tag, count }));\n}\n\nmodule.exports = { VerifiedHistoryStore, DEFAULT_STORE_DIR, HISTORY_FILE };\n",
      "testCode": "if (tryLoadSQLite() === undefined) throw new Error(\"returned undefined\");",
      "language": "typescript",
      "description": "Harvested from . — src/store/history.js (17 functions) (TypeScript variant)",
      "tags": [
        "fs",
        "path",
        "crypto",
        "DEFAULT_STORE_DIR",
        "HISTORY_FILE",
        "javascript",
        "harvested",
        "variant",
        "typescript",
        "auto-generated"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.77
    },
    {
      "id": "bcf260e9418b0eb3",
      "name": "teams.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { TeamManager, TEAM_ROLES } = require('../src/auth/teams');\n\ndescribe('TeamManager', () => {\n  let tm;\n  const ownerId = 'user-1';\n  const memberId = 'user-2';\n  const viewerId = 'user-3';\n  let orgId;\n\n  beforeEach(() => {\n    tm = new TeamManager({});\n    const org = tm.createOrg('TestOrg', ownerId);\n    orgId = org.id;\n  });\n\n  describe('createOrg', () => {\n    it('creates an organization', () => {\n      const org = tm.createOrg('NewOrg', 'user-99');\n      assert.ok(org.id);\n      assert.equal(org.name, 'NewOrg');\n      assert.equal(org.owner, 'user-99');\n    });\n\n    it('sets owner as first member', () => {\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n      assert.equal(members[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('throws without name or owner', () => {\n      assert.throws(() => tm.createOrg('', 'user'), /Name and owner required/);\n    });\n  });\n\n  describe('getOrg', () => {\n    it('returns org by id', () => {\n      const org = tm.getOrg(orgId);\n      assert.equal(org.name, 'TestOrg');\n    });\n\n    it('returns null for unknown id', () => {\n      assert.equal(tm.getOrg('nonexistent'), null);\n    });\n  });\n\n  describe('listUserOrgs', () => {\n    it('lists orgs for a user', () => {\n      const orgs = tm.listUserOrgs(ownerId);\n      assert.equal(orgs.length, 1);\n      assert.equal(orgs[0].name, 'TestOrg');\n      assert.equal(orgs[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('returns empty for non-member', () => {\n      assert.equal(tm.listUserOrgs('nobody').length, 0);\n    });\n  });\n\n  describe('addMember', () => {\n    it('adds a member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 2);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      assert.throws(\n        () => tm.addMember(orgId, memberId, viewerId),\n        /Admin access required/\n      );\n    });\n\n    it('throws for invalid role', () => {\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, memberId, 'superadmin'),\n        /Invalid role/\n      );\n    });\n\n    it('enforces max members', () => {\n      const org = tm.getOrg(orgId);\n      org.maxMembers = 2;\n      tm.addMember(orgId, ownerId, memberId);\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, viewerId),\n        /Maximum members/\n      );\n    });\n  });\n\n  describe('removeMember', () => {\n    it('removes a member', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, ownerId, memberId);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n    });\n\n    it('allows self-removal', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, memberId, memberId);\n    });\n\n    it('cannot remove owner', () => {\n      assert.throws(\n        () => tm.removeMember(orgId, ownerId, ownerId),\n        /Cannot remove the owner/\n      );\n    });\n  });\n\n  describe('updateMemberRole', () => {\n    it('updates role', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      tm.updateMemberRole(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      const member = members.find(m => m.userId === memberId);\n      assert.equal(member.role, TEAM_ROLES.MEMBER);\n    });\n  });\n\n  describe('updateOrg', () => {\n    it('updates org settings', () => {\n      const updated = tm.updateOrg(orgId, ownerId, { name: 'Renamed', settings: { minCoherency: 0.8 } });\n      assert.equal(updated.name, 'Renamed');\n      assert.equal(updated.settings.minCoherency, 0.8);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.updateOrg(orgId, viewerId, { name: 'X' }), /Admin access required/);\n    });\n  });\n\n  describe('deleteOrg', () => {\n    it('deletes org as owner', () => {\n      const result = tm.deleteOrg(orgId, ownerId);\n      assert.ok(result.deleted);\n      assert.equal(tm.getOrg(orgId), null);\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(() => tm.deleteOrg(orgId, memberId), /Only the owner/);\n    });\n  });\n\n  describe('invite system', () => {\n    it('creates and accepts invite', () => {\n      const invite = tm.createInvite(orgId, ownerId);\n      assert.ok(invite.token);\n      const result = tm.acceptInvite(invite.token, memberId);\n      assert.equal(result.orgId, orgId);\n      assert.equal(result.role, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canView(orgId, memberId));\n    });\n\n    it('rejects invalid invite', () => {\n      assert.throws(() => tm.acceptInvite('bad-token', memberId), /Invalid invite/);\n    });\n\n    it('rejects expired invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { expiresIn: -1000 });\n      assert.throws(() => tm.acceptInvite(invite.token, memberId), /expired/);\n    });\n\n    it('rejects used invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { maxUses: 1 });\n      tm.acceptInvite(invite.token, memberId);\n      assert.throws(() => tm.acceptInvite(invite.token, viewerId), /Invalid|used/);\n    });\n  });\n\n  describe('SSO', () => {\n    it('registers SSO provider', () => {\n      const result = tm.registerSSOProvider(orgId, ownerId, {\n        type: 'oidc',\n        issuer: 'https://auth.example.com',\n        clientId: 'client-123',\n        clientSecret: 'secret',\n      });\n      assert.ok(result.configured);\n    });\n\n    it('gets SSO config', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'saml', issuer: 'https://idp.example.com' });\n      const config = tm.getSSOConfig(orgId);\n      assert.equal(config.type, 'saml');\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(\n        () => tm.registerSSOProvider(orgId, memberId, { type: 'oidc' }),\n        /Owner access required/\n      );\n    });\n\n    it('validates SSO token', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'oidc', issuer: 'test' });\n      const result = tm.validateSSOToken(orgId, 'fake-token');\n      assert.ok(result.valid);\n    });\n\n    it('returns null for unconfigured org', () => {\n      assert.equal(tm.validateSSOToken('no-org', 'token'), null);\n    });\n  });\n\n  describe('audit log', () => {\n    it('records actions', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      const log = tm.getAuditLog(orgId, ownerId);\n      assert.ok(log.length >= 2); // org_created + member_added\n      assert.ok(log.some(e => e.action === 'member_added'));\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.getAuditLog(orgId, viewerId), /Admin access required/);\n    });\n  });\n\n  describe('permissions', () => {\n    it('canSubmit for member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canSubmit(orgId, memberId));\n    });\n\n    it('canView for viewer', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.ok(tm.canView(orgId, viewerId));\n      assert.ok(!tm.canSubmit(orgId, viewerId));\n    });\n\n    it('canManage for admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.ok(tm.canManage(orgId, memberId));\n    });\n\n    it('owner has all permissions', () => {\n      assert.ok(tm.canSubmit(orgId, ownerId));\n      assert.ok(tm.canView(orgId, ownerId));\n      assert.ok(tm.canManage(orgId, ownerId));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/teams.test.js (13 functions)",
      "tags": [
        "assert",
        "ownerId",
        "memberId",
        "viewerId",
        "org",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.76
    },
    {
      "id": "5d4608e8aa9f2141",
      "name": "teams.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { TeamManager, TEAM_ROLES } = require('../src/auth/teams');\n\ndescribe('TeamManager', () => {\n  let tm;\n  const ownerId = 'user-1';\n  const memberId = 'user-2';\n  const viewerId = 'user-3';\n  let orgId;\n\n  beforeEach(() => {\n    tm = new TeamManager({});\n    const org = tm.createOrg('TestOrg', ownerId);\n    orgId = org.id;\n  });\n\n  describe('createOrg', () => {\n    it('creates an organization', () => {\n      const org = tm.createOrg('NewOrg', 'user-99');\n      assert.ok(org.id);\n      assert.equal(org.name, 'NewOrg');\n      assert.equal(org.owner, 'user-99');\n    });\n\n    it('sets owner as first member', () => {\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n      assert.equal(members[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('throws without name or owner', () => {\n      assert.throws(() => tm.createOrg('', 'user'), /Name and owner required/);\n    });\n  });\n\n  describe('getOrg', () => {\n    it('returns org by id', () => {\n      const org = tm.getOrg(orgId);\n      assert.equal(org.name, 'TestOrg');\n    });\n\n    it('returns null for unknown id', () => {\n      assert.equal(tm.getOrg('nonexistent'), null);\n    });\n  });\n\n  describe('listUserOrgs', () => {\n    it('lists orgs for a user', () => {\n      const orgs = tm.listUserOrgs(ownerId);\n      assert.equal(orgs.length, 1);\n      assert.equal(orgs[0].name, 'TestOrg');\n      assert.equal(orgs[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('returns empty for non-member', () => {\n      assert.equal(tm.listUserOrgs('nobody').length, 0);\n    });\n  });\n\n  describe('addMember', () => {\n    it('adds a member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 2);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      assert.throws(\n        () => tm.addMember(orgId, memberId, viewerId),\n        /Admin access required/\n      );\n    });\n\n    it('throws for invalid role', () => {\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, memberId, 'superadmin'),\n        /Invalid role/\n      );\n    });\n\n    it('enforces max members', () => {\n      const org = tm.getOrg(orgId);\n      org.maxMembers = 2;\n      tm.addMember(orgId, ownerId, memberId);\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, viewerId),\n        /Maximum members/\n      );\n    });\n  });\n\n  describe('removeMember', () => {\n    it('removes a member', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, ownerId, memberId);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n    });\n\n    it('allows self-removal', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, memberId, memberId);\n    });\n\n    it('cannot remove owner', () => {\n      assert.throws(\n        () => tm.removeMember(orgId, ownerId, ownerId),\n        /Cannot remove the owner/\n      );\n    });\n  });\n\n  describe('updateMemberRole', () => {\n    it('updates role', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      tm.updateMemberRole(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      const member = members.find(m => m.userId === memberId);\n      assert.equal(member.role, TEAM_ROLES.MEMBER);\n    });\n  });\n\n  describe('updateOrg', () => {\n    it('updates org settings', () => {\n      const updated = tm.updateOrg(orgId, ownerId, { name: 'Renamed', settings: { minCoherency: 0.8 } });\n      assert.equal(updated.name, 'Renamed');\n      assert.equal(updated.settings.minCoherency, 0.8);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.updateOrg(orgId, viewerId, { name: 'X' }), /Admin access required/);\n    });\n  });\n\n  describe('deleteOrg', () => {\n    it('deletes org as owner', () => {\n      const result = tm.deleteOrg(orgId, ownerId);\n      assert.ok(result.deleted);\n      assert.equal(tm.getOrg(orgId), null);\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(() => tm.deleteOrg(orgId, memberId), /Only the owner/);\n    });\n  });\n\n  describe('invite system', () => {\n    it('creates and accepts invite', () => {\n      const invite = tm.createInvite(orgId, ownerId);\n      assert.ok(invite.token);\n      const result = tm.acceptInvite(invite.token, memberId);\n      assert.equal(result.orgId, orgId);\n      assert.equal(result.role, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canView(orgId, memberId));\n    });\n\n    it('rejects invalid invite', () => {\n      assert.throws(() => tm.acceptInvite('bad-token', memberId), /Invalid invite/);\n    });\n\n    it('rejects expired invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { expiresIn: -1000 });\n      assert.throws(() => tm.acceptInvite(invite.token, memberId), /expired/);\n    });\n\n    it('rejects used invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { maxUses: 1 });\n      tm.acceptInvite(invite.token, memberId);\n      assert.throws(() => tm.acceptInvite(invite.token, viewerId), /Invalid|used/);\n    });\n  });\n\n  describe('SSO', () => {\n    it('registers SSO provider', () => {\n      const result = tm.registerSSOProvider(orgId, ownerId, {\n        type: 'oidc',\n        issuer: 'https://auth.example.com',\n        clientId: 'client-123',\n        clientSecret: 'secret',\n      });\n      assert.ok(result.configured);\n    });\n\n    it('gets SSO config', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'saml', issuer: 'https://idp.example.com' });\n      const config = tm.getSSOConfig(orgId);\n      assert.equal(config.type, 'saml');\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(\n        () => tm.registerSSOProvider(orgId, memberId, { type: 'oidc' }),\n        /Owner access required/\n      );\n    });\n\n    it('validates SSO token', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'oidc', issuer: 'test' });\n      const result = tm.validateSSOToken(orgId, 'fake-token');\n      assert.ok(result.valid);\n    });\n\n    it('returns null for unconfigured org', () => {\n      assert.equal(tm.validateSSOToken('no-org', 'token'), null);\n    });\n  });\n\n  describe('audit log', () => {\n    it('records actions', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      const log = tm.getAuditLog(orgId, ownerId);\n      assert.ok(log.length >= 2); // org_created + member_added\n      assert.ok(log.some(e => e.action === 'member_added'));\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.getAuditLog(orgId, viewerId), /Admin access required/);\n    });\n  });\n\n  describe('permissions', () => {\n    it('canSubmit for member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canSubmit(orgId, memberId));\n    });\n\n    it('canView for viewer', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.ok(tm.canView(orgId, viewerId));\n      assert.ok(!tm.canSubmit(orgId, viewerId));\n    });\n\n    it('canManage for admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.ok(tm.canManage(orgId, memberId));\n    });\n\n    it('owner has all permissions', () => {\n      assert.ok(tm.canSubmit(orgId, ownerId));\n      assert.ok(tm.canView(orgId, ownerId));\n      assert.ok(tm.canManage(orgId, ownerId));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/teams.test.js (13 functions)",
      "tags": [
        "assert",
        "ownerId",
        "memberId",
        "viewerId",
        "org",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.76
    },
    {
      "id": "3bb96ee440ebdc7c",
      "name": "teams.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { TeamManager, TEAM_ROLES } = require('../src/auth/teams');\n\ndescribe('TeamManager', () => {\n  let tm;\n  const ownerId = 'user-1';\n  const memberId = 'user-2';\n  const viewerId = 'user-3';\n  let orgId;\n\n  beforeEach(() => {\n    tm = new TeamManager({});\n    const org = tm.createOrg('TestOrg', ownerId);\n    orgId = org.id;\n  });\n\n  describe('createOrg', () => {\n    it('creates an organization', () => {\n      const org = tm.createOrg('NewOrg', 'user-99');\n      assert.ok(org.id);\n      assert.equal(org.name, 'NewOrg');\n      assert.equal(org.owner, 'user-99');\n    });\n\n    it('sets owner as first member', () => {\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n      assert.equal(members[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('throws without name or owner', () => {\n      assert.throws(() => tm.createOrg('', 'user'), /Name and owner required/);\n    });\n  });\n\n  describe('getOrg', () => {\n    it('returns org by id', () => {\n      const org = tm.getOrg(orgId);\n      assert.equal(org.name, 'TestOrg');\n    });\n\n    it('returns null for unknown id', () => {\n      assert.equal(tm.getOrg('nonexistent'), null);\n    });\n  });\n\n  describe('listUserOrgs', () => {\n    it('lists orgs for a user', () => {\n      const orgs = tm.listUserOrgs(ownerId);\n      assert.equal(orgs.length, 1);\n      assert.equal(orgs[0].name, 'TestOrg');\n      assert.equal(orgs[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('returns empty for non-member', () => {\n      assert.equal(tm.listUserOrgs('nobody').length, 0);\n    });\n  });\n\n  describe('addMember', () => {\n    it('adds a member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 2);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      assert.throws(\n        () => tm.addMember(orgId, memberId, viewerId),\n        /Admin access required/\n      );\n    });\n\n    it('throws for invalid role', () => {\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, memberId, 'superadmin'),\n        /Invalid role/\n      );\n    });\n\n    it('enforces max members', () => {\n      const org = tm.getOrg(orgId);\n      org.maxMembers = 2;\n      tm.addMember(orgId, ownerId, memberId);\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, viewerId),\n        /Maximum members/\n      );\n    });\n  });\n\n  describe('removeMember', () => {\n    it('removes a member', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, ownerId, memberId);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n    });\n\n    it('allows self-removal', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, memberId, memberId);\n    });\n\n    it('cannot remove owner', () => {\n      assert.throws(\n        () => tm.removeMember(orgId, ownerId, ownerId),\n        /Cannot remove the owner/\n      );\n    });\n  });\n\n  describe('updateMemberRole', () => {\n    it('updates role', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      tm.updateMemberRole(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      const member = members.find(m => m.userId === memberId);\n      assert.equal(member.role, TEAM_ROLES.MEMBER);\n    });\n  });\n\n  describe('updateOrg', () => {\n    it('updates org settings', () => {\n      const updated = tm.updateOrg(orgId, ownerId, { name: 'Renamed', settings: { minCoherency: 0.8 } });\n      assert.equal(updated.name, 'Renamed');\n      assert.equal(updated.settings.minCoherency, 0.8);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.updateOrg(orgId, viewerId, { name: 'X' }), /Admin access required/);\n    });\n  });\n\n  describe('deleteOrg', () => {\n    it('deletes org as owner', () => {\n      const result = tm.deleteOrg(orgId, ownerId);\n      assert.ok(result.deleted);\n      assert.equal(tm.getOrg(orgId), null);\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(() => tm.deleteOrg(orgId, memberId), /Only the owner/);\n    });\n  });\n\n  describe('invite system', () => {\n    it('creates and accepts invite', () => {\n      const invite = tm.createInvite(orgId, ownerId);\n      assert.ok(invite.token);\n      const result = tm.acceptInvite(invite.token, memberId);\n      assert.equal(result.orgId, orgId);\n      assert.equal(result.role, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canView(orgId, memberId));\n    });\n\n    it('rejects invalid invite', () => {\n      assert.throws(() => tm.acceptInvite('bad-token', memberId), /Invalid invite/);\n    });\n\n    it('rejects expired invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { expiresIn: -1000 });\n      assert.throws(() => tm.acceptInvite(invite.token, memberId), /expired/);\n    });\n\n    it('rejects used invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { maxUses: 1 });\n      tm.acceptInvite(invite.token, memberId);\n      assert.throws(() => tm.acceptInvite(invite.token, viewerId), /Invalid|used/);\n    });\n  });\n\n  describe('SSO', () => {\n    it('registers SSO provider', () => {\n      const result = tm.registerSSOProvider(orgId, ownerId, {\n        type: 'oidc',\n        issuer: 'https://auth.example.com',\n        clientId: 'client-123',\n        clientSecret: 'secret',\n      });\n      assert.ok(result.configured);\n    });\n\n    it('gets SSO config', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'saml', issuer: 'https://idp.example.com' });\n      const config = tm.getSSOConfig(orgId);\n      assert.equal(config.type, 'saml');\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(\n        () => tm.registerSSOProvider(orgId, memberId, { type: 'oidc' }),\n        /Owner access required/\n      );\n    });\n\n    it('validates SSO token', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'oidc', issuer: 'test' });\n      const result = tm.validateSSOToken(orgId, 'fake-token');\n      assert.ok(result.valid);\n    });\n\n    it('returns null for unconfigured org', () => {\n      assert.equal(tm.validateSSOToken('no-org', 'token'), null);\n    });\n  });\n\n  describe('audit log', () => {\n    it('records actions', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      const log = tm.getAuditLog(orgId, ownerId);\n      assert.ok(log.length >= 2); // org_created + member_added\n      assert.ok(log.some(e => e.action === 'member_added'));\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.getAuditLog(orgId, viewerId), /Admin access required/);\n    });\n  });\n\n  describe('permissions', () => {\n    it('canSubmit for member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canSubmit(orgId, memberId));\n    });\n\n    it('canView for viewer', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.ok(tm.canView(orgId, viewerId));\n      assert.ok(!tm.canSubmit(orgId, viewerId));\n    });\n\n    it('canManage for admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.ok(tm.canManage(orgId, memberId));\n    });\n\n    it('owner has all permissions', () => {\n      assert.ok(tm.canSubmit(orgId, ownerId));\n      assert.ok(tm.canView(orgId, ownerId));\n      assert.ok(tm.canManage(orgId, ownerId));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/teams.test.js (13 functions)",
      "tags": [
        "assert",
        "ownerId",
        "memberId",
        "viewerId",
        "org",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.76
    },
    {
      "id": "f66b4344930acfe4",
      "name": "teams.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst { TeamManager, TEAM_ROLES } = require('../src/auth/teams');\n\ndescribe('TeamManager', () => {\n  let tm;\n  const ownerId = 'user-1';\n  const memberId = 'user-2';\n  const viewerId = 'user-3';\n  let orgId;\n\n  beforeEach(() => {\n    tm = new TeamManager({});\n    const org = tm.createOrg('TestOrg', ownerId);\n    orgId = org.id;\n  });\n\n  describe('createOrg', () => {\n    it('creates an organization', () => {\n      const org = tm.createOrg('NewOrg', 'user-99');\n      assert.ok(org.id);\n      assert.equal(org.name, 'NewOrg');\n      assert.equal(org.owner, 'user-99');\n    });\n\n    it('sets owner as first member', () => {\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n      assert.equal(members[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('throws without name or owner', () => {\n      assert.throws(() => tm.createOrg('', 'user'), /Name and owner required/);\n    });\n  });\n\n  describe('getOrg', () => {\n    it('returns org by id', () => {\n      const org = tm.getOrg(orgId);\n      assert.equal(org.name, 'TestOrg');\n    });\n\n    it('returns null for unknown id', () => {\n      assert.equal(tm.getOrg('nonexistent'), null);\n    });\n  });\n\n  describe('listUserOrgs', () => {\n    it('lists orgs for a user', () => {\n      const orgs = tm.listUserOrgs(ownerId);\n      assert.equal(orgs.length, 1);\n      assert.equal(orgs[0].name, 'TestOrg');\n      assert.equal(orgs[0].role, TEAM_ROLES.OWNER);\n    });\n\n    it('returns empty for non-member', () => {\n      assert.equal(tm.listUserOrgs('nobody').length, 0);\n    });\n  });\n\n  describe('addMember', () => {\n    it('adds a member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 2);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      assert.throws(\n        () => tm.addMember(orgId, memberId, viewerId),\n        /Admin access required/\n      );\n    });\n\n    it('throws for invalid role', () => {\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, memberId, 'superadmin'),\n        /Invalid role/\n      );\n    });\n\n    it('enforces max members', () => {\n      const org = tm.getOrg(orgId);\n      org.maxMembers = 2;\n      tm.addMember(orgId, ownerId, memberId);\n      assert.throws(\n        () => tm.addMember(orgId, ownerId, viewerId),\n        /Maximum members/\n      );\n    });\n  });\n\n  describe('removeMember', () => {\n    it('removes a member', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, ownerId, memberId);\n      const members = tm.listMembers(orgId, ownerId);\n      assert.equal(members.length, 1);\n    });\n\n    it('allows self-removal', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      tm.removeMember(orgId, memberId, memberId);\n    });\n\n    it('cannot remove owner', () => {\n      assert.throws(\n        () => tm.removeMember(orgId, ownerId, ownerId),\n        /Cannot remove the owner/\n      );\n    });\n  });\n\n  describe('updateMemberRole', () => {\n    it('updates role', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.VIEWER);\n      tm.updateMemberRole(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      const members = tm.listMembers(orgId, ownerId);\n      const member = members.find(m => m.userId === memberId);\n      assert.equal(member.role, TEAM_ROLES.MEMBER);\n    });\n  });\n\n  describe('updateOrg', () => {\n    it('updates org settings', () => {\n      const updated = tm.updateOrg(orgId, ownerId, { name: 'Renamed', settings: { minCoherency: 0.8 } });\n      assert.equal(updated.name, 'Renamed');\n      assert.equal(updated.settings.minCoherency, 0.8);\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.updateOrg(orgId, viewerId, { name: 'X' }), /Admin access required/);\n    });\n  });\n\n  describe('deleteOrg', () => {\n    it('deletes org as owner', () => {\n      const result = tm.deleteOrg(orgId, ownerId);\n      assert.ok(result.deleted);\n      assert.equal(tm.getOrg(orgId), null);\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(() => tm.deleteOrg(orgId, memberId), /Only the owner/);\n    });\n  });\n\n  describe('invite system', () => {\n    it('creates and accepts invite', () => {\n      const invite = tm.createInvite(orgId, ownerId);\n      assert.ok(invite.token);\n      const result = tm.acceptInvite(invite.token, memberId);\n      assert.equal(result.orgId, orgId);\n      assert.equal(result.role, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canView(orgId, memberId));\n    });\n\n    it('rejects invalid invite', () => {\n      assert.throws(() => tm.acceptInvite('bad-token', memberId), /Invalid invite/);\n    });\n\n    it('rejects expired invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { expiresIn: -1000 });\n      assert.throws(() => tm.acceptInvite(invite.token, memberId), /expired/);\n    });\n\n    it('rejects used invite', () => {\n      const invite = tm.createInvite(orgId, ownerId, { maxUses: 1 });\n      tm.acceptInvite(invite.token, memberId);\n      assert.throws(() => tm.acceptInvite(invite.token, viewerId), /Invalid|used/);\n    });\n  });\n\n  describe('SSO', () => {\n    it('registers SSO provider', () => {\n      const result = tm.registerSSOProvider(orgId, ownerId, {\n        type: 'oidc',\n        issuer: 'https://auth.example.com',\n        clientId: 'client-123',\n        clientSecret: 'secret',\n      });\n      assert.ok(result.configured);\n    });\n\n    it('gets SSO config', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'saml', issuer: 'https://idp.example.com' });\n      const config = tm.getSSOConfig(orgId);\n      assert.equal(config.type, 'saml');\n    });\n\n    it('throws for non-owner', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.throws(\n        () => tm.registerSSOProvider(orgId, memberId, { type: 'oidc' }),\n        /Owner access required/\n      );\n    });\n\n    it('validates SSO token', () => {\n      tm.registerSSOProvider(orgId, ownerId, { type: 'oidc', issuer: 'test' });\n      const result = tm.validateSSOToken(orgId, 'fake-token');\n      assert.ok(result.valid);\n    });\n\n    it('returns null for unconfigured org', () => {\n      assert.equal(tm.validateSSOToken('no-org', 'token'), null);\n    });\n  });\n\n  describe('audit log', () => {\n    it('records actions', () => {\n      tm.addMember(orgId, ownerId, memberId);\n      const log = tm.getAuditLog(orgId, ownerId);\n      assert.ok(log.length >= 2); // org_created + member_added\n      assert.ok(log.some(e => e.action === 'member_added'));\n    });\n\n    it('throws for non-admin', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.throws(() => tm.getAuditLog(orgId, viewerId), /Admin access required/);\n    });\n  });\n\n  describe('permissions', () => {\n    it('canSubmit for member', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.MEMBER);\n      assert.ok(tm.canSubmit(orgId, memberId));\n    });\n\n    it('canView for viewer', () => {\n      tm.addMember(orgId, ownerId, viewerId, TEAM_ROLES.VIEWER);\n      assert.ok(tm.canView(orgId, viewerId));\n      assert.ok(!tm.canSubmit(orgId, viewerId));\n    });\n\n    it('canManage for admin', () => {\n      tm.addMember(orgId, ownerId, memberId, TEAM_ROLES.ADMIN);\n      assert.ok(tm.canManage(orgId, memberId));\n    });\n\n    it('owner has all permissions', () => {\n      assert.ok(tm.canSubmit(orgId, ownerId));\n      assert.ok(tm.canView(orgId, ownerId));\n      assert.ok(tm.canManage(orgId, ownerId));\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/teams.test.js (13 functions)",
      "tags": [
        "assert",
        "ownerId",
        "memberId",
        "viewerId",
        "org",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.76
    },
    {
      "id": "7fec2f95ec93e33c",
      "name": "coherency.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  computeCoherencyScore,\n  scoreSyntax,\n  scoreCompleteness,\n  scoreConsistency,\n  detectLanguage,\n  checkBalancedBraces,\n} = require('../src/core/coherency');\n\ndescribe('checkBalancedBraces', () => {\n  it('returns true for balanced braces', () => {\n    assert.equal(checkBalancedBraces('function f() { return [1, 2]; }'), true);\n  });\n\n  it('returns false for unbalanced braces', () => {\n    assert.equal(checkBalancedBraces('function f() { return [1, 2;'), false);\n  });\n\n  it('handles empty string', () => {\n    assert.equal(checkBalancedBraces(''), true);\n  });\n});\n\ndescribe('detectLanguage', () => {\n  it('detects javascript', () => {\n    assert.equal(detectLanguage('const x = () => { return 1; }'), 'javascript');\n  });\n\n  it('detects python', () => {\n    assert.equal(detectLanguage('def hello():\\n    print(\"hi\")'), 'python');\n  });\n\n  it('detects rust', () => {\n    assert.equal(detectLanguage('fn main() -> i32 { let mut x = 5; }'), 'rust');\n  });\n\n  it('returns unknown for ambiguous code', () => {\n    assert.equal(detectLanguage('x = 1'), 'unknown');\n  });\n});\n\ndescribe('scoreSyntax', () => {\n  it('scores valid JS as 1.0', () => {\n    assert.equal(scoreSyntax('var x = 1 + 2;', 'javascript'), 1.0);\n  });\n\n  it('scores broken JS lower', () => {\n    const score = scoreSyntax('function { broken', 'javascript');\n    assert.ok(score < 0.5);\n  });\n});\n\ndescribe('scoreCompleteness', () => {\n  it('scores complete code as 1.0', () => {\n    assert.equal(scoreCompleteness('function add(a, b) { return a + b; }'), 1.0);\n  });\n\n  it('penalizes TODO markers', () => {\n    const score = scoreCompleteness('function add(a, b) { // TODO: implement\\n}');\n    assert.ok(score < 1.0);\n  });\n\n  it('penalizes placeholder patterns', () => {\n    const score = scoreCompleteness('function add(a, b) { ... }');\n    assert.ok(score < 0.8);\n  });\n});\n\ndescribe('scoreConsistency', () => {\n  it('scores consistent code well', () => {\n    const code = 'function getData() {\\n  const myResult = fetchData();\\n  return myResult;\\n}';\n    assert.ok(scoreConsistency(code) >= 0.8);\n  });\n});\n\ndescribe('computeCoherencyScore', () => {\n  it('produces a score between 0 and 1', () => {\n    const result = computeCoherencyScore('function add(a, b) { return a + b; }');\n    assert.ok(result.total >= 0 && result.total <= 1);\n  });\n\n  it('scores proven code higher', () => {\n    const code = 'function add(a, b) { return a + b; }';\n    const withTest = computeCoherencyScore(code, { testPassed: true });\n    const withoutTest = computeCoherencyScore(code, { testPassed: false });\n    assert.ok(withTest.total > withoutTest.total);\n  });\n\n  it('includes breakdown', () => {\n    const result = computeCoherencyScore('const x = 1;');\n    assert.ok(result.breakdown);\n    assert.ok('syntaxValid' in result.breakdown);\n    assert.ok('completeness' in result.breakdown);\n    assert.ok('consistency' in result.breakdown);\n    assert.ok('testProof' in result.breakdown);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/coherency.test.js (11 functions)",
      "tags": [
        "assert",
        "f",
        "x",
        "score",
        "add",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "architectural",
      "coherency": 0.76
    },
    {
      "id": "b4133bdd10730e54",
      "name": "tagsTest",
      "code": "function tagsTest(x) {\\n  return x + 1;\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "tagsTest",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "80f7ac7542dbf525",
      "name": "init",
      "code": "function init(options) {\\n  return options;\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "init",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "f820eba2df8cf757",
      "name": "triple",
      "code": "function triple(n) {\\n  return n * 3;\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "triple",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "2af3a07b17b7587a",
      "name": "healthTest",
      "code": "function healthTest(n) {\\n  return n > 0 ? \"positive\" : \"negative\";\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "healthTest",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "251f96891641eeef",
      "name": "langTest",
      "code": "function langTest(s) {\\n  return s.toUpperCase();\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "langTest",
        "javascript",
        "harvested"
      ],
      "patternType": "testing",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "af385a8ac7aa854b",
      "name": "distTest",
      "code": "function distTest(arr) {\\n  return arr.sort((a, b) => a - b);\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "distTest",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "composite",
      "coherency": 0.755
    },
    {
      "id": "e56fa7ba4f92f08d",
      "name": "analyticsTest",
      "code": "function analyticsTest(data) {\\n  return data.map(x => x * 2).filter(x => x > 5);\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/upgrades.test.js",
      "tags": [
        "analyticsTest",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "31730fe3e3084371",
      "name": "clean",
      "code": "function clean(s) {\\n  return s.replace(/[^a-z]/g, \"\");\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/recycler.test.js",
      "tags": [
        "clean",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.755
    },
    {
      "id": "372b48f163bd2386",
      "name": "big",
      "code": "function big() {\\n' + '// padding\\n'.repeat(10000) + '}",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "big",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "d205288031ce6338",
      "name": "getData",
      "code": "function getData() {\\n  const myResult = fetchData();\\n  return myResult;\\n}",
      "language": "javascript",
      "description": "Harvested function from . — tests/coherency.test.js",
      "tags": [
        "getData",
        "javascript",
        "harvested"
      ],
      "patternType": "io",
      "complexity": "atomic",
      "coherency": 0.755
    },
    {
      "id": "50713686dbcdee30",
      "name": "f",
      "code": "function f() { ' + 'if (true) { '.repeat(10) + '}'.repeat(10) + ' }",
      "language": "javascript",
      "description": "Harvested function from . — tests/ast.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "composite",
      "coherency": 0.755
    },
    {
      "id": "69e6b8eec6fd21bb",
      "name": "history",
      "code": "/**\n * Verified Code History Store\n *\n * Persistent store for code that has PROVEN itself (passed validation + coherency).\n *\n * Backend: SQLite (Node 22+ built-in) when available, falls back to flat JSON.\n *\n * Each entry includes:\n * - The code itself\n * - Coherency score breakdown\n * - Validation proof (test results)\n * - Metadata (language, tags, description, author)\n * - Timestamps and reliability tracking\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst DEFAULT_STORE_DIR = '.remembrance';\nconst HISTORY_FILE = 'verified-history.json';\n\n/**\n * Try to load SQLiteStore. Returns null if node:sqlite unavailable.\n */\nfunction tryLoadSQLite() {\n  try {\n    const { DatabaseSync } = require('node:sqlite');\n    if (DatabaseSync) {\n      const { SQLiteStore } = require('./sqlite');\n      return SQLiteStore;\n    }\n  } catch {}\n  return null;\n}\n\nclass VerifiedHistoryStore {\n  constructor(baseDir = process.cwd()) {\n    this.storeDir = path.join(baseDir, DEFAULT_STORE_DIR);\n    this._backend = 'json'; // default\n\n    const SQLiteStoreClass = tryLoadSQLite();\n    if (SQLiteStoreClass) {\n      try {\n        // Shared SQLite instance — keyed by storeDir\n        if (!VerifiedHistoryStore._sqliteInstances) {\n          VerifiedHistoryStore._sqliteInstances = new Map();\n        }\n        if (VerifiedHistoryStore._sqliteInstances.has(this.storeDir)) {\n          this._sqlite = VerifiedHistoryStore._sqliteInstances.get(this.storeDir);\n        } else {\n          this._sqlite = new SQLiteStoreClass(baseDir);\n          VerifiedHistoryStore._sqliteInstances.set(this.storeDir, this._sqlite);\n        }\n        this._backend = 'sqlite';\n      } catch {\n        this._ensureJSONStore();\n      }\n    } else {\n      this._ensureJSONStore();\n    }\n  }\n\n  get backend() { return this._backend; }\n\n  // ─── JSON fallback methods ───\n\n  _ensureJSONStore() {\n    this.historyPath = path.join(this.storeDir, HISTORY_FILE);\n    if (!fs.existsSync(this.storeDir)) {\n      fs.mkdirSync(this.storeDir, { recursive: true });\n    }\n    if (!fs.existsSync(this.historyPath)) {\n      this._writeJSON({ entries: [], meta: { created: new Date().toISOString(), version: 1 } });\n    }\n  }\n\n  _readJSON() {\n    return JSON.parse(fs.readFileSync(this.historyPath, 'utf-8'));\n  }\n\n  _writeJSON(data) {\n    fs.writeFileSync(this.historyPath, JSON.stringify(data, null, 2), 'utf-8');\n  }\n\n  _hash(code) {\n    return crypto.createHash('sha256').update(code).digest('hex').slice(0, 16);\n  }\n\n  // ─── Public API ───\n\n  add(entry) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.addEntry(entry);\n    }\n    return this._addJSON(entry);\n  }\n\n  getAll(filters = {}) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.getAllEntries(filters);\n    }\n    return this._getAllJSON(filters);\n  }\n\n  get(id) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.getEntry(id);\n    }\n    return this._getJSON(id);\n  }\n\n  recordUsage(id, succeeded) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.recordEntryUsage(id, succeeded);\n    }\n    return this._recordUsageJSON(id, succeeded);\n  }\n\n  prune(minCoherency = 0.4) {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.pruneEntries(minCoherency);\n    }\n    return this._pruneJSON(minCoherency);\n  }\n\n  summary() {\n    if (this._backend === 'sqlite') {\n      return this._sqlite.entrySummary();\n    }\n    return this._summaryJSON();\n  }\n\n  /**\n   * Get the shared SQLite store instance (for PatternLibrary to share).\n   */\n  getSQLiteStore() {\n    return this._sqlite || null;\n  }\n\n  // ─── JSON implementations (fallback) ───\n\n  _addJSON(entry) {\n    const data = this._readJSON();\n    const id = this._hash(entry.code + Date.now().toString());\n    const record = {\n      id,\n      code: entry.code,\n      language: entry.language || 'unknown',\n      description: entry.description || '',\n      tags: entry.tags || [],\n      author: entry.author || 'anonymous',\n      coherencyScore: entry.coherencyScore,\n      validation: {\n        testPassed: entry.testPassed ?? null,\n        testOutput: entry.testOutput || null,\n        validatedAt: new Date().toISOString(),\n      },\n      reliability: {\n        timesUsed: 0,\n        timesSucceeded: 0,\n        historicalScore: 1.0,\n      },\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    data.entries.push(record);\n    this._writeJSON(data);\n    return record;\n  }\n\n  _getAllJSON(filters = {}) {\n    const data = this._readJSON();\n    let entries = data.entries;\n    if (filters.language) {\n      entries = entries.filter(e => e.language.toLowerCase() === filters.language.toLowerCase());\n    }\n    if (filters.minCoherency != null) {\n      entries = entries.filter(e => (e.coherencyScore?.total ?? 0) >= filters.minCoherency);\n    }\n    if (filters.tags && filters.tags.length > 0) {\n      const filterTags = new Set(filters.tags.map(t => t.toLowerCase()));\n      entries = entries.filter(e => e.tags.some(t => filterTags.has(t.toLowerCase())));\n    }\n    return entries;\n  }\n\n  _getJSON(id) {\n    const data = this._readJSON();\n    return data.entries.find(e => e.id === id) || null;\n  }\n\n  _recordUsageJSON(id, succeeded) {\n    const data = this._readJSON();\n    const entry = data.entries.find(e => e.id === id);\n    if (!entry) return null;\n    entry.reliability.timesUsed += 1;\n    if (succeeded) entry.reliability.timesSucceeded += 1;\n    entry.reliability.historicalScore =\n      entry.reliability.timesUsed > 0\n        ? entry.reliability.timesSucceeded / entry.reliability.timesUsed\n        : 0.5;\n    entry.updatedAt = new Date().toISOString();\n    this._writeJSON(data);\n    return entry;\n  }\n\n  _pruneJSON(minCoherency = 0.4) {\n    const data = this._readJSON();\n    const before = data.entries.length;\n    data.entries = data.entries.filter(e => (e.coherencyScore?.total ?? 0) >= minCoherency);\n    this._writeJSON(data);\n    return { removed: before - data.entries.length, remaining: data.entries.length };\n  }\n\n  _summaryJSON() {\n    const entries = this.getAll();\n    return {\n      totalEntries: entries.length,\n      languages: [...new Set(entries.map(e => e.language))],\n      avgCoherency: entries.length > 0\n        ? Math.round(entries.reduce((s, e) => s + (e.coherencyScore?.total ?? 0), 0) / entries.length * 1000) / 1000\n        : 0,\n      topTags: getTopTags(entries, 10),\n    };\n  }\n}\n\nfunction getTopTags(entries, limit) {\n  const counts = {};\n  for (const e of entries) {\n    for (const tag of e.tags) {\n      const t = tag.toLowerCase();\n      counts[t] = (counts[t] || 0) + 1;\n    }\n  }\n  return Object.entries(counts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, limit)\n    .map(([tag, count]) => ({ tag, count }));\n}\n\nmodule.exports = { VerifiedHistoryStore, DEFAULT_STORE_DIR, HISTORY_FILE };\n",
      "language": "javascript",
      "description": "Harvested from . — src/store/history.js (17 functions)",
      "tags": [
        "fs",
        "path",
        "crypto",
        "DEFAULT_STORE_DIR",
        "HISTORY_FILE",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.75
    },
    {
      "id": "e720b99e094b2056",
      "name": "seeds-extended",
      "code": "/**\n * Extended Seed Patterns — bulk patterns from common utility libraries.\n */\nconst EXTENDED_SEEDS = [\n  // ═══ JavaScript: String Utilities ═══\n  { name: 'capitalize', language: 'javascript', patternType: 'utility',\n    description: 'Capitalize first letter of string', tags: ['string', 'utility'],\n    code: `function capitalize(s) {\n  return s ? s[0].toUpperCase() + s.slice(1) : '';\n}`,\n    testCode: `if (capitalize('hello') !== 'Hello') throw new Error('basic');\nif (capitalize('') !== '') throw new Error('empty');\nif (capitalize('A') !== 'A') throw new Error('already');` },\n\n  { name: 'camel-case', language: 'javascript', patternType: 'utility',\n    description: 'Convert string to camelCase', tags: ['string', 'utility', 'case'],\n    code: `function camelCase(str) {\n  return str.replace(/[-_\\\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')\n            .replace(/^[A-Z]/, c => c.toLowerCase());\n}`,\n    testCode: `if (camelCase('hello-world') !== 'helloWorld') throw new Error('kebab');\nif (camelCase('foo_bar') !== 'fooBar') throw new Error('snake');\nif (camelCase('Hello World') !== 'helloWorld') throw new Error('space');` },\n\n  { name: 'snake-case', language: 'javascript', patternType: 'utility',\n    description: 'Convert string to snake_case', tags: ['string', 'utility', 'case'],\n    code: `function snakeCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n            .replace(/[-\\\\s]+/g, '_').toLowerCase();\n}`,\n    testCode: `if (snakeCase('helloWorld') !== 'hello_world') throw new Error('camel');\nif (snakeCase('hello-world') !== 'hello_world') throw new Error('kebab');\nif (snakeCase('Hello World') !== 'hello_world') throw new Error('space');` },\n\n  { name: 'kebab-case', language: 'javascript', patternType: 'utility',\n    description: 'Convert string to kebab-case', tags: ['string', 'utility', 'case'],\n    code: `function kebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/[_\\\\s]+/g, '-').toLowerCase();\n}`,\n    testCode: `if (kebabCase('helloWorld') !== 'hello-world') throw new Error('camel');\nif (kebabCase('hello_world') !== 'hello-world') throw new Error('snake');\nif (kebabCase('Hello World') !== 'hello-world') throw new Error('space');` },\n\n  { name: 'truncate', language: 'javascript', patternType: 'utility',\n    description: 'Truncate string to max length with suffix', tags: ['string', 'utility'],\n    code: `function truncate(str, maxLen, suffix) {\n  suffix = suffix || '...';\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - suffix.length) + suffix;\n}`,\n    testCode: `if (truncate('hello world', 8) !== 'hello...') throw new Error('basic');\nif (truncate('hi', 10) !== 'hi') throw new Error('short');\nif (truncate('abcdef', 5, '..') !== 'abc..') throw new Error('custom');` },\n\n  { name: 'slugify', language: 'javascript', patternType: 'utility',\n    description: 'Convert string to URL-friendly slug', tags: ['string', 'utility', 'url'],\n    code: `function slugify(str) {\n  return str.toLowerCase().trim()\n    .replace(/[^a-z0-9\\\\s-]/g, '')\n    .replace(/[\\\\s-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}`,\n    testCode: `if (slugify('Hello World!') !== 'hello-world') throw new Error('basic');\nif (slugify('  foo  bar  ') !== 'foo-bar') throw new Error('spaces');\nif (slugify('a--b') !== 'a-b') throw new Error('dashes');` },\n\n  { name: 'escape-html', language: 'javascript', patternType: 'utility',\n    description: 'Escape HTML special characters', tags: ['string', 'security', 'html'],\n    code: `function escapeHTML(str) {\n  var map = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\n  return str.replace(/[&<>\"']/g, function(c) { return map[c]; });\n}`,\n    testCode: `if (escapeHTML('<b>hi</b>') !== '&lt;b&gt;hi&lt;/b&gt;') throw new Error('tags');\nif (escapeHTML('a&b') !== 'a&amp;b') throw new Error('amp');\nif (escapeHTML('hello') !== 'hello') throw new Error('noop');` },\n\n  { name: 'unescape-html', language: 'javascript', patternType: 'utility',\n    description: 'Unescape HTML entities back to characters', tags: ['string', 'html'],\n    code: `function unescapeHTML(str) {\n  var map = {'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};\n  return str.replace(/&(?:amp|lt|gt|quot|#39);/g, function(m) { return map[m]; });\n}`,\n    testCode: `if (unescapeHTML('&lt;b&gt;') !== '<b>') throw new Error('tags');\nif (unescapeHTML('a&amp;b') !== 'a&b') throw new Error('amp');\nif (unescapeHTML('hello') !== 'hello') throw new Error('noop');` },\n\n  { name: 'reverse-string', language: 'javascript', patternType: 'utility',\n    description: 'Reverse a string', tags: ['string', 'utility'],\n    code: `function reverseString(str) {\n  return str.split('').reverse().join('');\n}`,\n    testCode: `if (reverseString('hello') !== 'olleh') throw new Error('basic');\nif (reverseString('') !== '') throw new Error('empty');\nif (reverseString('a') !== 'a') throw new Error('single');` },\n\n  { name: 'word-count', language: 'javascript', patternType: 'utility',\n    description: 'Count words in a string', tags: ['string', 'utility'],\n    code: `function wordCount(str) {\n  var trimmed = str.trim();\n  if (!trimmed) return 0;\n  return trimmed.split(/\\\\s+/).length;\n}`,\n    testCode: `if (wordCount('hello world') !== 2) throw new Error('two');\nif (wordCount('  one  ') !== 1) throw new Error('padded');\nif (wordCount('') !== 0) throw new Error('empty');\nif (wordCount('a b c d') !== 4) throw new Error('four');` },\n\n  { name: 'title-case', language: 'javascript', patternType: 'utility',\n    description: 'Convert string to Title Case', tags: ['string', 'utility', 'case'],\n    code: `function titleCase(str) {\n  return str.replace(/\\\\b\\\\w/g, function(c) { return c.toUpperCase(); });\n}`,\n    testCode: `if (titleCase('hello world') !== 'Hello World') throw new Error('basic');\nif (titleCase('foo bar baz') !== 'Foo Bar Baz') throw new Error('three');` },\n\n  { name: 'repeat-string', language: 'javascript', patternType: 'utility',\n    description: 'Repeat a string n times', tags: ['string', 'utility'],\n    code: `function repeatString(str, n) {\n  var result = '';\n  for (var i = 0; i < n; i++) result += str;\n  return result;\n}`,\n    testCode: `if (repeatString('ab', 3) !== 'ababab') throw new Error('basic');\nif (repeatString('x', 0) !== '') throw new Error('zero');\nif (repeatString('', 5) !== '') throw new Error('empty');` },\n\n  { name: 'is-palindrome', language: 'javascript', patternType: 'utility',\n    description: 'Check if string is a palindrome', tags: ['string', 'utility', 'validation'],\n    code: `function isPalindrome(str) {\n  var clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return clean === clean.split('').reverse().join('');\n}`,\n    testCode: `if (!isPalindrome('racecar')) throw new Error('basic');\nif (!isPalindrome('A man a plan a canal Panama')) throw new Error('sentence');\nif (isPalindrome('hello')) throw new Error('not palindrome');\nif (!isPalindrome('')) throw new Error('empty');` },\n\n  { name: 'count-occurrences', language: 'javascript', patternType: 'utility',\n    description: 'Count occurrences of substring in string', tags: ['string', 'utility'],\n    code: `function countOccurrences(str, sub) {\n  if (!sub.length) return 0;\n  var count = 0, pos = 0;\n  while ((pos = str.indexOf(sub, pos)) !== -1) { count++; pos += sub.length; }\n  return count;\n}`,\n    testCode: `if (countOccurrences('abcabc', 'abc') !== 2) throw new Error('two');\nif (countOccurrences('hello', 'x') !== 0) throw new Error('none');\nif (countOccurrences('aaa', 'a') !== 3) throw new Error('single');` },\n\n  { name: 'pad-string', language: 'javascript', patternType: 'utility',\n    description: 'Pad string to target length', tags: ['string', 'utility'],\n    code: `function padString(str, len, ch, right) {\n  ch = ch || ' ';\n  while (str.length < len) {\n    str = right ? str + ch : ch + str;\n  }\n  return str;\n}`,\n    testCode: `if (padString('5', 3, '0') !== '005') throw new Error('left');\nif (padString('5', 3, '0', true) !== '500') throw new Error('right');\nif (padString('hello', 3) !== 'hello') throw new Error('longer');` },\n\n  // ═══ JavaScript: Array Utilities ═══\n  { name: 'chunk', language: 'javascript', patternType: 'utility',\n    description: 'Split array into chunks of given size', tags: ['array', 'utility'],\n    code: `function chunk(arr, size) {\n  var result = [];\n  for (var i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}`,\n    testCode: `if (JSON.stringify(chunk([1,2,3,4,5], 2)) !== '[[1,2],[3,4],[5]]') throw new Error('basic');\nif (JSON.stringify(chunk([], 3)) !== '[]') throw new Error('empty');\nif (JSON.stringify(chunk([1], 5)) !== '[[1]]') throw new Error('small');` },\n\n  { name: 'compact', language: 'javascript', patternType: 'utility',\n    description: 'Remove falsy values from array', tags: ['array', 'utility', 'filter'],\n    code: `function compact(arr) {\n  return arr.filter(Boolean);\n}`,\n    testCode: `var r = compact([0, 1, false, 2, '', 3, null, undefined]);\nif (JSON.stringify(r) !== '[1,2,3]') throw new Error('basic: ' + JSON.stringify(r));\nif (compact([]).length !== 0) throw new Error('empty');` },\n\n  { name: 'difference', language: 'javascript', patternType: 'utility',\n    description: 'Get items in first array not in second', tags: ['array', 'utility', 'set'],\n    code: `function difference(a, b) {\n  var set = new Set(b);\n  return a.filter(function(x) { return !set.has(x); });\n}`,\n    testCode: `if (JSON.stringify(difference([1,2,3], [2,3,4])) !== '[1]') throw new Error('basic');\nif (difference([1,2], [1,2]).length !== 0) throw new Error('same');\nif (JSON.stringify(difference([1,2,3], [])) !== '[1,2,3]') throw new Error('empty b');` },\n\n  { name: 'intersection', language: 'javascript', patternType: 'utility',\n    description: 'Get items present in both arrays', tags: ['array', 'utility', 'set'],\n    code: `function intersection(a, b) {\n  var set = new Set(b);\n  return a.filter(function(x) { return set.has(x); });\n}`,\n    testCode: `if (JSON.stringify(intersection([1,2,3], [2,3,4])) !== '[2,3]') throw new Error('basic');\nif (intersection([1,2], [3,4]).length !== 0) throw new Error('none');` },\n\n  { name: 'union', language: 'javascript', patternType: 'utility',\n    description: 'Get unique items from both arrays', tags: ['array', 'utility', 'set'],\n    code: `function union(a, b) {\n  return Array.from(new Set(a.concat(b)));\n}`,\n    testCode: `var r = union([1,2,3], [2,3,4]);\nif (JSON.stringify(r.sort()) !== '[1,2,3,4]') throw new Error('basic');\nif (union([], []).length !== 0) throw new Error('empty');` },\n\n  { name: 'zip', language: 'javascript', patternType: 'utility',\n    description: 'Zip multiple arrays into array of tuples', tags: ['array', 'utility'],\n    code: `function zip() {\n  var arrays = Array.prototype.slice.call(arguments);\n  var len = Math.min.apply(null, arrays.map(function(a) { return a.length; }));\n  var result = [];\n  for (var i = 0; i < len; i++) result.push(arrays.map(function(a) { return a[i]; }));\n  return result;\n}`,\n    testCode: `var r = zip([1,2,3], ['a','b','c']);\nif (JSON.stringify(r) !== '[[1,\"a\"],[2,\"b\"],[3,\"c\"]]') throw new Error('basic');\nif (zip([1], [2,3]).length !== 1) throw new Error('unequal');` },\n\n  { name: 'unzip', language: 'javascript', patternType: 'utility',\n    description: 'Unzip array of tuples into separate arrays', tags: ['array', 'utility'],\n    code: `function unzip(pairs) {\n  if (!pairs.length) return [];\n  return pairs[0].map(function(_, i) {\n    return pairs.map(function(p) { return p[i]; });\n  });\n}`,\n    testCode: `var r = unzip([[1,'a'],[2,'b'],[3,'c']]);\nif (JSON.stringify(r) !== '[[1,2,3],[\"a\",\"b\",\"c\"]]') throw new Error('basic');\nif (unzip([]).length !== 0) throw new Error('empty');` },\n\n  { name: 'range', language: 'javascript', patternType: 'utility',\n    description: 'Generate array of numbers in range', tags: ['array', 'utility', 'generator'],\n    code: `function range(start, end, step) {\n  step = step || 1;\n  var result = [];\n  if (step > 0) { for (var i = start; i < end; i += step) result.push(i); }\n  else { for (var i = start; i > end; i += step) result.push(i); }\n  return result;\n}`,\n    testCode: `if (JSON.stringify(range(0, 5)) !== '[0,1,2,3,4]') throw new Error('basic');\nif (JSON.stringify(range(0, 10, 2)) !== '[0,2,4,6,8]') throw new Error('step');\nif (JSON.stringify(range(5, 0, -1)) !== '[5,4,3,2,1]') throw new Error('neg');` },\n\n  { name: 'unique', language: 'javascript', patternType: 'utility',\n    description: 'Get unique values from array', tags: ['array', 'utility', 'set'],\n    code: `function unique(arr) {\n  return Array.from(new Set(arr));\n}`,\n    testCode: `if (JSON.stringify(unique([1,2,2,3,3,3])) !== '[1,2,3]') throw new Error('basic');\nif (unique([]).length !== 0) throw new Error('empty');\nif (unique([1]).length !== 1) throw new Error('single');` },\n\n  { name: 'partition', language: 'javascript', patternType: 'utility',\n    description: 'Split array into two based on predicate', tags: ['array', 'utility'],\n    code: `function partition(arr, fn) {\n  var pass = [], fail = [];\n  for (var i = 0; i < arr.length; i++) {\n    (fn(arr[i]) ? pass : fail).push(arr[i]);\n  }\n  return [pass, fail];\n}`,\n    testCode: `var r = partition([1,2,3,4,5], function(n) { return n % 2 === 0; });\nif (JSON.stringify(r[0]) !== '[2,4]') throw new Error('evens');\nif (JSON.stringify(r[1]) !== '[1,3,5]') throw new Error('odds');` },\n\n  { name: 'take', language: 'javascript', patternType: 'utility',\n    description: 'Take first n elements from array', tags: ['array', 'utility'],\n    code: `function take(arr, n) {\n  return arr.slice(0, n);\n}`,\n    testCode: `if (JSON.stringify(take([1,2,3,4], 2)) !== '[1,2]') throw new Error('basic');\nif (take([], 5).length !== 0) throw new Error('empty');\nif (JSON.stringify(take([1,2], 5)) !== '[1,2]') throw new Error('over');` },\n\n  { name: 'drop', language: 'javascript', patternType: 'utility',\n    description: 'Drop first n elements from array', tags: ['array', 'utility'],\n    code: `function drop(arr, n) {\n  return arr.slice(n);\n}`,\n    testCode: `if (JSON.stringify(drop([1,2,3,4], 2)) !== '[3,4]') throw new Error('basic');\nif (drop([], 5).length !== 0) throw new Error('empty');` },\n\n  { name: 'last', language: 'javascript', patternType: 'utility',\n    description: 'Get last element of array', tags: ['array', 'utility'],\n    code: `function last(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}`,\n    testCode: `if (last([1,2,3]) !== 3) throw new Error('basic');\nif (last([]) !== undefined) throw new Error('empty');\nif (last([42]) !== 42) throw new Error('single');` },\n\n  { name: 'without', language: 'javascript', patternType: 'utility',\n    description: 'Remove specified values from array', tags: ['array', 'utility', 'filter'],\n    code: `function without(arr) {\n  var values = Array.prototype.slice.call(arguments, 1);\n  var set = new Set(values);\n  return arr.filter(function(x) { return !set.has(x); });\n}`,\n    testCode: `if (JSON.stringify(without([1,2,3,4], 2, 4)) !== '[1,3]') throw new Error('basic');\nif (without([1,1,1], 1).length !== 0) throw new Error('all');` },\n\n  { name: 'sample-array', language: 'javascript', patternType: 'utility',\n    description: 'Get random sample of n items from array', tags: ['array', 'utility', 'random'],\n    code: `function sampleArray(arr, n) {\n  var shuffled = arr.slice();\n  for (var i = shuffled.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;\n  }\n  return shuffled.slice(0, n || 1);\n}`,\n    testCode: `var s = sampleArray([1,2,3,4,5], 3);\nif (s.length !== 3) throw new Error('length');\nif (!s.every(function(x) { return [1,2,3,4,5].indexOf(x) >= 0; })) throw new Error('items');\nif (sampleArray([], 3).length !== 0) throw new Error('empty');` },\n\n\n  // ═══ JavaScript: Object Utilities ═══\n  { name: 'pick', language: 'javascript', patternType: 'utility',\n    description: 'Pick specified keys from object', tags: ['object', 'utility'],\n    code: `function pick(obj, keys) {\n  var result = {};\n  for (var i = 0; i < keys.length; i++) {\n    if (keys[i] in obj) result[keys[i]] = obj[keys[i]];\n  }\n  return result;\n}`,\n    testCode: `var r = pick({a:1,b:2,c:3}, ['a','c']);\nif (r.a !== 1 || r.c !== 3) throw new Error('picked');\nif ('b' in r) throw new Error('excluded');` },\n\n  { name: 'omit', language: 'javascript', patternType: 'utility',\n    description: 'Omit specified keys from object', tags: ['object', 'utility'],\n    code: `function omit(obj, keys) {\n  var set = new Set(keys);\n  var result = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k) && !set.has(k)) result[k] = obj[k];\n  }\n  return result;\n}`,\n    testCode: `var r = omit({a:1,b:2,c:3}, ['b']);\nif (r.a !== 1 || r.c !== 3) throw new Error('kept');\nif ('b' in r) throw new Error('omitted');` },\n\n  { name: 'deep-merge', language: 'javascript', patternType: 'utility',\n    description: 'Deep merge multiple objects', tags: ['object', 'utility', 'merge'],\n    code: `function deepMerge(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        target[key] = deepMerge(target[key] || {}, source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}`,\n    testCode: `var r = deepMerge({a:1, b:{c:2, d:3}}, {b:{c:9, e:4}});\nif (r.a !== 1) throw new Error('a');\nif (r.b.c !== 9) throw new Error('override');\nif (r.b.d !== 3) throw new Error('keep');\nif (r.b.e !== 4) throw new Error('add');` },\n\n  { name: 'map-values', language: 'javascript', patternType: 'utility',\n    description: 'Map over object values', tags: ['object', 'utility', 'transform'],\n    code: `function mapValues(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = fn(obj[keys[i]], keys[i]);\n  }\n  return result;\n}`,\n    testCode: `var r = mapValues({a:1,b:2}, function(v) { return v * 2; });\nif (r.a !== 2 || r.b !== 4) throw new Error('doubled');` },\n\n  { name: 'map-keys', language: 'javascript', patternType: 'utility',\n    description: 'Map over object keys', tags: ['object', 'utility', 'transform'],\n    code: `function mapKeys(obj, fn) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[fn(keys[i], obj[keys[i]])] = obj[keys[i]];\n  }\n  return result;\n}`,\n    testCode: `var r = mapKeys({a:1,b:2}, function(k) { return k.toUpperCase(); });\nif (r.A !== 1 || r.B !== 2) throw new Error('mapped');\nif ('a' in r) throw new Error('old key');` },\n\n  { name: 'invert', language: 'javascript', patternType: 'utility',\n    description: 'Swap keys and values in object', tags: ['object', 'utility'],\n    code: `function invert(obj) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    result[obj[keys[i]]] = keys[i];\n  }\n  return result;\n}`,\n    testCode: `var r = invert({a:'x', b:'y'});\nif (r.x !== 'a' || r.y !== 'b') throw new Error('inverted');` },\n\n  { name: 'defaults', language: 'javascript', patternType: 'utility',\n    description: 'Set default values without overriding existing', tags: ['object', 'utility'],\n    code: `function defaults(obj) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (source.hasOwnProperty(key) && obj[key] === undefined) {\n        obj[key] = source[key];\n      }\n    }\n  }\n  return obj;\n}`,\n    testCode: `var r = defaults({a:1}, {a:9, b:2}, {c:3});\nif (r.a !== 1) throw new Error('no override');\nif (r.b !== 2) throw new Error('added b');\nif (r.c !== 3) throw new Error('added c');` },\n\n  { name: 'freeze-deep', language: 'javascript', patternType: 'utility',\n    description: 'Recursively freeze object', tags: ['object', 'utility', 'immutable'],\n    code: `function freezeDeep(obj) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function(key) {\n    if (obj[key] && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {\n      freezeDeep(obj[key]);\n    }\n  });\n  return obj;\n}`,\n    testCode: `var o = freezeDeep({a:1, b:{c:2}});\nif (!Object.isFrozen(o)) throw new Error('frozen');\nif (!Object.isFrozen(o.b)) throw new Error('deep frozen');` },\n\n  { name: 'has-path', language: 'javascript', patternType: 'utility',\n    description: 'Check if object has nested path', tags: ['object', 'utility', 'path'],\n    code: `function hasPath(obj, path) {\n  var keys = path.split('.');\n  var current = obj;\n  for (var i = 0; i < keys.length; i++) {\n    if (current == null || !current.hasOwnProperty(keys[i])) return false;\n    current = current[keys[i]];\n  }\n  return true;\n}`,\n    testCode: `if (!hasPath({a:{b:{c:1}}}, 'a.b.c')) throw new Error('deep');\nif (hasPath({a:1}, 'a.b')) throw new Error('missing');\nif (hasPath({}, 'x')) throw new Error('empty');` },\n\n  { name: 'rename-keys', language: 'javascript', patternType: 'utility',\n    description: 'Rename object keys via mapping', tags: ['object', 'utility', 'transform'],\n    code: `function renameKeys(obj, keyMap) {\n  var result = {};\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    var newKey = keyMap[keys[i]] || keys[i];\n    result[newKey] = obj[keys[i]];\n  }\n  return result;\n}`,\n    testCode: `var r = renameKeys({a:1, b:2}, {a:'x'});\nif (r.x !== 1) throw new Error('renamed');\nif (r.b !== 2) throw new Error('kept');\nif ('a' in r) throw new Error('old key');` },\n\n  // ═══ JavaScript: Math/Number ═══\n  { name: 'clamp', language: 'javascript', patternType: 'utility',\n    description: 'Clamp number between min and max', tags: ['math', 'utility'],\n    code: `function clamp(val, min, max) {\n  return Math.min(Math.max(val, min), max);\n}`,\n    testCode: `if (clamp(5, 0, 10) !== 5) throw new Error('in range');\nif (clamp(-5, 0, 10) !== 0) throw new Error('below');\nif (clamp(15, 0, 10) !== 10) throw new Error('above');` },\n\n  { name: 'lerp', language: 'javascript', patternType: 'utility',\n    description: 'Linear interpolation between two values', tags: ['math', 'utility', 'animation'],\n    code: `function lerp(a, b, t) {\n  return a + (b - a) * t;\n}`,\n    testCode: `if (lerp(0, 10, 0.5) !== 5) throw new Error('mid');\nif (lerp(0, 10, 0) !== 0) throw new Error('start');\nif (lerp(0, 10, 1) !== 10) throw new Error('end');` },\n\n  { name: 'fibonacci', language: 'javascript', patternType: 'algorithm',\n    description: 'Get nth Fibonacci number iteratively', tags: ['math', 'algorithm'],\n    code: `function fibonacci(n) {\n  if (n <= 1) return n;\n  var a = 0, b = 1;\n  for (var i = 2; i <= n; i++) { var t = b; b = a + b; a = t; }\n  return b;\n}`,\n    testCode: `if (fibonacci(0) !== 0) throw new Error('f0');\nif (fibonacci(1) !== 1) throw new Error('f1');\nif (fibonacci(10) !== 55) throw new Error('f10');\nif (fibonacci(20) !== 6765) throw new Error('f20');` },\n\n  { name: 'is-prime', language: 'javascript', patternType: 'algorithm',\n    description: 'Check if number is prime', tags: ['math', 'algorithm', 'validation'],\n    code: `function isPrime(n) {\n  if (n < 2) return false;\n  if (n < 4) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (var i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}`,\n    testCode: `if (!isPrime(2)) throw new Error('2');\nif (!isPrime(17)) throw new Error('17');\nif (isPrime(1)) throw new Error('1');\nif (isPrime(15)) throw new Error('15');` },\n\n  { name: 'gcd', language: 'javascript', patternType: 'algorithm',\n    description: 'Greatest common divisor using Euclidean algorithm', tags: ['math', 'algorithm'],\n    code: `function gcd(a, b) {\n  a = Math.abs(a); b = Math.abs(b);\n  while (b) { var t = b; b = a % b; a = t; }\n  return a;\n}`,\n    testCode: `if (gcd(12, 8) !== 4) throw new Error('12,8');\nif (gcd(7, 13) !== 1) throw new Error('coprime');\nif (gcd(0, 5) !== 5) throw new Error('zero');` },\n\n  { name: 'factorial', language: 'javascript', patternType: 'algorithm',\n    description: 'Compute factorial of n', tags: ['math', 'algorithm'],\n    code: `function factorial(n) {\n  if (n < 0) throw new Error('negative');\n  var result = 1;\n  for (var i = 2; i <= n; i++) result *= i;\n  return result;\n}`,\n    testCode: `if (factorial(0) !== 1) throw new Error('0!');\nif (factorial(5) !== 120) throw new Error('5!');\nif (factorial(1) !== 1) throw new Error('1!');\ntry { factorial(-1); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }` },\n\n  { name: 'round-to', language: 'javascript', patternType: 'utility',\n    description: 'Round number to specified decimal places', tags: ['math', 'utility'],\n    code: `function roundTo(num, places) {\n  var factor = Math.pow(10, places);\n  return Math.round((num + Number.EPSILON) * factor) / factor;\n}`,\n    testCode: `if (roundTo(3.14159, 2) !== 3.14) throw new Error('2 places');\nif (roundTo(1.005, 2) !== 1.01) throw new Error('rounding');\nif (roundTo(2.675, 2) !== 2.68) throw new Error('banker');\nif (roundTo(5, 0) !== 5) throw new Error('integer');` },\n\n  { name: 'random-int', language: 'javascript', patternType: 'utility',\n    description: 'Random integer between min and max inclusive', tags: ['math', 'utility', 'random'],\n    code: `function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}`,\n    testCode: `for (var i = 0; i < 100; i++) {\n  var r = randomInt(1, 10);\n  if (r < 1 || r > 10) throw new Error('out of range: ' + r);\n  if (!Number.isInteger(r)) throw new Error('not int');\n}` },\n\n  { name: 'sum', language: 'javascript', patternType: 'utility',\n    description: 'Sum array of numbers', tags: ['math', 'utility', 'array'],\n    code: `function sum(arr) {\n  var total = 0;\n  for (var i = 0; i < arr.length; i++) total += arr[i];\n  return total;\n}`,\n    testCode: `if (sum([1,2,3,4]) !== 10) throw new Error('basic');\nif (sum([]) !== 0) throw new Error('empty');\nif (sum([-1, 1]) !== 0) throw new Error('negative');` },\n\n  { name: 'median', language: 'javascript', patternType: 'utility',\n    description: 'Calculate median of number array', tags: ['math', 'utility', 'statistics'],\n    code: `function median(arr) {\n  if (!arr.length) return undefined;\n  var sorted = arr.slice().sort(function(a,b) { return a - b; });\n  var mid = sorted.length >>> 1;\n  return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;\n}`,\n    testCode: `if (median([3,1,2]) !== 2) throw new Error('odd');\nif (median([4,1,3,2]) !== 2.5) throw new Error('even');\nif (median([5]) !== 5) throw new Error('single');\nif (median([]) !== undefined) throw new Error('empty');` },\n\n  // ═══ JavaScript: Async Patterns ═══\n  { name: 'sleep', language: 'javascript', patternType: 'utility',\n    description: 'Promise-based delay function', tags: ['async', 'utility', 'promise'],\n    code: `function sleep(ms) {\n  return new Promise(function(resolve) { setTimeout(resolve, ms); });\n}`,\n    testCode: `if (typeof sleep(1).then !== 'function') throw new Error('not promise');\nvar start = Date.now();\nsleep(10).then(function() {\n  if (Date.now() - start < 5) throw new Error('too fast');\n});` },\n\n  { name: 'promise-timeout', language: 'javascript', patternType: 'utility',\n    description: 'Wrap promise with timeout', tags: ['async', 'utility', 'promise'],\n    code: `function promiseTimeout(promise, ms) {\n  var timeout = new Promise(function(_, reject) {\n    setTimeout(function() { reject(new Error('timeout')); }, ms);\n  });\n  return Promise.race([promise, timeout]);\n}`,\n    testCode: `promiseTimeout(Promise.resolve(42), 100).then(function(v) {\n  if (v !== 42) throw new Error('value');\n});` },\n\n  { name: 'deferred', language: 'javascript', patternType: 'utility',\n    description: 'Create deferred promise with external resolve/reject', tags: ['async', 'utility', 'promise'],\n    code: `function deferred() {\n  var resolve, reject;\n  var promise = new Promise(function(res, rej) { resolve = res; reject = rej; });\n  return { promise: promise, resolve: resolve, reject: reject };\n}`,\n    testCode: `var d = deferred();\nif (typeof d.promise.then !== 'function') throw new Error('promise');\nif (typeof d.resolve !== 'function') throw new Error('resolve');\nif (typeof d.reject !== 'function') throw new Error('reject');\nd.promise.then(function(v) { if (v !== 'ok') throw new Error('value'); });\nd.resolve('ok');` },\n\n  { name: 'p-map', language: 'javascript', patternType: 'utility',\n    description: 'Parallel map with concurrency limit', tags: ['async', 'utility', 'concurrency'],\n    code: `function pMap(items, fn, concurrency) {\n  concurrency = concurrency || Infinity;\n  var results = new Array(items.length);\n  var index = 0;\n  function worker() {\n    var work = Promise.resolve();\n    while (index < items.length) {\n      work = (function(i) {\n        return work.then(function() { return fn(items[i], i); })\n          .then(function(r) { results[i] = r; });\n      })(index++);\n    }\n    return work;\n  }\n  var workers = [];\n  for (var i = 0; i < Math.min(concurrency, items.length); i++) workers.push(worker());\n  return Promise.all(workers).then(function() { return results; });\n}`,\n    testCode: `pMap([1,2,3], function(x) { return Promise.resolve(x * 2); }, 2).then(function(r) {\n  if (JSON.stringify(r) !== '[2,4,6]') throw new Error('result: ' + JSON.stringify(r));\n});` },\n\n  // ═══ JavaScript: Data Structures ═══\n  { name: 'stack', language: 'javascript', patternType: 'data-structure',\n    description: 'Stack with push, pop, peek operations', tags: ['data-structure', 'stack'],\n    code: `function Stack() {\n  this.items = [];\n}\nStack.prototype.push = function(item) { this.items.push(item); };\nStack.prototype.pop = function() { return this.items.pop(); };\nStack.prototype.peek = function() { return this.items[this.items.length - 1]; };\nStack.prototype.isEmpty = function() { return this.items.length === 0; };\nStack.prototype.size = function() { return this.items.length; };`,\n    testCode: `var s = new Stack();\ns.push(1); s.push(2); s.push(3);\nif (s.peek() !== 3) throw new Error('peek');\nif (s.pop() !== 3) throw new Error('pop');\nif (s.size() !== 2) throw new Error('size');\nif (s.isEmpty()) throw new Error('not empty');` },\n\n  { name: 'min-heap', language: 'javascript', patternType: 'data-structure',\n    description: 'Min-heap with insert and extractMin', tags: ['data-structure', 'heap', 'priority-queue'],\n    code: `function MinHeap() { this.data = []; }\nMinHeap.prototype.insert = function(val) {\n  this.data.push(val);\n  var i = this.data.length - 1;\n  while (i > 0) {\n    var p = (i - 1) >>> 1;\n    if (this.data[p] <= this.data[i]) break;\n    var t = this.data[p]; this.data[p] = this.data[i]; this.data[i] = t;\n    i = p;\n  }\n};\nMinHeap.prototype.extractMin = function() {\n  if (!this.data.length) return undefined;\n  var min = this.data[0], last = this.data.pop();\n  if (this.data.length > 0) {\n    this.data[0] = last;\n    var i = 0, n = this.data.length;\n    while (true) {\n      var m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.data[l] < this.data[m]) m = l;\n      if (r < n && this.data[r] < this.data[m]) m = r;\n      if (m === i) break;\n      var t = this.data[i]; this.data[i] = this.data[m]; this.data[m] = t;\n      i = m;\n    }\n  }\n  return min;\n};\nMinHeap.prototype.peek = function() { return this.data[0]; };`,\n    testCode: `var h = new MinHeap();\nh.insert(5); h.insert(2); h.insert(8); h.insert(1);\nif (h.peek() !== 1) throw new Error('peek');\nif (h.extractMin() !== 1) throw new Error('min1');\nif (h.extractMin() !== 2) throw new Error('min2');\nif (h.extractMin() !== 5) throw new Error('min3');` },\n\n  { name: 'linked-list', language: 'javascript', patternType: 'data-structure',\n    description: 'Singly linked list', tags: ['data-structure', 'linked-list'],\n    code: `function LinkedList() { this.head = null; this.length = 0; }\nLinkedList.prototype.push = function(val) {\n  this.head = { val: val, next: this.head };\n  this.length++;\n};\nLinkedList.prototype.pop = function() {\n  if (!this.head) return undefined;\n  var val = this.head.val;\n  this.head = this.head.next;\n  this.length--;\n  return val;\n};\nLinkedList.prototype.has = function(val) {\n  var n = this.head;\n  while (n) { if (n.val === val) return true; n = n.next; }\n  return false;\n};\nLinkedList.prototype.toArray = function() {\n  var r = [], n = this.head;\n  while (n) { r.push(n.val); n = n.next; }\n  return r;\n};`,\n    testCode: `var ll = new LinkedList();\nll.push(1); ll.push(2); ll.push(3);\nif (ll.length !== 3) throw new Error('length');\nif (!ll.has(2)) throw new Error('has');\nif (ll.pop() !== 3) throw new Error('pop');\nif (JSON.stringify(ll.toArray()) !== '[2,1]') throw new Error('toArray');` },\n\n  { name: 'priority-queue', language: 'javascript', patternType: 'data-structure',\n    description: 'Priority queue using min-heap', tags: ['data-structure', 'priority-queue', 'heap'],\n    code: `function PriorityQueue() { this.heap = []; }\nPriorityQueue.prototype.enqueue = function(value, priority) {\n  this.heap.push({value: value, priority: priority});\n  var i = this.heap.length - 1;\n  while (i > 0) {\n    var p = (i-1) >>> 1;\n    if (this.heap[p].priority <= this.heap[i].priority) break;\n    var t = this.heap[p]; this.heap[p] = this.heap[i]; this.heap[i] = t;\n    i = p;\n  }\n};\nPriorityQueue.prototype.dequeue = function() {\n  if (!this.heap.length) return undefined;\n  var top = this.heap[0], last = this.heap.pop();\n  if (this.heap.length > 0) {\n    this.heap[0] = last;\n    var i = 0, n = this.heap.length;\n    while (true) {\n      var m = i, l = 2*i+1, r = 2*i+2;\n      if (l < n && this.heap[l].priority < this.heap[m].priority) m = l;\n      if (r < n && this.heap[r].priority < this.heap[m].priority) m = r;\n      if (m === i) break;\n      var t = this.heap[i]; this.heap[i] = this.heap[m]; this.heap[m] = t;\n      i = m;\n    }\n  }\n  return top.value;\n};`,\n    testCode: `var pq = new PriorityQueue();\npq.enqueue('low', 3); pq.enqueue('high', 1); pq.enqueue('med', 2);\nif (pq.dequeue() !== 'high') throw new Error('first');\nif (pq.dequeue() !== 'med') throw new Error('second');\nif (pq.dequeue() !== 'low') throw new Error('third');` },\n\n  { name: 'bloom-filter', language: 'javascript', patternType: 'data-structure',\n    description: 'Bloom filter for probabilistic set membership', tags: ['data-structure', 'bloom-filter', 'probabilistic'],\n    code: `function BloomFilter(size) {\n  this.size = size || 256;\n  this.bits = new Uint8Array(this.size);\n}\nBloomFilter.prototype._hashes = function(val) {\n  var str = String(val), h1 = 0, h2 = 0;\n  for (var i = 0; i < str.length; i++) {\n    h1 = (h1 * 31 + str.charCodeAt(i)) % this.size;\n    h2 = (h2 * 37 + str.charCodeAt(i)) % this.size;\n  }\n  return [h1, h2, (h1 + h2) % this.size];\n};\nBloomFilter.prototype.add = function(val) {\n  var h = this._hashes(val);\n  for (var i = 0; i < h.length; i++) this.bits[h[i]] = 1;\n};\nBloomFilter.prototype.has = function(val) {\n  var h = this._hashes(val);\n  for (var i = 0; i < h.length; i++) { if (!this.bits[h[i]]) return false; }\n  return true;\n};`,\n    testCode: `var bf = new BloomFilter(256);\nbf.add('hello'); bf.add('world');\nif (!bf.has('hello')) throw new Error('has hello');\nif (!bf.has('world')) throw new Error('has world');` },\n\n  // ═══ JavaScript: Functional ═══\n  { name: 'curry', language: 'javascript', patternType: 'utility',\n    description: 'Curry a function for partial application', tags: ['functional', 'utility'],\n    code: `function curry(fn) {\n  return function curried() {\n    var args = Array.prototype.slice.call(arguments);\n    if (args.length >= fn.length) return fn.apply(this, args);\n    return function() {\n      return curried.apply(this, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  };\n}`,\n    testCode: `var add = curry(function(a, b, c) { return a + b + c; });\nif (add(1, 2, 3) !== 6) throw new Error('all');\nif (add(1)(2)(3) !== 6) throw new Error('curried');\nif (add(1, 2)(3) !== 6) throw new Error('partial');` },\n\n  { name: 'compose', language: 'javascript', patternType: 'utility',\n    description: 'Compose functions right-to-left', tags: ['functional', 'utility'],\n    code: `function compose() {\n  var fns = Array.prototype.slice.call(arguments);\n  return function(input) {\n    return fns.reduceRight(function(val, fn) { return fn(val); }, input);\n  };\n}`,\n    testCode: `var double = function(x) { return x * 2; };\nvar inc = function(x) { return x + 1; };\nvar transform = compose(String, inc, double);\nif (transform(5) !== '11') throw new Error('compose: ' + transform(5));` },\n\n  { name: 'partial', language: 'javascript', patternType: 'utility',\n    description: 'Partially apply arguments to function', tags: ['functional', 'utility'],\n    code: `function partial(fn) {\n  var preset = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    return fn.apply(this, preset.concat(Array.prototype.slice.call(arguments)));\n  };\n}`,\n    testCode: `var add = function(a, b, c) { return a + b + c; };\nvar add10 = partial(add, 10);\nif (add10(2, 3) !== 15) throw new Error('partial');\nvar add10and20 = partial(add, 10, 20);\nif (add10and20(3) !== 33) throw new Error('two');` },\n\n  { name: 'once', language: 'javascript', patternType: 'utility',\n    description: 'Ensure function is only called once', tags: ['functional', 'utility'],\n    code: `function once(fn) {\n  var called = false, result;\n  return function() {\n    if (!called) { called = true; result = fn.apply(this, arguments); }\n    return result;\n  };\n}`,\n    testCode: `var count = 0;\nvar inc = once(function() { return ++count; });\nif (inc() !== 1) throw new Error('first');\nif (inc() !== 1) throw new Error('cached');\nif (count !== 1) throw new Error('called once');` },\n\n  { name: 'negate', language: 'javascript', patternType: 'utility',\n    description: 'Create function that negates predicate result', tags: ['functional', 'utility'],\n    code: `function negate(fn) {\n  return function() { return !fn.apply(this, arguments); };\n}`,\n    testCode: `var isEven = function(n) { return n % 2 === 0; };\nvar isOdd = negate(isEven);\nif (!isOdd(3)) throw new Error('odd');\nif (isOdd(4)) throw new Error('even');` },\n\n  { name: 'flip', language: 'javascript', patternType: 'utility',\n    description: 'Reverse argument order of function', tags: ['functional', 'utility'],\n    code: `function flip(fn) {\n  return function() {\n    return fn.apply(this, Array.prototype.slice.call(arguments).reverse());\n  };\n}`,\n    testCode: `var div = function(a, b) { return a / b; };\nvar flipped = flip(div);\nif (flipped(2, 10) !== 5) throw new Error('flipped');` },\n\n  // ═══ JavaScript: Date/Time ═══\n  { name: 'is-leap-year', language: 'javascript', patternType: 'utility',\n    description: 'Check if year is a leap year', tags: ['date', 'utility', 'validation'],\n    code: `function isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}`,\n    testCode: `if (!isLeapYear(2000)) throw new Error('2000');\nif (!isLeapYear(2024)) throw new Error('2024');\nif (isLeapYear(1900)) throw new Error('1900');\nif (isLeapYear(2023)) throw new Error('2023');` },\n\n  { name: 'days-between', language: 'javascript', patternType: 'utility',\n    description: 'Count days between two dates', tags: ['date', 'utility'],\n    code: `function daysBetween(d1, d2) {\n  var ms = Math.abs(new Date(d1) - new Date(d2));\n  return Math.floor(ms / 86400000);\n}`,\n    testCode: `if (daysBetween('2024-01-01', '2024-01-31') !== 30) throw new Error('jan');\nif (daysBetween('2024-01-01', '2024-01-01') !== 0) throw new Error('same');` },\n\n  { name: 'days-in-month', language: 'javascript', patternType: 'utility',\n    description: 'Get number of days in a given month', tags: ['date', 'utility'],\n    code: `function daysInMonth(year, month) {\n  return new Date(year, month, 0).getDate();\n}`,\n    testCode: `if (daysInMonth(2024, 2) !== 29) throw new Error('feb leap');\nif (daysInMonth(2023, 2) !== 28) throw new Error('feb normal');\nif (daysInMonth(2024, 1) !== 31) throw new Error('jan');` },\n\n  // ═══ JavaScript: Validation ═══\n  { name: 'is-url', language: 'javascript', patternType: 'utility',\n    description: 'Validate URL string', tags: ['validation', 'utility', 'url'],\n    code: `function isURL(str) {\n  try {\n    var url = new URL(str);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch(e) { return false; }\n}`,\n    testCode: `if (!isURL('https://example.com')) throw new Error('https');\nif (!isURL('http://example.com/path?q=1')) throw new Error('path');\nif (isURL('not-a-url')) throw new Error('invalid');\nif (isURL('ftp://x.com')) throw new Error('ftp');` },\n\n  { name: 'is-json', language: 'javascript', patternType: 'utility',\n    description: 'Check if string is valid JSON', tags: ['validation', 'utility', 'json'],\n    code: `function isJSON(str) {\n  try { JSON.parse(str); return true; } catch(e) { return false; }\n}`,\n    testCode: `if (!isJSON('{\"a\":1}')) throw new Error('object');\nif (!isJSON('[1,2,3]')) throw new Error('array');\nif (!isJSON('\"hello\"')) throw new Error('string');\nif (isJSON('not json')) throw new Error('invalid');` },\n\n  { name: 'luhn-check', language: 'javascript', patternType: 'algorithm',\n    description: 'Luhn algorithm for credit card validation', tags: ['validation', 'algorithm'],\n    code: `function luhnCheck(num) {\n  var str = String(num).replace(/\\\\D/g, '');\n  var sum = 0, alt = false;\n  for (var i = str.length - 1; i >= 0; i--) {\n    var n = parseInt(str[i], 10);\n    if (alt) { n *= 2; if (n > 9) n -= 9; }\n    sum += n;\n    alt = !alt;\n  }\n  return sum % 10 === 0;\n}`,\n    testCode: `if (!luhnCheck('79927398713')) throw new Error('valid');\nif (luhnCheck('1234567890')) throw new Error('invalid');` },\n\n  // ═══ JavaScript: HTTP/Web ═══\n  { name: 'parse-query-string', language: 'javascript', patternType: 'utility',\n    description: 'Parse URL query string to object', tags: ['http', 'utility', 'url'],\n    code: `function parseQueryString(qs) {\n  if (!qs || qs === '?') return {};\n  return qs.replace(/^\\\\?/, '').split('&').reduce(function(obj, pair) {\n    var parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || '');\n    return obj;\n  }, {});\n}`,\n    testCode: `var r = parseQueryString('?foo=bar&baz=42');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (Object.keys(parseQueryString('')).length !== 0) throw new Error('empty');` },\n\n  { name: 'build-query-string', language: 'javascript', patternType: 'utility',\n    description: 'Build URL query string from object', tags: ['http', 'utility', 'url'],\n    code: `function buildQueryString(obj) {\n  var pairs = Object.keys(obj).filter(function(k) {\n    return obj[k] !== undefined;\n  }).map(function(k) {\n    return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);\n  });\n  return pairs.length ? '?' + pairs.join('&') : '';\n}`,\n    testCode: `var r = buildQueryString({foo: 'bar', baz: 42});\nif (!r.includes('foo=bar')) throw new Error('foo');\nif (!r.includes('baz=42')) throw new Error('baz');\nif (r[0] !== '?') throw new Error('question');\nif (buildQueryString({}) !== '') throw new Error('empty');` },\n\n  { name: 'parse-cookie', language: 'javascript', patternType: 'utility',\n    description: 'Parse cookie header string to object', tags: ['http', 'utility', 'cookie'],\n    code: `function parseCookie(str) {\n  if (!str) return {};\n  return str.split(';').reduce(function(obj, pair) {\n    var parts = pair.trim().split('=');\n    var key = parts[0].trim();\n    obj[key] = parts.slice(1).join('=').trim();\n    return obj;\n  }, {});\n}`,\n    testCode: `var r = parseCookie('foo=bar; baz=42; name=hello');\nif (r.foo !== 'bar') throw new Error('foo');\nif (r.baz !== '42') throw new Error('baz');\nif (r.name !== 'hello') throw new Error('name');\nif (Object.keys(parseCookie('')).length !== 0) throw new Error('empty');` },\n];\n\n/**\n * Seed the pattern library with all extended patterns.\n * Skips patterns that already exist (by name match).\n */\nfunction seedExtendedLibrary(oracle, { verbose = false } = {}) {\n  const existing = oracle.patterns.getAll();\n  const existingNames = new Set(existing.map(p => p.name));\n\n  let registered = 0, skipped = 0, failed = 0;\n  const failures = [];\n\n  for (const seed of EXTENDED_SEEDS) {\n    if (existingNames.has(seed.name)) {\n      skipped++;\n      continue;\n    }\n\n    const result = oracle.registerPattern(seed);\n    if (result.registered) {\n      registered++;\n      if (verbose) {\n        console.log(`  [OK]   ${seed.name} — coherency ${result.validation.coherencyScore.total.toFixed(3)}`);\n      }\n    } else {\n      failed++;\n      failures.push({ name: seed.name, reason: result.reason });\n      console.log(`  [FAIL] ${seed.name}: ${result.reason}`);\n    }\n  }\n\n  return { registered, skipped, failed, failures, total: EXTENDED_SEEDS.length };\n}\n\nmodule.exports = { seedExtendedLibrary, EXTENDED_SEEDS };\n",
      "language": "javascript",
      "description": "Harvested from . — src/patterns/seeds-extended.js (149 functions)",
      "tags": [
        "EXTENDED_SEEDS",
        "capitalize",
        "camelCase",
        "snakeCase",
        "kebabCase",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.75
    },
    {
      "id": "36bf2f11e4388875",
      "name": "feedback",
      "code": "/**\n * CI Feedback Loop — Automatic reliability tracking.\n *\n * When code pulled from the Oracle is used in a project and CI runs,\n * this module:\n *\n * 1. Scans for a tracking manifest (.remembrance/pulled-patterns.json)\n *    that records which patterns/entries were pulled into the project\n * 2. Checks CI test results (exit code, test output)\n * 3. Reports success/failure back to the Oracle store\n * 4. Logs feedback to an append-only audit trail\n *\n * Usage from CI:\n *   # After tests pass:\n *   node src/cli.js ci-feedback --status pass\n *   # After tests fail:\n *   node src/cli.js ci-feedback --status fail\n *   # Auto-detect from exit code:\n *   npm test && node src/cli.js ci-feedback --status pass || node src/cli.js ci-feedback --status fail\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst PULLED_MANIFEST = 'pulled-patterns.json';\nconst FEEDBACK_LOG = 'ci-feedback-log.json';\n\nclass CIFeedbackReporter {\n  constructor(oracle, options = {}) {\n    this.oracle = oracle;\n    this.storeDir = oracle.store.storeDir || path.join(options.baseDir || process.cwd(), '.remembrance');\n    this.manifestPath = path.join(this.storeDir, PULLED_MANIFEST);\n    this.logPath = path.join(this.storeDir, FEEDBACK_LOG);\n  }\n\n  /**\n   * Record that a pattern/entry was pulled from the Oracle.\n   * Call this when code is retrieved so we know what to track.\n   */\n  trackPull(entry) {\n    const manifest = this._readManifest();\n    const record = {\n      id: entry.id,\n      name: entry.name || null,\n      source: entry.source || 'unknown',\n      pulledAt: new Date().toISOString(),\n      reported: false,\n    };\n\n    // Dedupe: don't track the same ID twice\n    if (!manifest.tracked.find(t => t.id === entry.id)) {\n      manifest.tracked.push(record);\n      this._writeManifest(manifest);\n    }\n\n    return record;\n  }\n\n  /**\n   * Report CI results back to the Oracle.\n   * Called after CI tests run — updates reliability scores for all tracked patterns.\n   *\n   * Returns: { reported, updated, errors }\n   */\n  reportResults(status, options = {}) {\n    const { testOutput = '', commitSha = '', ciProvider = 'unknown' } = options;\n    const succeeded = status === 'pass' || status === 'success' || status === true;\n    const manifest = this._readManifest();\n\n    if (manifest.tracked.length === 0) {\n      return { reported: 0, updated: [], errors: [], message: 'No tracked patterns to report on' };\n    }\n\n    const unreported = manifest.tracked.filter(t => !t.reported);\n    if (unreported.length === 0) {\n      return { reported: 0, updated: [], errors: [], message: 'All tracked patterns already reported' };\n    }\n\n    const updated = [];\n    const errors = [];\n    const now = new Date().toISOString();\n\n    for (const tracked of unreported) {\n      try {\n        // Try pattern feedback first, then entry feedback\n        let result = this.oracle.patternFeedback(tracked.id, succeeded);\n        if (!result.success) {\n          result = this.oracle.feedback(tracked.id, succeeded);\n        }\n\n        if (result.success || result.newReliability != null) {\n          tracked.reported = true;\n          tracked.reportedAt = now;\n          tracked.status = succeeded ? 'pass' : 'fail';\n          updated.push({\n            id: tracked.id,\n            name: tracked.name,\n            succeeded,\n            newReliability: result.newReliability ?? result.successCount / result.usageCount,\n          });\n        } else {\n          errors.push({ id: tracked.id, error: result.error || 'Unknown error' });\n        }\n      } catch (err) {\n        errors.push({ id: tracked.id, error: err.message });\n      }\n    }\n\n    // Update manifest\n    this._writeManifest(manifest);\n\n    // Append to audit log\n    this._appendLog({\n      timestamp: now,\n      status: succeeded ? 'pass' : 'fail',\n      commitSha,\n      ciProvider,\n      testOutput: testOutput.slice(0, 500), // Truncate to keep log manageable\n      patternsReported: updated.length,\n      errorsCount: errors.length,\n      details: updated,\n    });\n\n    return {\n      reported: updated.length,\n      updated,\n      errors,\n      message: `Reported ${updated.length} pattern(s) as ${succeeded ? 'pass' : 'fail'}`,\n    };\n  }\n\n  /**\n   * Get feedback statistics.\n   */\n  stats() {\n    const manifest = this._readManifest();\n    const log = this._readLog();\n\n    return {\n      trackedPatterns: manifest.tracked.length,\n      unreported: manifest.tracked.filter(t => !t.reported).length,\n      reported: manifest.tracked.filter(t => t.reported).length,\n      totalFeedbackEvents: log.length,\n      recentFeedback: log.slice(-5),\n    };\n  }\n\n  /**\n   * Clear the tracking manifest (e.g. after a release).\n   */\n  clearTracking() {\n    this._writeManifest({ tracked: [], clearedAt: new Date().toISOString() });\n  }\n\n  // ─── Internal ───\n\n  _readManifest() {\n    if (!fs.existsSync(this.manifestPath)) {\n      return { tracked: [] };\n    }\n    try {\n      return JSON.parse(fs.readFileSync(this.manifestPath, 'utf-8'));\n    } catch {\n      return { tracked: [] };\n    }\n  }\n\n  _writeManifest(data) {\n    if (!fs.existsSync(this.storeDir)) {\n      fs.mkdirSync(this.storeDir, { recursive: true });\n    }\n    fs.writeFileSync(this.manifestPath, JSON.stringify(data, null, 2), 'utf-8');\n  }\n\n  _readLog() {\n    if (!fs.existsSync(this.logPath)) return [];\n    try {\n      return JSON.parse(fs.readFileSync(this.logPath, 'utf-8'));\n    } catch {\n      return [];\n    }\n  }\n\n  _appendLog(entry) {\n    const log = this._readLog();\n    log.push(entry);\n    // Keep last 1000 entries\n    const trimmed = log.slice(-1000);\n    fs.writeFileSync(this.logPath, JSON.stringify(trimmed, null, 2), 'utf-8');\n  }\n}\n\n/**\n * Auto-track pulled patterns.\n * Wraps Oracle.resolve() and Oracle.query() to automatically track\n * which patterns are being used in the project.\n */\nfunction wrapWithTracking(oracle) {\n  const reporter = new CIFeedbackReporter(oracle);\n\n  const origResolve = oracle.resolve.bind(oracle);\n  oracle.resolve = function (request) {\n    const result = origResolve(request);\n    if (result.pattern && result.decision === 'pull') {\n      reporter.trackPull({ id: result.pattern.id, name: result.pattern.name, source: 'pattern' });\n    }\n    return result;\n  };\n\n  const origQuery = oracle.query.bind(oracle);\n  oracle.query = function (query) {\n    const results = origQuery(query);\n    for (const r of results.slice(0, 1)) { // Track only the top result\n      reporter.trackPull({ id: r.id, name: r.description, source: 'history' });\n    }\n    return results;\n  };\n\n  oracle._feedbackReporter = reporter;\n  return reporter;\n}\n\nmodule.exports = { CIFeedbackReporter, wrapWithTracking };\n",
      "language": "javascript",
      "description": "Harvested from . — src/ci/feedback.js (19 functions)",
      "tags": [
        "fs",
        "path",
        "PULLED_MANIFEST",
        "FEEDBACK_LOG",
        "manifest",
        "javascript",
        "harvested"
      ],
      "patternType": "data-structure",
      "complexity": "architectural",
      "coherency": 0.75
    },
    {
      "id": "e268748f0d77308f",
      "name": "seeds",
      "code": "/**\n * Seed Patterns — proven, tested atomic code patterns.\n *\n * Each pattern includes:\n * - The code itself\n * - A test that proves it works\n * - Metadata (name, description, tags, type)\n *\n * These are the foundation of the pattern library.\n * Every single one has been tested and validated.\n */\n\nconst SEEDS = [\n  // ─── Algorithms ───\n  {\n    name: 'binary-search',\n    code: `function binarySearch(arr, target) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}`,\n    testCode: `if (binarySearch([1,2,3,4,5], 3) !== 2) throw new Error(\"mid\");\nif (binarySearch([1,2,3,4,5], 1) !== 0) throw new Error(\"first\");\nif (binarySearch([1,2,3,4,5], 5) !== 4) throw new Error(\"last\");\nif (binarySearch([1,2,3,4,5], 6) !== -1) throw new Error(\"missing\");\nif (binarySearch([], 1) !== -1) throw new Error(\"empty\");`,\n    language: 'javascript',\n    description: 'Binary search on a sorted array — O(log n)',\n    tags: ['search', 'algorithm', 'array', 'sorted', 'binary-search'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'merge-sort',\n    code: `function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = arr.length >>> 1;\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    result.push(left[i] <= right[j] ? left[i++] : right[j++]);\n  }\n  while (i < left.length) result.push(left[i++]);\n  while (j < right.length) result.push(right[j++]);\n  return result;\n}`,\n    testCode: `const r1 = mergeSort([5,3,8,1,9,2]);\nif (JSON.stringify(r1) !== '[1,2,3,5,8,9]') throw new Error(\"sort: \" + r1);\nif (JSON.stringify(mergeSort([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(mergeSort([1])) !== '[1]') throw new Error(\"single\");\nif (JSON.stringify(mergeSort([3,1,1,2])) !== '[1,1,2,3]') throw new Error(\"dups\");`,\n    language: 'javascript',\n    description: 'Merge sort — stable O(n log n) sorting',\n    tags: ['sort', 'algorithm', 'array', 'merge-sort', 'stable'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'depth-first-search',\n    code: `function dfs(graph, start, visited = new Set()) {\n  visited.add(start);\n  const result = [start];\n  for (const neighbor of (graph[start] || [])) {\n    if (!visited.has(neighbor)) {\n      result.push(...dfs(graph, neighbor, visited));\n    }\n  }\n  return result;\n}`,\n    testCode: `const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = dfs(g, 'a');\nif (!r.includes('a') || !r.includes('b') || !r.includes('c') || !r.includes('d')) throw new Error(\"missing nodes\");\nif (r[0] !== 'a') throw new Error(\"should start at root\");\nif (r.length !== 4) throw new Error(\"should visit all: \" + r);`,\n    language: 'javascript',\n    description: 'Depth-first search on adjacency list graph',\n    tags: ['graph', 'search', 'algorithm', 'dfs', 'traversal'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'breadth-first-search',\n    code: `function bfs(graph, start) {\n  const visited = new Set([start]);\n  const queue = [start];\n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of (graph[node] || [])) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}`,\n    testCode: `const g = { a: ['b','c'], b: ['d'], c: ['d'], d: [] };\nconst r = bfs(g, 'a');\nif (r[0] !== 'a') throw new Error(\"start\");\nif (r.length !== 4) throw new Error(\"all nodes\");\nif (r.indexOf('b') > r.indexOf('d') && r.indexOf('c') > r.indexOf('d')) throw new Error(\"bfs order\");`,\n    language: 'javascript',\n    description: 'Breadth-first search on adjacency list graph',\n    tags: ['graph', 'search', 'algorithm', 'bfs', 'traversal'],\n    patternType: 'algorithm',\n  },\n\n  // ─── Utilities ───\n  {\n    name: 'debounce',\n    code: `function debounce(fn, delay) {\n  let timer;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}`,\n    testCode: `const d = debounce(() => {}, 100);\nif (typeof d !== 'function') throw new Error(\"should return function\");`,\n    language: 'javascript',\n    description: 'Debounce — delays function execution until pause in calls',\n    tags: ['utility', 'async', 'debounce', 'rate-limit', 'timing'],\n    patternType: 'utility',\n  },\n  {\n    name: 'throttle',\n    code: `function throttle(fn, limit) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      return fn.apply(this, args);\n    }\n  };\n}`,\n    testCode: `let count = 0;\nconst t = throttle(() => count++, 50);\nt(); t(); t();\nif (count !== 1) throw new Error(\"should throttle: \" + count);`,\n    language: 'javascript',\n    description: 'Throttle — limits function to one call per time window',\n    tags: ['utility', 'async', 'throttle', 'rate-limit', 'timing'],\n    patternType: 'utility',\n  },\n  {\n    name: 'memoize',\n    code: `function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}`,\n    testCode: `let calls = 0;\nconst add = memoize((a, b) => { calls++; return a + b; });\nif (add(1, 2) !== 3) throw new Error(\"first call\");\nif (add(1, 2) !== 3) throw new Error(\"cached call\");\nif (calls !== 1) throw new Error(\"should cache: \" + calls);\nif (add(2, 3) !== 5) throw new Error(\"diff args\");\nif (calls !== 2) throw new Error(\"new args: \" + calls);`,\n    language: 'javascript',\n    description: 'Memoize — caches function results by arguments',\n    tags: ['utility', 'cache', 'memoize', 'performance', 'optimization'],\n    patternType: 'utility',\n  },\n  {\n    name: 'deep-clone',\n    code: `function deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (const key of Object.keys(obj)) {\n    cloned[key] = deepClone(obj[key]);\n  }\n  return cloned;\n}`,\n    testCode: `const orig = { a: 1, b: { c: [1,2,{d:3}] }, e: new Date(0) };\nconst clone = deepClone(orig);\nif (clone === orig) throw new Error(\"same ref\");\nif (clone.b === orig.b) throw new Error(\"shallow copy\");\nclone.b.c[2].d = 999;\nif (orig.b.c[2].d === 999) throw new Error(\"mutation leaked\");\nif (clone.e.getTime() !== 0) throw new Error(\"date clone\");\nif (deepClone(null) !== null) throw new Error(\"null\");\nif (deepClone(42) !== 42) throw new Error(\"primitive\");`,\n    language: 'javascript',\n    description: 'Deep clone — recursively copies objects, arrays, dates, regexps',\n    tags: ['utility', 'clone', 'deep-copy', 'object', 'immutable'],\n    patternType: 'utility',\n  },\n  {\n    name: 'retry-async',\n    code: `async function retry(fn, maxRetries = 3, delay = 1000) {\n  let lastError;\n  for (let i = 0; i <= maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (i < maxRetries) {\n        await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));\n      }\n    }\n  }\n  throw lastError;\n}`,\n    testCode: `let attempts = 0;\nconst fn = async () => { attempts++; if (attempts < 3) throw new Error(\"fail\"); return \"ok\"; };\nretry(fn, 3, 1).then(r => {\n  if (r !== \"ok\") throw new Error(\"result\");\n  if (attempts !== 3) throw new Error(\"attempts: \" + attempts);\n});`,\n    language: 'javascript',\n    description: 'Retry with exponential backoff for async operations',\n    tags: ['utility', 'async', 'retry', 'backoff', 'error-handling', 'resilience'],\n    patternType: 'utility',\n  },\n  {\n    name: 'pipe',\n    code: `function pipe(...fns) {\n  return function(input) {\n    return fns.reduce((val, fn) => fn(val), input);\n  };\n}`,\n    testCode: `const double = x => x * 2;\nconst inc = x => x + 1;\nconst str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");`,\n    language: 'javascript',\n    description: 'Function pipe — compose left-to-right',\n    tags: ['utility', 'functional', 'pipe', 'compose', 'transform'],\n    patternType: 'utility',\n  },\n\n  // ─── Data Structures ───\n  {\n    name: 'lru-cache',\n    code: `class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}`,\n    testCode: `const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");`,\n    language: 'javascript',\n    description: 'LRU Cache using Map for O(1) get/set with eviction',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  },\n  {\n    name: 'trie',\n    code: `class Trie {\n  constructor() { this.root = {}; }\n  insert(word) {\n    let node = this.root;\n    for (const ch of word) { node = node[ch] = node[ch] || {}; }\n    node._end = true;\n  }\n  search(word) {\n    let node = this.root;\n    for (const ch of word) { if (!node[ch]) return false; node = node[ch]; }\n    return node._end === true;\n  }\n  startsWith(prefix) {\n    let node = this.root;\n    for (const ch of prefix) { if (!node[ch]) return false; node = node[ch]; }\n    return true;\n  }\n}`,\n    testCode: `const t = new Trie();\nt.insert(\"hello\"); t.insert(\"help\");\nif (!t.search(\"hello\")) throw new Error(\"find hello\");\nif (t.search(\"hell\")) throw new Error(\"partial\");\nif (!t.startsWith(\"hel\")) throw new Error(\"prefix\");\nif (t.startsWith(\"xyz\")) throw new Error(\"bad prefix\");`,\n    language: 'javascript',\n    description: 'Trie (prefix tree) for fast string lookups and prefix search',\n    tags: ['data-structure', 'trie', 'string', 'prefix', 'search'],\n    patternType: 'data-structure',\n  },\n\n  // ─── Validation ───\n  {\n    name: 'validate-email',\n    code: `function validateEmail(email) {\n  if (typeof email !== 'string') return false;\n  const re = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n  return re.test(email) && email.length <= 254;\n}`,\n    testCode: `if (!validateEmail(\"user@example.com\")) throw new Error(\"valid\");\nif (!validateEmail(\"a@b.co\")) throw new Error(\"short valid\");\nif (validateEmail(\"@example.com\")) throw new Error(\"no local\");\nif (validateEmail(\"user@\")) throw new Error(\"no domain\");\nif (validateEmail(\"\")) throw new Error(\"empty\");\nif (validateEmail(null)) throw new Error(\"null\");\nif (validateEmail(\"has space@x.com\")) throw new Error(\"space\");`,\n    language: 'javascript',\n    description: 'Email validation with basic RFC compliance',\n    tags: ['validation', 'email', 'regex', 'input', 'sanitize'],\n    patternType: 'validation',\n  },\n\n  // ─── Transformation ───\n  {\n    name: 'flatten-deep',\n    code: `function flattenDeep(arr) {\n  const result = [];\n  const stack = [...arr];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    if (Array.isArray(item)) {\n      stack.push(...item);\n    } else {\n      result.unshift(item);\n    }\n  }\n  return result;\n}`,\n    testCode: `if (JSON.stringify(flattenDeep([1,[2,[3,[4]]]])) !== '[1,2,3,4]') throw new Error(\"nested\");\nif (JSON.stringify(flattenDeep([])) !== '[]') throw new Error(\"empty\");\nif (JSON.stringify(flattenDeep([1,2,3])) !== '[1,2,3]') throw new Error(\"flat\");`,\n    language: 'javascript',\n    description: 'Flatten deeply nested arrays iteratively (no recursion limit)',\n    tags: ['transformation', 'array', 'flatten', 'iterative', 'utility'],\n    patternType: 'transformation',\n  },\n  {\n    name: 'group-by',\n    code: `function groupBy(arr, keyFn) {\n  const groups = {};\n  for (const item of arr) {\n    const key = typeof keyFn === 'function' ? keyFn(item) : item[keyFn];\n    (groups[key] = groups[key] || []).push(item);\n  }\n  return groups;\n}`,\n    testCode: `const data = [{n:'a',t:1},{n:'b',t:1},{n:'c',t:2}];\nconst g = groupBy(data, 't');\nif (g[1].length !== 2) throw new Error(\"group 1\");\nif (g[2].length !== 1) throw new Error(\"group 2\");\nconst g2 = groupBy(data, item => item.t);\nif (g2[1].length !== 2) throw new Error(\"fn key\");`,\n    language: 'javascript',\n    description: 'Group array items by a key or function',\n    tags: ['transformation', 'array', 'group', 'aggregate', 'utility'],\n    patternType: 'transformation',\n  },\n\n  // ─── Python patterns ───\n  {\n    name: 'binary-search-py',\n    code: `def binary_search(arr, target):\n    lo, hi = 0, len(arr) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1`,\n    testCode: `assert binary_search([1,2,3,4,5], 3) == 2, \"mid\"\nassert binary_search([1,2,3,4,5], 1) == 0, \"first\"\nassert binary_search([1,2,3,4,5], 6) == -1, \"missing\"\nassert binary_search([], 1) == -1, \"empty\"`,\n    language: 'python',\n    description: 'Binary search on sorted list — O(log n)',\n    tags: ['search', 'algorithm', 'list', 'sorted', 'binary-search'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'memoize-py',\n    code: `def memoize(fn):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = fn(*args)\n        return cache[args]\n    wrapper.cache = cache\n    return wrapper`,\n    testCode: `calls = 0\ndef add(a, b):\n    global calls\n    calls += 1\n    return a + b\nmemo_add = memoize(add)\nassert memo_add(1, 2) == 3\nassert memo_add(1, 2) == 3\nassert calls == 1, f\"should cache: {calls}\"`,\n    language: 'python',\n    description: 'Memoize decorator — caches function results by arguments',\n    tags: ['utility', 'cache', 'memoize', 'decorator', 'performance'],\n    patternType: 'utility',\n  },\n\n  // ─── TypeScript patterns ───\n  {\n    name: 'debounce-ts',\n    code: `function debounce<T extends (...args: any[]) => void>(fn: T, delay: number): T {\n  let timer: ReturnType<typeof setTimeout>;\n  return ((...args: Parameters<T>) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  }) as T;\n}`,\n    testCode: `let count = 0;\nconst inc = debounce(() => { count++; }, 50);\ninc(); inc(); inc();\nsetTimeout(() => {\n  if (count !== 0) throw new Error(\"should not fire yet: \" + count);\n  setTimeout(() => {\n    if (count !== 1) throw new Error(\"should fire once: \" + count);\n  }, 60);\n}, 20);`,\n    language: 'typescript',\n    description: 'Debounce with TypeScript generics — preserves argument types',\n    tags: ['utility', 'async', 'debounce', 'rate-limit', 'typescript', 'generic'],\n    patternType: 'utility',\n  },\n  {\n    name: 'result-type-ts',\n    code: `type Result<T, E = Error> = { ok: true; value: T } | { ok: false; error: E };\n\nfunction Ok<T>(value: T): Result<T, never> {\n  return { ok: true, value };\n}\n\nfunction Err<E>(error: E): Result<never, E> {\n  return { ok: false, error };\n}\n\nfunction unwrap<T, E>(result: Result<T, E>): T {\n  if (result.ok) return result.value;\n  throw result.error;\n}`,\n    testCode: `const ok = Ok(42);\nif (!ok.ok || ok.value !== 42) throw new Error(\"Ok failed\");\nconst err = Err(new Error(\"boom\"));\nif (err.ok) throw new Error(\"Err should not be ok\");\ntry { unwrap(err); throw new Error(\"should throw\"); } catch(e) { if (e.message !== \"boom\") throw e; }\nif (unwrap(Ok(\"hello\")) !== \"hello\") throw new Error(\"unwrap ok\");`,\n    language: 'typescript',\n    description: 'Result type (Rust-style Ok/Err) for typed error handling',\n    tags: ['utility', 'error-handling', 'typescript', 'type-safety', 'result'],\n    patternType: 'utility',\n  },\n  {\n    name: 'typed-event-emitter-ts',\n    code: `type EventMap = Record<string, any>;\n\nclass TypedEmitter<T extends EventMap> {\n  private listeners: { [K in keyof T]?: Array<(payload: T[K]) => void> } = {};\n\n  on<K extends keyof T>(event: K, fn: (payload: T[K]) => void): void {\n    (this.listeners[event] = this.listeners[event] || []).push(fn);\n  }\n\n  off<K extends keyof T>(event: K, fn: (payload: T[K]) => void): void {\n    const fns = this.listeners[event];\n    if (fns) this.listeners[event] = fns.filter(f => f !== fn);\n  }\n\n  emit<K extends keyof T>(event: K, payload: T[K]): void {\n    for (const fn of this.listeners[event] || []) fn(payload);\n  }\n}`,\n    testCode: `const em = new TypedEmitter();\nlet got = null;\nconst handler = (v) => { got = v; };\nem.on('test', handler);\nem.emit('test', 42);\nif (got !== 42) throw new Error(\"emit failed: \" + got);\nem.off('test', handler);\nem.emit('test', 99);\nif (got !== 42) throw new Error(\"off failed: \" + got);`,\n    language: 'typescript',\n    description: 'Type-safe event emitter with generics for event map',\n    tags: ['utility', 'events', 'typescript', 'generic', 'type-safe'],\n    patternType: 'design-pattern',\n  },\n\n  // ─── Go patterns (sandbox-executable) ───\n  {\n    name: 'binary-search-go',\n    code: `package sandbox\n\nfunc BinarySearch(arr []int, target int) int {\n\tlo, hi := 0, len(arr)-1\n\tfor lo <= hi {\n\t\tmid := lo + (hi-lo)/2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tlo = mid + 1\n\t\t} else {\n\t\t\thi = mid - 1\n\t\t}\n\t}\n\treturn -1\n}`,\n    testCode: `package sandbox\n\nimport \"testing\"\n\nfunc TestBinarySearch(t *testing.T) {\n\tif BinarySearch([]int{1,2,3,4,5}, 3) != 2 { t.Fatal(\"mid\") }\n\tif BinarySearch([]int{1,2,3,4,5}, 1) != 0 { t.Fatal(\"first\") }\n\tif BinarySearch([]int{1,2,3,4,5}, 6) != -1 { t.Fatal(\"missing\") }\n\tif BinarySearch([]int{}, 1) != -1 { t.Fatal(\"empty\") }\n}`,\n    language: 'go',\n    description: 'Binary search on sorted slice — O(log n)',\n    tags: ['search', 'algorithm', 'slice', 'sorted', 'binary-search'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'merge-sort-go',\n    code: `package sandbox\n\nfunc MergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := MergeSort(arr[:mid])\n\tright := MergeSort(arr[mid:])\n\treturn merge(left, right)\n}\n\nfunc merge(a, b []int) []int {\n\tresult := make([]int, 0, len(a)+len(b))\n\ti, j := 0, 0\n\tfor i < len(a) && j < len(b) {\n\t\tif a[i] <= b[j] {\n\t\t\tresult = append(result, a[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, b[j])\n\t\t\tj++\n\t\t}\n\t}\n\tresult = append(result, a[i:]...)\n\tresult = append(result, b[j:]...)\n\treturn result\n}`,\n    testCode: `package sandbox\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMergeSort(t *testing.T) {\n\tgot := MergeSort([]int{5,3,8,1,9,2})\n\twant := []int{1,2,3,5,8,9}\n\tif !reflect.DeepEqual(got, want) { t.Fatalf(\"got %v want %v\", got, want) }\n\tif len(MergeSort([]int{})) != 0 { t.Fatal(\"empty\") }\n\tif MergeSort([]int{1})[0] != 1 { t.Fatal(\"single\") }\n}`,\n    language: 'go',\n    description: 'Merge sort — stable O(n log n) sorting for slices',\n    tags: ['sort', 'algorithm', 'slice', 'stable', 'merge-sort'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'retry-go',\n    code: `package sandbox\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc Retry(attempts int, delay time.Duration, fn func() error) error {\n\tvar err error\n\tfor i := 0; i < attempts; i++ {\n\t\terr = fn()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif i < attempts-1 {\n\t\t\ttime.Sleep(delay)\n\t\t\tdelay *= 2\n\t\t}\n\t}\n\treturn fmt.Errorf(\"failed after %d attempts: %w\", attempts, err)\n}`,\n    testCode: `package sandbox\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestRetry(t *testing.T) {\n\tcount := 0\n\terr := Retry(3, time.Millisecond, func() error {\n\t\tcount++\n\t\tif count < 3 { return errors.New(\"fail\") }\n\t\treturn nil\n\t})\n\tif err != nil { t.Fatalf(\"should succeed: %v\", err) }\n\tif count != 3 { t.Fatalf(\"attempts: %d\", count) }\n}`,\n    language: 'go',\n    description: 'Retry with exponential backoff — robust error recovery',\n    tags: ['utility', 'async', 'retry', 'backoff', 'error-handling'],\n    patternType: 'utility',\n  },\n  {\n    name: 'lru-cache-go',\n    code: `package sandbox\n\ntype LRUCache struct {\n\tcapacity int\n\titems    map[string]*node\n\thead     *node\n\ttail     *node\n}\n\ntype node struct {\n\tkey        string\n\tvalue      interface{}\n\tprev, next *node\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n\thead := &node{}\n\ttail := &node{}\n\thead.next = tail\n\ttail.prev = head\n\treturn &LRUCache{capacity: capacity, items: make(map[string]*node), head: head, tail: tail}\n}\n\nfunc (c *LRUCache) Get(key string) (interface{}, bool) {\n\tif n, ok := c.items[key]; ok {\n\t\tc.moveToFront(n)\n\t\treturn n.value, true\n\t}\n\treturn nil, false\n}\n\nfunc (c *LRUCache) Put(key string, value interface{}) {\n\tif n, ok := c.items[key]; ok {\n\t\tn.value = value\n\t\tc.moveToFront(n)\n\t\treturn\n\t}\n\tn := &node{key: key, value: value}\n\tc.items[key] = n\n\tc.addToFront(n)\n\tif len(c.items) > c.capacity {\n\t\tback := c.tail.prev\n\t\tc.remove(back)\n\t\tdelete(c.items, back.key)\n\t}\n}\n\nfunc (c *LRUCache) moveToFront(n *node) { c.remove(n); c.addToFront(n) }\nfunc (c *LRUCache) addToFront(n *node) { n.prev = c.head; n.next = c.head.next; c.head.next.prev = n; c.head.next = n }\nfunc (c *LRUCache) remove(n *node) { n.prev.next = n.next; n.next.prev = n.prev }`,\n    testCode: `package sandbox\n\nimport \"testing\"\n\nfunc TestLRUCache(t *testing.T) {\n\tc := NewLRUCache(2)\n\tc.Put(\"a\", 1)\n\tc.Put(\"b\", 2)\n\tif v, ok := c.Get(\"a\"); !ok || v != 1 { t.Fatal(\"get a\") }\n\tc.Put(\"c\", 3)\n\tif _, ok := c.Get(\"b\"); ok { t.Fatal(\"should evict b\") }\n\tif v, ok := c.Get(\"c\"); !ok || v != 3 { t.Fatal(\"get c\") }\n}`,\n    language: 'go',\n    description: 'LRU cache with O(1) get/put using doubly-linked list + hashmap',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  },\n\n  // ─── Rust patterns (sandbox-executable) ───\n  {\n    name: 'binary-search-rs',\n    code: `pub fn binary_search(arr: &[i32], target: i32) -> Option<usize> {\n    let (mut lo, mut hi) = (0usize, arr.len());\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        match arr[mid].cmp(&target) {\n            std::cmp::Ordering::Equal => return Some(mid),\n            std::cmp::Ordering::Less => lo = mid + 1,\n            std::cmp::Ordering::Greater => hi = mid,\n        }\n    }\n    None\n}`,\n    testCode: `    use super::*;\n\n    #[test]\n    fn test_binary_search() {\n        assert_eq!(binary_search(&[1,2,3,4,5], 3), Some(2));\n        assert_eq!(binary_search(&[1,2,3,4,5], 1), Some(0));\n        assert_eq!(binary_search(&[1,2,3,4,5], 6), None);\n        assert_eq!(binary_search(&[], 1), None);\n    }`,\n    language: 'rust',\n    description: 'Binary search returning Option<usize> — idiomatic Rust',\n    tags: ['search', 'algorithm', 'slice', 'sorted', 'binary-search'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'merge-sort-rs',\n    code: `pub fn merge_sort(arr: &mut Vec<i32>) {\n    let len = arr.len();\n    if len <= 1 { return; }\n    let mid = len / 2;\n    let mut left = arr[..mid].to_vec();\n    let mut right = arr[mid..].to_vec();\n    merge_sort(&mut left);\n    merge_sort(&mut right);\n    let (mut i, mut j, mut k) = (0, 0, 0);\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] { arr[k] = left[i]; i += 1; }\n        else { arr[k] = right[j]; j += 1; }\n        k += 1;\n    }\n    while i < left.len() { arr[k] = left[i]; i += 1; k += 1; }\n    while j < right.len() { arr[k] = right[j]; j += 1; k += 1; }\n}`,\n    testCode: `    use super::*;\n\n    #[test]\n    fn test_merge_sort() {\n        let mut v = vec![5,3,8,1,9,2];\n        merge_sort(&mut v);\n        assert_eq!(v, vec![1,2,3,5,8,9]);\n        let mut e: Vec<i32> = vec![];\n        merge_sort(&mut e);\n        assert!(e.is_empty());\n    }`,\n    language: 'rust',\n    description: 'In-place merge sort for Vec<i32> — stable O(n log n)',\n    tags: ['sort', 'algorithm', 'vec', 'stable', 'merge-sort'],\n    patternType: 'algorithm',\n  },\n  {\n    name: 'retry-rs',\n    code: `use std::time::Duration;\n\npub fn retry<F, T, E>(attempts: u32, initial_delay: Duration, mut f: F) -> Result<T, E>\nwhere\n    F: FnMut() -> Result<T, E>,\n{\n    let mut delay = initial_delay;\n    for i in 0..attempts {\n        match f() {\n            Ok(val) => return Ok(val),\n            Err(e) => {\n                if i == attempts - 1 { return Err(e); }\n                std::thread::sleep(delay);\n                delay *= 2;\n            }\n        }\n    }\n    unreachable!()\n}`,\n    testCode: `    use super::*;\n    use std::time::Duration;\n\n    #[test]\n    fn test_retry() {\n        let mut count = 0u32;\n        let result = retry(3, Duration::from_millis(1), || -> Result<&str, &str> {\n            count += 1;\n            if count < 3 { Err(\"fail\") } else { Ok(\"ok\") }\n        });\n        assert_eq!(result, Ok(\"ok\"));\n        assert_eq!(count, 3);\n    }`,\n    language: 'rust',\n    description: 'Generic retry with exponential backoff — works with any Result<T, E>',\n    tags: ['utility', 'async', 'retry', 'backoff', 'error-handling', 'generic'],\n    patternType: 'utility',\n  },\n  {\n    name: 'lru-cache-rs',\n    code: `use std::collections::HashMap;\n\npub struct LruCache<K: std::hash::Hash + Eq + Clone, V> {\n    capacity: usize,\n    map: HashMap<K, (V, usize)>,\n    counter: usize,\n}\n\nimpl<K: std::hash::Hash + Eq + Clone, V> LruCache<K, V> {\n    pub fn new(capacity: usize) -> Self {\n        LruCache { capacity, map: HashMap::new(), counter: 0 }\n    }\n\n    pub fn get(&mut self, key: &K) -> Option<&V> {\n        if let Some(entry) = self.map.get_mut(key) {\n            self.counter += 1;\n            entry.1 = self.counter;\n            Some(&entry.0)\n        } else {\n            None\n        }\n    }\n\n    pub fn put(&mut self, key: K, value: V) {\n        self.counter += 1;\n        if self.map.contains_key(&key) {\n            self.map.insert(key, (value, self.counter));\n            return;\n        }\n        if self.map.len() >= self.capacity {\n            let lru_key = self.map.iter()\n                .min_by_key(|(_, (_, ts))| *ts)\n                .map(|(k, _)| k.clone())\n                .unwrap();\n            self.map.remove(&lru_key);\n        }\n        self.map.insert(key, (value, self.counter));\n    }\n}`,\n    testCode: `    use super::*;\n\n    #[test]\n    fn test_lru_cache() {\n        let mut c = LruCache::new(2);\n        c.put(\"a\", 1);\n        c.put(\"b\", 2);\n        assert_eq!(c.get(&\"a\"), Some(&1));\n        c.put(\"c\", 3);\n        assert_eq!(c.get(&\"b\"), None);\n        assert_eq!(c.get(&\"c\"), Some(&3));\n    }`,\n    language: 'rust',\n    description: 'Generic LRU cache with HashMap — evicts least recently used',\n    tags: ['data-structure', 'cache', 'lru', 'hashmap', 'eviction', 'generic'],\n    patternType: 'data-structure',\n  },\n];\n\n/**\n * Seed the pattern library with all built-in patterns.\n * Skips patterns that already exist (by name match).\n */\nfunction seedLibrary(oracle) {\n  const existing = oracle.patterns.getAll();\n  const existingNames = new Set(existing.map(p => p.name));\n\n  let registered = 0, skipped = 0, failed = 0;\n\n  for (const seed of SEEDS) {\n    if (existingNames.has(seed.name)) {\n      skipped++;\n      continue;\n    }\n\n    const result = oracle.registerPattern(seed);\n    if (result.registered) {\n      registered++;\n    } else {\n      failed++;\n      console.log(`  [FAIL] ${seed.name}: ${result.reason}`);\n    }\n  }\n\n  return { registered, skipped, failed, total: SEEDS.length };\n}\n\nmodule.exports = { seedLibrary, SEEDS };\n",
      "language": "javascript",
      "description": "Harvested from . — src/patterns/seeds.js (70 functions)",
      "tags": [
        "SEEDS",
        "binarySearch",
        "lo",
        "mid",
        "mergeSort",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.745
    },
    {
      "id": "da2371e2c259e3a9",
      "name": "github-handler",
      "code": "#!/usr/bin/env node\n\n/**\n * GitHub event handler — runs inside GitHub Actions to process\n * Oracle commands from issues and repository_dispatch events.\n *\n * For issues:   reads ISSUE_BODY env var, processes, posts comment via gh CLI\n * For dispatch: reads JSON from stdin, processes, outputs result\n */\n\nconst { AIConnector } = require('./connector');\nconst { parseIssueCommand, formatAsComment } = require('./github-bridge');\nconst { execSync } = require('child_process');\n\nconst connector = new AIConnector({ provider: 'github', modelId: 'actions' });\n\nfunction handleIssue() {\n  const body = process.env.ISSUE_BODY;\n  const issueNumber = process.env.ISSUE_NUMBER;\n  const repo = process.env.REPO;\n\n  if (!body || !issueNumber) {\n    console.error('Missing ISSUE_BODY or ISSUE_NUMBER');\n    process.exit(1);\n  }\n\n  const command = parseIssueCommand(body);\n  console.log('Parsed command:', JSON.stringify(command));\n\n  const result = connector.execute(command);\n  console.log('Result:', JSON.stringify(result, null, 2));\n\n  const comment = formatAsComment(result);\n\n  // Post comment back to the issue\n  if (process.env.GITHUB_TOKEN && repo) {\n    try {\n      const escaped = comment.replace(/'/g, \"'\\\\''\");\n      execSync(\n        `gh issue comment ${issueNumber} --repo ${repo} --body '${escaped}'`,\n        { stdio: 'inherit', env: { ...process.env, GH_TOKEN: process.env.GITHUB_TOKEN } }\n      );\n      console.log('Comment posted successfully');\n    } catch (err) {\n      console.error('Failed to post comment:', err.message);\n      // Still output the result\n      console.log('\\n--- RESULT ---\\n' + comment);\n    }\n  } else {\n    console.log('\\n--- RESULT ---\\n' + comment);\n  }\n}\n\nfunction handleDispatch() {\n  let input = '';\n  process.stdin.setEncoding('utf-8');\n  process.stdin.on('data', chunk => { input += chunk; });\n  process.stdin.on('end', () => {\n    try {\n      const payload = JSON.parse(input);\n      const command = payload.action\n        ? payload\n        : { action: payload.command || 'stats', params: payload.params || payload };\n\n      const result = connector.execute(command);\n      console.log(JSON.stringify(result, null, 2));\n    } catch (err) {\n      console.error('Failed to parse dispatch payload:', err.message);\n      process.exit(1);\n    }\n  });\n}\n\n// Determine which mode we're in\nif (process.env.ISSUE_BODY) {\n  handleIssue();\n} else {\n  handleDispatch();\n}\n",
      "language": "javascript",
      "description": "Harvested from . — src/connectors/github-handler.js (12 functions)",
      "tags": [
        "connector",
        "handleIssue",
        "body",
        "issueNumber",
        "repo",
        "javascript",
        "harvested"
      ],
      "patternType": "transformation",
      "complexity": "architectural",
      "coherency": 0.745
    },
    {
      "id": "3c7ed40301a9d4ce",
      "name": "embeddings.test",
      "code": "const { describe, it } = require('node:test');\nconst assert = require('node:assert/strict');\nconst {\n  expandQuery,\n  identifyConcepts,\n  semanticSimilarity,\n  semanticSearch,\n  charNgrams,\n  cosineSim,\n} = require('../src/core/embeddings');\n\ndescribe('expandQuery', () => {\n  it('expands rate-limiting intent', () => {\n    const expanded = expandQuery('prevent calling too often');\n    assert.ok(expanded.includes('throttle'));\n    assert.ok(expanded.includes('debounce'));\n    assert.ok(expanded.includes('rate-limit'));\n  });\n\n  it('expands caching intent', () => {\n    const expanded = expandQuery('remember already computed result');\n    assert.ok(expanded.includes('memoize'));\n    assert.ok(expanded.includes('cache'));\n    assert.ok(expanded.includes('lru'));\n  });\n\n  it('preserves original terms', () => {\n    const expanded = expandQuery('sort an array');\n    assert.ok(expanded.includes('sort'));\n    assert.ok(expanded.includes('array'));\n  });\n\n  it('handles no cluster match', () => {\n    const expanded = expandQuery('quantum computing');\n    assert.ok(expanded.includes('quantum'));\n    assert.ok(expanded.includes('computing'));\n    assert.equal(expanded.length, 2);\n  });\n});\n\ndescribe('identifyConcepts', () => {\n  it('identifies rate-limiting concepts from throttle code', () => {\n    const concepts = identifyConcepts('function throttle(fn, delay) { let last = 0; return (...args) => { const now = Date.now(); if (now - last >= delay) { last = now; fn(...args); } }; }');\n    const ids = concepts.map(c => c.id);\n    assert.ok(ids.includes('rate-limiting'));\n  });\n\n  it('identifies caching concepts from memoize code', () => {\n    const concepts = identifyConcepts('function memoize(fn) { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn(...args); cache.set(key, result); return result; }; }');\n    const ids = concepts.map(c => c.id);\n    assert.ok(ids.includes('caching'));\n  });\n\n  it('returns empty for unrelated text', () => {\n    const concepts = identifyConcepts('hello world quantum physics');\n    assert.equal(concepts.length, 0);\n  });\n});\n\ndescribe('semanticSimilarity', () => {\n  it('scores high for intent-matching query + code', () => {\n    const result = semanticSimilarity(\n      'prevent calling too often',\n      'function debounce(fn, delay) { let timer; return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), delay); }; }'\n    );\n    assert.ok(result.similarity > 0.2, `Expected > 0.2, got ${result.similarity}`);\n    assert.ok(result.matchedConcepts.includes('rate-limiting'));\n  });\n\n  it('scores low for unrelated query + code', () => {\n    const result = semanticSimilarity(\n      'quantum computing simulation',\n      'function debounce(fn, delay) { let timer; return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), delay); }; }'\n    );\n    assert.ok(result.similarity < 0.15, `Expected < 0.15, got ${result.similarity}`);\n  });\n\n  it('scores high for synonym-level match', () => {\n    const result = semanticSimilarity(\n      'remember results already computed',\n      'function memoize(fn) { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const r = fn(...args); cache.set(key, r); return r; }; }'\n    );\n    assert.ok(result.similarity > 0.15, `Expected > 0.15, got ${result.similarity}`);\n  });\n});\n\ndescribe('semanticSearch', () => {\n  const items = [\n    { id: '1', name: 'debounce', description: 'Delay function execution', tags: ['utility', 'rate-limit'], code: 'function debounce(fn, d) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), d); }; }', language: 'javascript' },\n    { id: '2', name: 'merge-sort', description: 'Sort array using merge sort', tags: ['algorithm', 'sort'], code: 'function mergeSort(arr) { if (arr.length <= 1) return arr; }', language: 'javascript' },\n    { id: '3', name: 'memoize', description: 'Cache function results', tags: ['utility', 'cache'], code: 'function memoize(fn) { const cache = new Map(); return (...a) => { const k = JSON.stringify(a); if (cache.has(k)) return cache.get(k); const r = fn(...a); cache.set(k, r); return r; }; }', language: 'javascript' },\n    { id: '4', name: 'binary-search', description: 'Find element in sorted array', tags: ['algorithm', 'search'], code: 'function bsearch(arr, t) { let lo = 0, hi = arr.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; if (arr[mid] === t) return mid; arr[mid] < t ? lo = mid + 1 : hi = mid - 1; } return -1; }', language: 'javascript' },\n  ];\n\n  it('ranks throttle/debounce first for rate-limiting intent', () => {\n    const results = semanticSearch(items, 'prevent calling too often');\n    assert.ok(results.length > 0);\n    assert.equal(results[0].id, '1'); // debounce\n  });\n\n  it('ranks memoize first for caching intent', () => {\n    const results = semanticSearch(items, 'remember computed results');\n    assert.ok(results.length > 0);\n    assert.equal(results[0].id, '3'); // memoize\n  });\n\n  it('ranks sort first for sorting intent', () => {\n    const results = semanticSearch(items, 'arrange numbers in ascending order');\n    assert.ok(results.length > 0);\n    assert.equal(results[0].id, '2'); // merge-sort\n  });\n\n  it('filters by language', () => {\n    const results = semanticSearch(items, 'sort', { language: 'python' });\n    assert.equal(results.length, 0);\n  });\n});\n\ndescribe('charNgrams', () => {\n  it('generates correct bigrams', () => {\n    const grams = charNgrams('abc', 2);\n    assert.deepEqual(grams, { ab: 1, bc: 1 });\n  });\n\n  it('counts repeated grams', () => {\n    const grams = charNgrams('abab', 2);\n    assert.equal(grams['ab'], 2);\n    assert.equal(grams['ba'], 1);\n  });\n});\n\ndescribe('cosineSim', () => {\n  it('returns 1 for identical vectors', () => {\n    const v = { a: 1, b: 2 };\n    assert.ok(Math.abs(cosineSim(v, v) - 1) < 1e-10);\n  });\n\n  it('returns 0 for orthogonal vectors', () => {\n    assert.equal(cosineSim({ a: 1 }, { b: 1 }), 0);\n  });\n\n  it('handles empty vectors', () => {\n    assert.equal(cosineSim({}, {}), 0);\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/embeddings.test.js (23 functions)",
      "tags": [
        "assert",
        "expanded",
        "concepts",
        "throttle",
        "last",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.73
    },
    {
      "id": "33b791868b957d04",
      "name": "debug-oracle.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst {\n  DebugOracle,\n  fingerprint,\n  normalizeError,\n  extractErrorClass,\n  classifyError,\n  computeConfidence,\n  generateErrorVariants,\n  generateFixVariants,\n  ERROR_CATEGORIES,\n} = require('../src/core/debug-oracle');\n\nconst { SQLiteStore, DatabaseSync } = require('../src/store/sqlite');\n\nfunction makeTempDir(suffix = '') {\n  const dir = path.join(os.tmpdir(), `debug-test-${suffix}-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}\n\nfunction createDebugOracle() {\n  const baseDir = makeTempDir('debug');\n  const store = new SQLiteStore(baseDir);\n  return new DebugOracle(store);\n}\n\ndescribe('Debug Oracle', () => {\n  if (!DatabaseSync) {\n    it('skips debug oracle tests (no SQLite)', () => { assert.ok(true); });\n    return;\n  }\n\n  // ─── Error Fingerprinting ───\n\n  describe('normalizeError', () => {\n    it('strips file paths and line numbers', () => {\n      const msg = 'Error at /home/user/project/src/foo.js:42:10';\n      const result = normalizeError(msg);\n      assert.ok(!result.includes('/home/user'));\n      assert.ok(result.includes('<FILE>:<LINE>'));\n    });\n\n    it('strips memory addresses', () => {\n      const msg = 'Segfault at 0x7fff5fc00000';\n      const result = normalizeError(msg);\n      assert.ok(!result.includes('0x7fff'));\n      assert.ok(result.includes('<ADDR>'));\n    });\n\n    it('strips timestamps', () => {\n      const msg = 'Error at 2024-01-15T10:30:00.000Z';\n      const result = normalizeError(msg);\n      assert.ok(!result.includes('2024'));\n      assert.ok(result.includes('<TIME>'));\n    });\n\n    it('normalizes whitespace', () => {\n      const msg = 'Error   with   extra    spaces';\n      const result = normalizeError(msg);\n      assert.equal(result, 'Error with extra spaces');\n    });\n\n    it('handles null/undefined gracefully', () => {\n      assert.equal(normalizeError(null), '');\n      assert.equal(normalizeError(undefined), '');\n      assert.equal(normalizeError(''), '');\n    });\n  });\n\n  describe('extractErrorClass', () => {\n    it('extracts TypeError', () => {\n      assert.equal(extractErrorClass('TypeError: x is not a function'), 'TypeError');\n    });\n\n    it('extracts ReferenceError', () => {\n      assert.equal(extractErrorClass('ReferenceError: x is not defined'), 'ReferenceError');\n    });\n\n    it('extracts SyntaxError', () => {\n      assert.equal(extractErrorClass('SyntaxError: Unexpected token }'), 'SyntaxError');\n    });\n\n    it('extracts from middle of message', () => {\n      assert.equal(extractErrorClass('Uncaught RangeError: Maximum call stack'), 'RangeError');\n    });\n\n    it('returns UnknownError for unrecognized', () => {\n      assert.equal(extractErrorClass('Something went wrong'), 'UnknownError');\n    });\n\n    it('handles null', () => {\n      assert.equal(extractErrorClass(null), 'UnknownError');\n    });\n  });\n\n  describe('classifyError', () => {\n    it('classifies TypeError as type', () => {\n      assert.equal(classifyError('TypeError: x is not a function'), 'type');\n    });\n\n    it('classifies SyntaxError as syntax', () => {\n      assert.equal(classifyError('SyntaxError: Unexpected token'), 'syntax');\n    });\n\n    it('classifies cannot find module as build', () => {\n      assert.equal(classifyError('Cannot find module \"foo\"'), 'build');\n    });\n\n    it('classifies ReferenceError as reference', () => {\n      assert.equal(classifyError('ReferenceError: x is not defined'), 'reference');\n    });\n\n    it('classifies assertion failure as logic', () => {\n      assert.equal(classifyError('AssertionError: expected 2 to equal 3'), 'logic');\n    });\n\n    it('classifies ECONNREFUSED as network', () => {\n      assert.equal(classifyError('ECONNREFUSED: Connection refused'), 'network');\n    });\n\n    it('classifies overflow as runtime', () => {\n      assert.equal(classifyError('RangeError: Maximum call stack size exceeded'), 'runtime');\n    });\n\n    it('classifies permission denied as permission', () => {\n      assert.equal(classifyError('EACCES: Permission denied'), 'permission');\n    });\n\n    it('classifies unhandled promise as async', () => {\n      assert.equal(classifyError('UnhandledPromiseRejection: ...'), 'async');\n    });\n\n    it('classifies JSON parse as data', () => {\n      assert.equal(classifyError('JSON.parse: invalid JSON'), 'data');\n    });\n\n    it('defaults to runtime for unknown', () => {\n      assert.equal(classifyError(null), 'runtime');\n    });\n  });\n\n  describe('fingerprint', () => {\n    it('generates stable hash for same error', () => {\n      const fp1 = fingerprint('TypeError: x is not a function', '');\n      const fp2 = fingerprint('TypeError: x is not a function', '');\n      assert.equal(fp1.hash, fp2.hash);\n    });\n\n    it('generates different hash for different errors', () => {\n      const fp1 = fingerprint('TypeError: x is not a function', '');\n      const fp2 = fingerprint('ReferenceError: y is not defined', '');\n      assert.notEqual(fp1.hash, fp2.hash);\n    });\n\n    it('normalizes before hashing', () => {\n      const fp1 = fingerprint('Error at /path/file.js:10:5', '');\n      const fp2 = fingerprint('Error at /other/file.js:20:3', '');\n      assert.equal(fp1.hash, fp2.hash); // Same after normalization\n    });\n\n    it('includes error class and category', () => {\n      const fp = fingerprint('TypeError: x is not a function', '');\n      assert.equal(fp.errorClass, 'TypeError');\n      assert.equal(fp.category, 'type');\n    });\n\n    it('extracts stack functions', () => {\n      const stack = `Error: something\n    at foo (/path/file.js:10:5)\n    at bar (/path/other.js:20:3)\n    at baz (/path/third.js:30:1)`;\n      const fp = fingerprint('Error: something', stack);\n      assert.deepEqual(fp.stackFunctions, ['foo', 'bar', 'baz']);\n    });\n  });\n\n  // ─── Confidence Scoring ───\n\n  describe('computeConfidence', () => {\n    it('returns 0.2 for zero applications', () => {\n      assert.equal(computeConfidence(0, 0), 0.2);\n    });\n\n    it('grows with successful applications', () => {\n      const c1 = computeConfidence(1, 1);\n      const c5 = computeConfidence(5, 5);\n      const c10 = computeConfidence(10, 10);\n      assert.ok(c1 < c5, 'confidence grows with applications');\n      assert.ok(c5 < c10, 'confidence continues growing');\n    });\n\n    it('decreases with failures', () => {\n      const allSuccess = computeConfidence(5, 5);\n      const halfSuccess = computeConfidence(5, 2);\n      assert.ok(halfSuccess < allSuccess);\n    });\n\n    it('approaches 1.0 for many successes', () => {\n      const c = computeConfidence(100, 100);\n      assert.ok(c > 0.9, `expected > 0.9, got ${c}`);\n    });\n\n    it('stays low for poor resolution rate', () => {\n      const c = computeConfidence(100, 10);\n      assert.ok(c < 0.3, `expected < 0.3, got ${c}`);\n    });\n  });\n\n  // ─── Variant Generation ───\n\n  describe('generateErrorVariants', () => {\n    it('generates undefined→null variant for TypeError', () => {\n      const variants = generateErrorVariants('TypeError: Cannot read property of undefined', 'type');\n      assert.ok(variants.some(v => v.includes('null')));\n    });\n\n    it('generates variants for is not a function', () => {\n      const variants = generateErrorVariants('TypeError: x is not a function', 'type');\n      assert.ok(variants.some(v => v.includes('is not an object')));\n    });\n\n    it('generates variants for Unexpected token', () => {\n      const variants = generateErrorVariants('SyntaxError: Unexpected token ;', 'syntax');\n      assert.ok(variants.length > 0);\n    });\n\n    it('returns empty for uncategorized errors', () => {\n      const variants = generateErrorVariants('Something weird', 'runtime');\n      assert.equal(variants.length, 0);\n    });\n  });\n\n  describe('generateFixVariants', () => {\n    it('generates Python variant from JS', () => {\n      const variants = generateFixVariants('const x = null;', 'javascript', ['python']);\n      assert.ok(variants.length > 0);\n      assert.equal(variants[0].language, 'python');\n      assert.ok(variants[0].code.includes('None'));\n    });\n\n    it('generates Go variant from JS', () => {\n      const variants = generateFixVariants('const x = null;', 'javascript', ['go']);\n      assert.ok(variants.length > 0);\n      assert.equal(variants[0].language, 'go');\n      assert.ok(variants[0].code.includes('nil'));\n    });\n\n    it('skips same language', () => {\n      const variants = generateFixVariants('const x = 1;', 'javascript', ['javascript']);\n      assert.equal(variants.length, 0);\n    });\n  });\n\n  // ─── DebugOracle Core ───\n\n  describe('DebugOracle.capture', () => {\n    it('captures an error→fix pair', () => {\n      const debug = createDebugOracle();\n      const result = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'if (typeof x === \"function\") x();',\n        fixDescription: 'Check if x is callable before calling',\n        language: 'javascript',\n      });\n      assert.ok(result.captured);\n      assert.ok(result.pattern);\n      assert.equal(result.pattern.errorClass, 'TypeError');\n      assert.equal(result.pattern.errorCategory, 'type');\n      assert.equal(result.pattern.language, 'javascript');\n      assert.ok(result.pattern.id);\n    });\n\n    it('auto-generates language variants', () => {\n      const debug = createDebugOracle();\n      const result = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'const safe = typeof x === \"function\" ? x() : null;',\n        language: 'javascript',\n      });\n      assert.ok(result.captured);\n      assert.ok(result.variants.length > 0, 'should auto-generate variants');\n    });\n\n    it('rejects duplicate fingerprints with high confidence', () => {\n      const debug = createDebugOracle();\n\n      // Capture first\n      debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'if (typeof x === \"function\") x();',\n        language: 'javascript',\n      });\n\n      // Manually boost confidence\n      const all = debug.getAll();\n      const captured = all.find(p => p.generationMethod === 'capture');\n      debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.9 WHERE id = ?').run(captured.id);\n\n      // Try duplicate\n      const result = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'different fix code',\n        language: 'javascript',\n      });\n      assert.ok(result.duplicate);\n      assert.equal(result.existingId, captured.id);\n    });\n\n    it('updates existing pattern if confidence is low', () => {\n      const debug = createDebugOracle();\n\n      // Capture first\n      debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'old fix code',\n        language: 'javascript',\n      });\n\n      // Try same fingerprint — confidence is low (0.2), should update\n      const result = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'better fix code',\n        language: 'javascript',\n      });\n      assert.ok(result.captured);\n      assert.ok(result.updated);\n    });\n\n    it('requires errorMessage and fixCode', () => {\n      const debug = createDebugOracle();\n      const result = debug.capture({ errorMessage: 'error' });\n      assert.ok(!result.captured);\n      assert.ok(result.error);\n    });\n  });\n\n  describe('DebugOracle.search', () => {\n    it('finds exact fingerprint matches', () => {\n      const debug = createDebugOracle();\n      debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'if (typeof x === \"function\") x();',\n        language: 'javascript',\n      });\n\n      const results = debug.search({\n        errorMessage: 'TypeError: x is not a function',\n      });\n      assert.ok(results.length > 0);\n      assert.equal(results[0].matchType, 'exact');\n    });\n\n    it('finds class matches', () => {\n      const debug = createDebugOracle();\n      debug.capture({\n        errorMessage: 'TypeError: y is not a function',\n        fixCode: 'check typeof before calling',\n        language: 'javascript',\n      });\n\n      const results = debug.search({\n        errorMessage: 'TypeError: z is undefined',\n      });\n      // Should find through class matching (both TypeError + type category)\n      assert.ok(results.length > 0);\n    });\n\n    it('ranks by confidence', () => {\n      const debug = createDebugOracle();\n\n      // Low confidence capture\n      debug.capture({\n        errorMessage: 'ReferenceError: a is not defined',\n        fixCode: 'let a = 0;',\n        language: 'javascript',\n      });\n\n      // Boost one capture's confidence\n      const all = debug.getAll();\n      const captured = all.find(p => p.generationMethod === 'capture');\n      if (captured) {\n        debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.9 WHERE id = ?').run(captured.id);\n      }\n\n      // Another capture with default confidence\n      debug.capture({\n        errorMessage: 'ReferenceError: b is not defined',\n        fixCode: 'let b = 0;',\n        language: 'javascript',\n      });\n\n      const results = debug.search({\n        errorMessage: 'ReferenceError: c is not defined',\n        limit: 10,\n      });\n\n      if (results.length >= 2) {\n        assert.ok(results[0].confidence >= results[1].confidence || results[0].matchScore >= results[1].matchScore);\n      }\n    });\n\n    it('returns empty for no matches', () => {\n      const debug = createDebugOracle();\n      const results = debug.search({\n        errorMessage: 'Some completely unique error',\n      });\n      assert.equal(results.length, 0);\n    });\n  });\n\n  describe('DebugOracle.reportOutcome', () => {\n    it('increases confidence on success', () => {\n      const debug = createDebugOracle();\n      const { pattern } = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'if (typeof x === \"function\") x();',\n        language: 'javascript',\n      });\n\n      const initialConfidence = pattern.confidence;\n      const result = debug.reportOutcome(pattern.id, true);\n      assert.ok(result.success);\n      assert.ok(result.timesApplied === 1);\n      assert.ok(result.timesResolved === 1);\n    });\n\n    it('tracks failed applications', () => {\n      const debug = createDebugOracle();\n      const { pattern } = debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'bad fix',\n        language: 'javascript',\n      });\n\n      const result = debug.reportOutcome(pattern.id, false);\n      assert.ok(result.success);\n      assert.equal(result.timesApplied, 1);\n      assert.equal(result.timesResolved, 0);\n    });\n\n    it('triggers cascade growth at threshold', () => {\n      const debug = createDebugOracle();\n      debug.cascadeThreshold = 0.01; // Very low for testing\n\n      const { pattern } = debug.capture({\n        errorMessage: 'TypeError: Cannot read property of undefined',\n        fixCode: 'if (obj && obj.prop) { return obj.prop; }',\n        language: 'javascript',\n      });\n\n      const result = debug.reportOutcome(pattern.id, true);\n      assert.ok(result.success);\n      // May generate cascade variants\n      assert.ok(result.cascadeVariants >= 0);\n    });\n\n    it('returns error for unknown ID', () => {\n      const debug = createDebugOracle();\n      const result = debug.reportOutcome('nonexistent', true);\n      assert.ok(!result.success);\n      assert.ok(result.error);\n    });\n  });\n\n  describe('DebugOracle.grow', () => {\n    it('generates variants from high-confidence patterns', () => {\n      const debug = createDebugOracle();\n\n      // Create a pattern and boost its confidence\n      debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'const result = typeof x === \"function\" ? x() : null;',\n        language: 'javascript',\n      });\n\n      const all = debug.getAll();\n      const captured = all.find(p => p.generationMethod === 'capture');\n      debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.8 WHERE id = ?').run(captured.id);\n\n      const report = debug.grow({ minConfidence: 0.5 });\n      assert.ok(report.processed > 0);\n      assert.ok(report.generated >= 0);\n    });\n\n    it('skips duplicates', () => {\n      const debug = createDebugOracle();\n\n      debug.capture({\n        errorMessage: 'TypeError: x is not a function',\n        fixCode: 'const result = typeof x === \"function\" ? x() : null;',\n        language: 'javascript',\n      });\n\n      const all = debug.getAll();\n      const captured = all.find(p => p.generationMethod === 'capture');\n      debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.8 WHERE id = ?').run(captured.id);\n\n      // Grow twice — second should skip duplicates\n      const report1 = debug.grow({ minConfidence: 0.5 });\n      const report2 = debug.grow({ minConfidence: 0.5 });\n      assert.ok(report2.skipped >= report1.stored || report2.stored === 0);\n    });\n  });\n\n  describe('DebugOracle.getAll', () => {\n    it('returns all patterns', () => {\n      const debug = createDebugOracle();\n      debug.capture({\n        errorMessage: 'TypeError: a',\n        fixCode: 'fix a',\n        language: 'javascript',\n      });\n      debug.capture({\n        errorMessage: 'SyntaxError: b',\n        fixCode: 'fix b',\n        language: 'python',\n      });\n\n      const all = debug.getAll();\n      assert.ok(all.length >= 2);\n    });\n\n    it('filters by language', () => {\n      const debug = createDebugOracle();\n      debug.capture({ errorMessage: 'TypeError: a', fixCode: 'fix a', language: 'javascript' });\n      debug.capture({ errorMessage: 'SyntaxError: b', fixCode: 'fix b', language: 'python' });\n\n      const pyOnly = debug.getAll({ language: 'python' });\n      assert.ok(pyOnly.every(p => p.language === 'python'));\n    });\n\n    it('filters by category', () => {\n      const debug = createDebugOracle();\n      debug.capture({ errorMessage: 'TypeError: a', fixCode: 'fix', language: 'javascript' });\n      debug.capture({ errorMessage: 'SyntaxError: Unexpected token', fixCode: 'fix', language: 'javascript' });\n\n      const syntaxOnly = debug.getAll({ category: 'syntax' });\n      assert.ok(syntaxOnly.every(p => p.errorCategory === 'syntax'));\n    });\n\n    it('filters by minimum confidence', () => {\n      const debug = createDebugOracle();\n      debug.capture({ errorMessage: 'TypeError: a', fixCode: 'fix', language: 'javascript' });\n\n      const all = debug.getAll();\n      const captured = all.find(p => p.generationMethod === 'capture');\n      debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.9 WHERE id = ?').run(captured.id);\n\n      const highConf = debug.getAll({ minConfidence: 0.8 });\n      assert.ok(highConf.every(p => p.confidence >= 0.8));\n    });\n  });\n\n  describe('DebugOracle.stats', () => {\n    it('returns valid statistics', () => {\n      const debug = createDebugOracle();\n      debug.capture({ errorMessage: 'TypeError: a', fixCode: 'fix a', language: 'javascript' });\n      debug.capture({ errorMessage: 'SyntaxError: Unexpected token', fixCode: 'fix b', language: 'python' });\n\n      const stats = debug.stats();\n      assert.ok(stats.totalPatterns >= 2);\n      assert.ok(typeof stats.avgConfidence === 'number');\n      assert.ok(typeof stats.resolutionRate === 'number');\n      assert.ok(stats.byCategory);\n      assert.ok(stats.byLanguage);\n      assert.ok(stats.byMethod);\n      assert.ok(typeof stats.captured === 'number');\n      assert.ok(typeof stats.generated === 'number');\n    });\n  });\n\n  // ─── Oracle API Integration ───\n\n  describe('RemembranceOracle debug methods', () => {\n    it('exposes debugCapture through oracle API', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n\n      const result = oracle.debugCapture({\n        errorMessage: 'TypeError: Cannot read properties of null',\n        fixCode: 'if (obj != null) { return obj.prop; }',\n        language: 'javascript',\n      });\n\n      assert.ok(result.captured || result.error === 'No SQLite store available');\n    });\n\n    it('exposes debugSearch through oracle API', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n\n      // Capture first\n      oracle.debugCapture({\n        errorMessage: 'TypeError: Cannot read properties of null',\n        fixCode: 'if (obj != null) { return obj.prop; }',\n        language: 'javascript',\n      });\n\n      const results = oracle.debugSearch({\n        errorMessage: 'TypeError: Cannot read properties of null',\n        federated: false,\n      });\n      // Results depend on SQLite availability\n      assert.ok(Array.isArray(results));\n    });\n\n    it('exposes debugStats through oracle API', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n\n      const stats = oracle.debugStats();\n      assert.ok(typeof stats.totalPatterns === 'number' || stats.error);\n    });\n\n    it('exposes debugGrow through oracle API', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n\n      const result = oracle.debugGrow();\n      assert.ok(typeof result.processed === 'number' || result.error);\n    });\n  });\n\n  // ─── MCP Integration ───\n\n  describe('MCP debug tools', () => {\n    it('lists debug tools', () => {\n      const { TOOLS } = require('../src/mcp/server');\n      const debugTools = TOOLS.filter(t => t.name.startsWith('oracle_debug_'));\n      assert.ok(debugTools.length >= 6, `expected at least 6 debug tools, got ${debugTools.length}`);\n    });\n\n    it('handles oracle_debug_capture', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_capture',\n          arguments: {\n            errorMessage: 'TypeError: x is undefined',\n            fixCode: 'const x = 0;',\n            language: 'javascript',\n          },\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n      assert.ok(response.result.content);\n    });\n\n    it('handles oracle_debug_search', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 2,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_search',\n          arguments: {\n            errorMessage: 'TypeError: x is undefined',\n          },\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n    });\n\n    it('handles oracle_debug_stats', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 3,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_stats',\n          arguments: {},\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n    });\n\n    it('handles oracle_debug_grow', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 4,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_grow',\n          arguments: {},\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n    });\n\n    it('handles oracle_debug_feedback', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      // First capture\n      oracle.debugCapture({\n        errorMessage: 'TypeError: x is undefined',\n        fixCode: 'const x = 0;',\n        language: 'javascript',\n      });\n      const patterns = oracle.debugPatterns();\n      const id = patterns.length > 0 ? patterns[0].id : 'test-id';\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 5,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_feedback',\n          arguments: { id, resolved: true },\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n    });\n\n    it('handles oracle_debug_share', () => {\n      const { MCPServer } = require('../src/mcp/server');\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const oracle = new RemembranceOracle({ autoSeed: false });\n      const server = new MCPServer(oracle);\n\n      const response = server.handleRequest({\n        jsonrpc: '2.0',\n        id: 6,\n        method: 'tools/call',\n        params: {\n          name: 'oracle_debug_share',\n          arguments: { dryRun: true },\n        },\n      });\n\n      assert.equal(response.jsonrpc, '2.0');\n      assert.ok(response.result);\n    });\n  });\n\n  // ─── ERROR_CATEGORIES completeness ───\n\n  describe('ERROR_CATEGORIES', () => {\n    it('covers all 10 categories', () => {\n      const expected = ['syntax', 'type', 'reference', 'logic', 'runtime', 'build', 'network', 'permission', 'async', 'data'];\n      for (const cat of expected) {\n        assert.ok(ERROR_CATEGORIES[cat], `missing category: ${cat}`);\n        assert.ok(ERROR_CATEGORIES[cat].keywords.length > 0, `no keywords for: ${cat}`);\n        assert.ok(typeof ERROR_CATEGORIES[cat].weight === 'number', `no weight for: ${cat}`);\n      }\n    });\n  });\n\n  // ─── End-to-End Growth Flow ───\n\n  describe('Exponential growth flow', () => {\n    it('capture → feedback → cascade → more patterns', () => {\n      const debug = createDebugOracle();\n      debug.cascadeThreshold = 0.01; // Low threshold for testing\n\n      // Step 1: Capture\n      const capture = debug.capture({\n        errorMessage: 'TypeError: Cannot read properties of null (reading \"length\")',\n        fixCode: 'const len = arr ? arr.length : 0;',\n        fixDescription: 'Null-safe length check',\n        language: 'javascript',\n        tags: ['null-safety', 'defensive'],\n      });\n      assert.ok(capture.captured);\n      const initialCount = debug.getAll().length;\n\n      // Step 2: Report success (triggers cascade)\n      const feedback = debug.reportOutcome(capture.pattern.id, true);\n      assert.ok(feedback.success);\n\n      // Step 3: Grow explicitly\n      debug.store.db.prepare('UPDATE debug_patterns SET confidence = 0.8 WHERE id = ?').run(capture.pattern.id);\n      const growth = debug.grow({ minConfidence: 0.5 });\n      const finalCount = debug.getAll().length;\n\n      // Should have grown\n      assert.ok(finalCount >= initialCount, `expected growth: ${initialCount} → ${finalCount}`);\n\n      // Step 4: Stats should reflect growth\n      const stats = debug.stats();\n      assert.ok(stats.totalPatterns >= initialCount);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/debug-oracle.test.js (51 functions)",
      "tags": [
        "assert",
        "path",
        "fs",
        "os",
        "makeTempDir",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.73
    },
    {
      "id": "5f35b5bc05ff0446",
      "name": "seedExtendedLibrary-ts",
      "code": "function seedExtendedLibrary(oracle, { verbose = false }",
      "language": "typescript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js (TypeScript variant)",
      "tags": [
        "seedExtendedLibrary",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.725
    },
    {
      "id": "7086b7e507f2ce8a",
      "name": "name-ts",
      "code": "const name = () =>)', () => {\n    const code = `const double = (n) => {\n  return n * 2;\n};\nconst triple = (n) => {\n  return n * 3;\n};`;\n    const funcs = extractFunctions(code, 'js');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'double');\n    assert.equal(funcs[0].signature, 'double(n)');\n    assert.equal(funcs[1].name, 'triple');\n  }",
      "language": "typescript",
      "description": "Harvested function from . — tests/versioning.test.js (TypeScript variant)",
      "tags": [
        "name",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.725
    },
    {
      "id": "f2b05665773c7870",
      "name": "persistence.test",
      "code": "const { describe, it, beforeEach } = require('node:test');\nconst assert = require('node:assert/strict');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst {\n  syncToGlobal,\n  syncFromGlobal,\n  syncBidirectional,\n  shareToCommuntiy,\n  pullFromCommunity,\n  federatedQuery,\n  globalStats,\n  personalStats,\n  communityStats,\n  openPersonalStore,\n  openCommunityStore,\n} = require('../src/core/persistence');\nconst { SQLiteStore, DatabaseSync } = require('../src/store/sqlite');\n\nfunction makeTempDir(suffix = '') {\n  const dir = path.join(os.tmpdir(), `persist-test-${suffix}-${Date.now()}-${Math.random().toString(36).slice(2)}`);\n  fs.mkdirSync(dir, { recursive: true });\n  return dir;\n}\n\nfunction createTestStores() {\n  const localBase = makeTempDir('local');\n  const globalBase = makeTempDir('global');\n  const localStore = new SQLiteStore(localBase);\n  const globalStore = new SQLiteStore(globalBase);\n  return { localStore, globalStore, localBase, globalBase };\n}\n\nfunction addTestPattern(store, name, opts = {}) {\n  store.addPattern({\n    name,\n    code: opts.code || `function ${name.replace(/-/g, '_')}() { return 1; }`,\n    language: opts.language || 'javascript',\n    coherencyScore: opts.coherencyScore || { total: 0.9 },\n    tags: opts.tags || ['test'],\n    testCode: opts.testCode || null,\n  });\n}\n\ndescribe('Cross-Project Persistence', () => {\n  if (!DatabaseSync) {\n    it('skips persistence tests (no SQLite)', () => { assert.ok(true); });\n    return;\n  }\n\n  describe('syncToGlobal (personal store)', () => {\n    it('syncs local patterns to personal store', () => {\n      const { localStore, globalStore } = createTestStores();\n\n      addTestPattern(localStore, 'test-add', { tags: ['math'] });\n      addTestPattern(localStore, 'test-sub', { coherencyScore: { total: 0.85 }, tags: ['math'] });\n\n      // Manual sync\n      const localPatterns = localStore.getAllPatterns();\n      const globalIndex = new Set(globalStore.getAllPatterns().map(p => `${p.name}:${p.language}`));\n\n      let synced = 0;\n      for (const p of localPatterns) {\n        if (!globalIndex.has(`${p.name}:${p.language}`)) {\n          globalStore.addPattern({\n            name: p.name, code: p.code, language: p.language,\n            coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n          });\n          synced++;\n        }\n      }\n\n      assert.equal(synced, 2);\n      assert.equal(globalStore.getAllPatterns().length, 2);\n    });\n\n    it('skips duplicates on second sync', () => {\n      const { localStore, globalStore } = createTestStores();\n\n      addTestPattern(localStore, 'unique-fn');\n\n      const p = localStore.getAllPatterns()[0];\n      globalStore.addPattern({\n        name: p.name, code: p.code, language: p.language,\n        coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n      });\n\n      const globalIndex = new Set(globalStore.getAllPatterns().map(pp => `${pp.name}:${pp.language}`));\n      let duplicates = 0;\n      for (const lp of localStore.getAllPatterns()) {\n        if (globalIndex.has(`${lp.name}:${lp.language}`)) duplicates++;\n      }\n\n      assert.equal(duplicates, 1);\n    });\n  });\n\n  describe('syncFromGlobal (personal store)', () => {\n    it('pulls personal patterns into local store', () => {\n      const { localStore, globalStore } = createTestStores();\n\n      addTestPattern(globalStore, 'personal-fn', { coherencyScore: { total: 0.95 }, tags: ['utility'] });\n\n      const globalPatterns = globalStore.getAllPatterns();\n      const localIndex = new Set(localStore.getAllPatterns().map(p => `${p.name}:${p.language}`));\n\n      let pulled = 0;\n      for (const p of globalPatterns) {\n        if (!localIndex.has(`${p.name}:${p.language}`)) {\n          localStore.addPattern({\n            name: p.name, code: p.code, language: p.language,\n            coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n          });\n          pulled++;\n        }\n      }\n\n      assert.equal(pulled, 1);\n      assert.equal(localStore.getAllPatterns().length, 1);\n      assert.equal(localStore.getAllPatterns()[0].name, 'personal-fn');\n    });\n  });\n\n  describe('shareToCommuntiy', () => {\n    it('shares test-backed patterns to community store', () => {\n      const { localStore } = createTestStores();\n      const communityBase = makeTempDir('community');\n      const communityStore = new SQLiteStore(communityBase);\n\n      // Pattern with test code — should be shared\n      addTestPattern(localStore, 'shareable', {\n        coherencyScore: { total: 0.9 },\n        testCode: 'if (shareable() !== 1) throw new Error(\"fail\");',\n      });\n      // Pattern without test code — should be skipped\n      addTestPattern(localStore, 'no-test', { coherencyScore: { total: 0.9 } });\n\n      const localPatterns = localStore.getAllPatterns();\n      const communityIndex = new Set();\n      let shared = 0, skipped = 0;\n\n      for (const p of localPatterns) {\n        const key = `${p.name}:${p.language}`;\n        if (communityIndex.has(key)) continue;\n        const coherency = p.coherencyScore?.total ?? 0;\n        if (coherency < 0.7) { skipped++; continue; }\n        const testCode = p.testCode;\n        if (!testCode) { skipped++; continue; }\n\n        communityStore.addPattern({\n          name: p.name, code: p.code, language: p.language,\n          coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n          testCode,\n        });\n        shared++;\n      }\n\n      assert.equal(shared, 1);\n      assert.equal(skipped, 1);\n      assert.equal(communityStore.getAllPatterns().length, 1);\n      assert.equal(communityStore.getAllPatterns()[0].name, 'shareable');\n    });\n\n    it('requires minimum coherency 0.7 for community', () => {\n      const { localStore } = createTestStores();\n      const communityBase = makeTempDir('community');\n      const communityStore = new SQLiteStore(communityBase);\n\n      addTestPattern(localStore, 'low-coherency', {\n        coherencyScore: { total: 0.5 },\n        testCode: 'assert(true);',\n      });\n\n      const localPatterns = localStore.getAllPatterns();\n      let shared = 0;\n\n      for (const p of localPatterns) {\n        const coherency = p.coherencyScore?.total ?? 0;\n        if (coherency >= 0.7) {\n          communityStore.addPattern({\n            name: p.name, code: p.code, language: p.language,\n            coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n          });\n          shared++;\n        }\n      }\n\n      assert.equal(shared, 0);\n      assert.equal(communityStore.getAllPatterns().length, 0);\n    });\n  });\n\n  describe('pullFromCommunity', () => {\n    it('pulls community patterns into local', () => {\n      const { localStore } = createTestStores();\n      const communityBase = makeTempDir('community');\n      const communityStore = new SQLiteStore(communityBase);\n\n      addTestPattern(communityStore, 'community-fn', { coherencyScore: { total: 0.85 } });\n      addTestPattern(communityStore, 'community-fn2', { coherencyScore: { total: 0.8 } });\n\n      const communityPatterns = communityStore.getAllPatterns();\n      const localIndex = new Set(localStore.getAllPatterns().map(p => `${p.name}:${p.language}`));\n\n      let pulled = 0;\n      for (const p of communityPatterns) {\n        if (!localIndex.has(`${p.name}:${p.language}`)) {\n          localStore.addPattern({\n            name: p.name, code: p.code, language: p.language,\n            coherencyScore: p.coherencyScore || {}, tags: p.tags || [],\n          });\n          pulled++;\n        }\n      }\n\n      assert.equal(pulled, 2);\n      assert.equal(localStore.getAllPatterns().length, 2);\n    });\n  });\n\n  describe('federatedQuery (3-tier)', () => {\n    it('merges local, personal, and community patterns with deduplication', () => {\n      const localBase = makeTempDir('local');\n      const personalBase = makeTempDir('personal');\n      const communityBase = makeTempDir('community');\n\n      const localStore = new SQLiteStore(localBase);\n      const personalStore = new SQLiteStore(personalBase);\n      const communityStore = new SQLiteStore(communityBase);\n\n      // Same name in all 3 — local should win\n      addTestPattern(localStore, 'shared', { code: 'return \"local\";' });\n      addTestPattern(personalStore, 'shared', { code: 'return \"personal\";' });\n      addTestPattern(communityStore, 'shared', { code: 'return \"community\";' });\n\n      // Unique to each tier\n      addTestPattern(personalStore, 'personal-only');\n      addTestPattern(communityStore, 'community-only');\n\n      // Manual federated\n      const seen = new Set();\n      const merged = [];\n\n      for (const p of localStore.getAllPatterns()) {\n        const key = `${p.name}:${p.language}`;\n        if (!seen.has(key)) { seen.add(key); merged.push({ ...p, source: 'local' }); }\n      }\n      for (const p of personalStore.getAllPatterns()) {\n        const key = `${p.name}:${p.language}`;\n        if (!seen.has(key)) { seen.add(key); merged.push({ ...p, source: 'personal' }); }\n      }\n      for (const p of communityStore.getAllPatterns()) {\n        const key = `${p.name}:${p.language}`;\n        if (!seen.has(key)) { seen.add(key); merged.push({ ...p, source: 'community' }); }\n      }\n\n      assert.equal(merged.length, 3); // shared(local) + personal-only + community-only\n      assert.equal(merged.filter(m => m.source === 'local').length, 1);\n      assert.equal(merged.filter(m => m.source === 'personal').length, 1);\n      assert.equal(merged.filter(m => m.source === 'community').length, 1);\n    });\n  });\n\n  describe('Oracle API integration', () => {\n    it('oracle.globalStats() returns combined personal + community stats', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n      const stats = oracle.globalStats();\n      assert.ok('available' in stats || 'error' in stats);\n      // Should include personal and community sub-stats\n      if (stats.available) {\n        assert.ok('personal' in stats);\n        assert.ok('community' in stats);\n      }\n    });\n\n    it('oracle.sync() runs without error', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n\n      oracle.registerPattern({\n        name: 'sync-test',\n        code: 'function syncTest(n) { return n; }',\n        testCode: 'if (syncTest(1) !== 1) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Identity',\n        tags: ['test'],\n        patternType: 'utility',\n      });\n\n      const result = oracle.sync();\n      assert.ok(result);\n      assert.ok('push' in result || 'error' in result);\n    });\n\n    it('oracle.share() requires test code', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n\n      oracle.registerPattern({\n        name: 'share-test',\n        code: 'function shareTest() { return 1; }',\n        testCode: 'if (shareTest() !== 1) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Test share',\n        tags: ['test'],\n        patternType: 'utility',\n      });\n\n      const result = oracle.share();\n      assert.ok(result);\n      assert.ok('shared' in result || 'error' in result);\n    });\n\n    it('oracle.federatedSearch() returns 3-tier merged results', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n\n      oracle.registerPattern({\n        name: 'fed-test',\n        code: 'function fedTest(n) { return n + 1; }',\n        testCode: 'if (fedTest(0) !== 1) throw new Error(\"fail\");',\n        language: 'javascript',\n        description: 'Increment',\n        tags: ['test'],\n        patternType: 'utility',\n      });\n\n      const result = oracle.federatedSearch();\n      assert.ok(result);\n      assert.ok(result.localCount >= 1);\n      assert.ok(result.mergedCount >= 1);\n      assert.ok('personalCount' in result);\n      assert.ok('communityCount' in result);\n    });\n\n    it('oracle.personalStats() returns personal store info', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n      const stats = oracle.personalStats();\n      assert.ok('available' in stats || 'error' in stats);\n    });\n\n    it('oracle.communityStats() returns community store info', () => {\n      const { RemembranceOracle } = require('../src/api/oracle');\n      const tmpDir = makeTempDir('oracle');\n      const oracle = new RemembranceOracle({ baseDir: tmpDir, autoSeed: false });\n      const stats = oracle.communityStats();\n      assert.ok('available' in stats || 'error' in stats);\n    });\n  });\n});\n",
      "language": "javascript",
      "description": "Harvested from . — tests/persistence.test.js (39 functions)",
      "tags": [
        "assert",
        "path",
        "fs",
        "os",
        "makeTempDir",
        "javascript",
        "harvested"
      ],
      "patternType": "algorithm",
      "complexity": "architectural",
      "coherency": 0.7
    },
    {
      "id": "2f0573a78b8db6f7",
      "name": "connectionPromise-ts",
      "code": "const connectionPromise = (count) => new Promise((resolve) => {\n      const check = () => {\n        if (wss.clients.size >= count) resolve();\n        else setTimeout(check, 20);\n      };\n      check();\n    }",
      "language": "typescript",
      "description": "Harvested function from . — tests/websocket.test.js (TypeScript variant)",
      "tags": [
        "connectionPromise",
        "javascript",
        "harvested",
        "variant",
        "typescript"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.675
    },
    {
      "id": "5f254859a01e04d6",
      "name": "connectionPromise",
      "code": "const connectionPromise = (count) => new Promise((resolve) => {\n      const check = () => {\n        if (wss.clients.size >= count) resolve();\n        else setTimeout(check, 20);\n      };\n      check();\n    }",
      "language": "javascript",
      "description": "Harvested function from . — tests/websocket.test.js",
      "tags": [
        "connectionPromise",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.63
    },
    {
      "id": "716530a3e700dfb4",
      "name": "name",
      "code": "const name = () =>)', () => {\n    const code = `const double = (n) => {\n  return n * 2;\n};\nconst triple = (n) => {\n  return n * 3;\n};`;\n    const funcs = extractFunctions(code, 'js');\n    assert.equal(funcs.length, 2);\n    assert.equal(funcs[0].name, 'double');\n    assert.equal(funcs[0].signature, 'double(n)');\n    assert.equal(funcs[1].name, 'triple');\n  }",
      "language": "javascript",
      "description": "Harvested function from . — tests/versioning.test.js",
      "tags": [
        "name",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.63
    },
    {
      "id": "5f4dcfce59ae6142",
      "name": "str",
      "code": "const str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");`,\n    language: 'javascript',\n    description: 'Function pipe — compose left-to-right',\n    tags: ['utility', 'functional', 'pipe', 'compose', 'transform'],\n    patternType: 'utility',\n  },\n\n  // ─── Data Structures ───\n  {\n    name: 'lru-cache',\n    code: `class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}`,\n    testCode: `const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");`,\n    language: 'javascript',\n    description: 'LRU Cache using Map for O(1) get/set with eviction',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "str",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.63
    },
    {
      "id": "39f18e2a416b6d92",
      "name": "f",
      "code": "const f = () => 1;', coherence: 0.71 };\n    const simScore = reflectionScore(similar, previous);\n    const divScore = reflectionScore(diverse, previous);\n    // Diverse should get a canvas bonus\n    assert.ok(divScore >= simScore, `Diverse ${divScore}",
      "language": "javascript",
      "description": "Harvested function from . — tests/reflection.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.63
    },
    {
      "id": "662752558dddb5cb",
      "name": "f",
      "code": "function f() { if (true) {', 0);\n      assert.equal(body, null);\n    });\n  }",
      "language": "javascript",
      "description": "Harvested function from . — tests/harvest.test.js",
      "tags": [
        "f",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "atomic",
      "coherency": 0.63
    },
    {
      "id": "1ad035bd89555457",
      "name": "multiply",
      "code": "const multiply = (a, b) => a * b;';\n    const fns = extractFunctionNames(code, 'javascript');\n    assert.ok(fns.includes('multiply'));\n  });\n\n  it('extracts Python functions', () => {\n    const code = 'def hello():\\n    print(\"hello\")\\n\\ndef world():\\n    pass';\n    const fns = extractFunctionNames(code, 'python');\n    assert.ok(fns.includes('hello'));\n    assert.ok(fns.includes('world'));\n  }",
      "language": "javascript",
      "description": "Harvested function from . — tests/auto-seed.test.js",
      "tags": [
        "multiply",
        "javascript",
        "harvested"
      ],
      "patternType": "validation",
      "complexity": "composite",
      "coherency": 0.63
    },
    {
      "id": "0a8997d88207fa81",
      "name": "inc",
      "code": "const inc = x => x + 1;\nconst str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");`,\n    language: 'javascript',\n    description: 'Function pipe — compose left-to-right',\n    tags: ['utility', 'functional', 'pipe', 'compose', 'transform'],\n    patternType: 'utility',\n  },\n\n  // ─── Data Structures ───\n  {\n    name: 'lru-cache',\n    code: `class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}`,\n    testCode: `const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");`,\n    language: 'javascript',\n    description: 'LRU Cache using Map for O(1) get/set with eviction',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "inc",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.63
    },
    {
      "id": "06fe505917d09e33",
      "name": "double",
      "code": "const double = x => x * 2;\nconst inc = x => x + 1;\nconst str = x => String(x);\nconst transform = pipe(double, inc, str);\nif (transform(5) !== \"11\") throw new Error(\"pipe: \" + transform(5));\nif (pipe()(42) !== 42) throw new Error(\"empty pipe\");`,\n    language: 'javascript',\n    description: 'Function pipe — compose left-to-right',\n    tags: ['utility', 'functional', 'pipe', 'compose', 'transform'],\n    patternType: 'utility',\n  },\n\n  // ─── Data Structures ───\n  {\n    name: 'lru-cache',\n    code: `class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  set(key, val) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, val);\n  }\n}`,\n    testCode: `const c = new LRUCache(2);\nc.set('a', 1); c.set('b', 2);\nif (c.get('a') !== 1) throw new Error(\"get a\");\nc.set('c', 3);\nif (c.get('b') !== undefined) throw new Error(\"evict b\");\nif (c.get('c') !== 3) throw new Error(\"get c\");`,\n    language: 'javascript',\n    description: 'LRU Cache using Map for O(1) get/set with eviction',\n    tags: ['data-structure', 'cache', 'lru', 'map', 'eviction'],\n    patternType: 'data-structure',\n  }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds.js",
      "tags": [
        "double",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "architectural",
      "coherency": 0.63
    },
    {
      "id": "e0d3c44960c65805",
      "name": "seedExtendedLibrary",
      "code": "function seedExtendedLibrary(oracle, { verbose = false }",
      "language": "javascript",
      "description": "Harvested function from . — src/patterns/seeds-extended.js",
      "tags": [
        "seedExtendedLibrary",
        "javascript",
        "harvested"
      ],
      "patternType": "utility",
      "complexity": "atomic",
      "coherency": 0.6
    }
  ]
}