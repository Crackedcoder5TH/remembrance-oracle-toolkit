[
  {
    "name": "coherence-rating",
    "code": "function CoherenceRating(score, dimensions) {\n  var dims = dimensions || {};\n  var total = typeof score === 'number' ? score : 0;\n  var level = total >= 0.8 ? 'high' : total >= 0.6 ? 'medium' : 'low';\n  var bar = function(val) {\n    var filled = Math.round(val * 20);\n    var empty = 20 - filled;\n    var result = '';\n    for (var i = 0; i < filled; i++) result += '#';\n    for (var i = 0; i < empty; i++) result += '-';\n    return '[' + result + '] ' + (val * 100).toFixed(1) + '%';\n  };\n  var output = {\n    total: total,\n    level: level,\n    bar: bar(total),\n    dimensions: {}\n  };\n  var keys = Object.keys(dims);\n  for (var i = 0; i < keys.length; i++) {\n    output.dimensions[keys[i]] = {\n      score: dims[keys[i]],\n      bar: bar(dims[keys[i]])\n    };\n  }\n  output.passes = total >= 0.6;\n  return output;\n}",
    "testCode": "var r = CoherenceRating(0.85, { correctness: 0.9, simplicity: 0.8, relevance: 0.85 });\nif (r.total !== 0.85) throw new Error('total');\nif (r.level !== 'high') throw new Error('level should be high: ' + r.level);\nif (!r.passes) throw new Error('should pass');\nif (!r.bar.includes('#')) throw new Error('bar should have filled chars');\nif (!r.dimensions.correctness) throw new Error('should have dimensions');\nif (r.dimensions.correctness.score !== 0.9) throw new Error('dim score');\nvar low = CoherenceRating(0.3);\nif (low.level !== 'low') throw new Error('should be low');\nif (low.passes) throw new Error('should not pass');\nvar med = CoherenceRating(0.65);\nif (med.level !== 'medium') throw new Error('should be medium');",
    "language": "javascript",
    "description": "Coherence rating component that renders score bars and pass/fail levels for multi-dimensional code quality",
    "tags": [
      "coherence",
      "rating",
      "ui",
      "react",
      "scoring",
      "visualization",
      "quality"
    ],
    "patternType": "utility"
  },
  {
    "name": "solana-nft-mint",
    "code": "function buildNFTMintTransaction(params) {\n  if (!params.creator) throw new Error('creator address required');\n  if (!params.name || params.name.length > 32) throw new Error('name required (max 32 chars)');\n  if (!params.symbol || params.symbol.length > 10) throw new Error('symbol required (max 10 chars)');\n  if (!params.uri) throw new Error('metadata URI required');\n\n  var sellerFeeBasis = params.sellerFeeBasisPoints || 500;\n  if (sellerFeeBasis < 0 || sellerFeeBasis > 10000) throw new Error('sellerFeeBasisPoints must be 0-10000');\n\n  var creators = params.creators || [{ address: params.creator, share: 100, verified: true }];\n  var totalShare = 0;\n  for (var i = 0; i < creators.length; i++) totalShare += creators[i].share;\n  if (totalShare !== 100) throw new Error('creator shares must sum to 100');\n\n  return {\n    type: 'nft_mint',\n    mint: { address: null, decimals: 0, supply: 1 },\n    metadata: {\n      name: params.name,\n      symbol: params.symbol,\n      uri: params.uri,\n      sellerFeeBasisPoints: sellerFeeBasis,\n      creators: creators,\n      isMutable: params.isMutable !== false,\n      collection: params.collection || null\n    },\n    creator: params.creator,\n    instructions: [\n      { program: 'system', action: 'createAccount' },\n      { program: 'token', action: 'initializeMint' },\n      { program: 'token', action: 'createAssociatedTokenAccount' },\n      { program: 'token', action: 'mintTo', amount: 1 },\n      { program: 'metadata', action: 'createMetadataV3' },\n      { program: 'metadata', action: 'createMasterEdition' }\n    ]\n  };\n}",
    "testCode": "var tx = buildNFTMintTransaction({\n  creator: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',\n  name: 'My NFT',\n  symbol: 'MNFT',\n  uri: 'https://arweave.net/abc123'\n});\nif (tx.type !== 'nft_mint') throw new Error('type');\nif (tx.mint.decimals !== 0) throw new Error('decimals must be 0 for NFT');\nif (tx.mint.supply !== 1) throw new Error('supply must be 1');\nif (tx.metadata.name !== 'My NFT') throw new Error('name');\nif (tx.metadata.sellerFeeBasisPoints !== 500) throw new Error('default fee');\nif (tx.instructions.length !== 6) throw new Error('should have 6 instructions');\nif (tx.metadata.creators[0].share !== 100) throw new Error('creator share');\ntry { buildNFTMintTransaction({}); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }\ntry { buildNFTMintTransaction({ creator: 'x', name: 'a'.repeat(33), symbol: 'X', uri: 'u' }); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }\nvar custom = buildNFTMintTransaction({\n  creator: 'abc', name: 'Test', symbol: 'T', uri: 'u',\n  sellerFeeBasisPoints: 1000,\n  creators: [{ address: 'a', share: 60, verified: true }, { address: 'b', share: 40, verified: false }]\n});\nif (custom.metadata.sellerFeeBasisPoints !== 1000) throw new Error('custom fee');\nif (custom.metadata.creators.length !== 2) throw new Error('custom creators');",
    "language": "javascript",
    "description": "Solana NFT mint transaction builder with metadata validation, creator splits, and instruction sequencing",
    "tags": [
      "solana",
      "nft",
      "mint",
      "blockchain",
      "web3",
      "token",
      "metaplex"
    ],
    "patternType": "utility"
  },
  {
    "name": "whisper-response-generator",
    "code": "function generateWhisperResponse(transcript, options) {\n  options = options || {};\n  var confidence = options.confidence || 0;\n  var language = options.language || 'en';\n  var segments = options.segments || [];\n\n  if (!transcript || typeof transcript !== 'string') {\n    return { text: '', confidence: 0, tokens: 0, status: 'empty' };\n  }\n\n  var text = transcript.trim();\n  var tokens = text.split(/\\s+/).length;\n  var sentences = text.split(/[.!?]+/).filter(function(s) { return s.trim().length > 0; });\n\n  var quality = 'low';\n  if (confidence >= 0.9 && tokens >= 3) quality = 'high';\n  else if (confidence >= 0.7 && tokens >= 2) quality = 'medium';\n\n  var timestamps = [];\n  for (var i = 0; i < segments.length; i++) {\n    timestamps.push({\n      text: segments[i].text || '',\n      start: segments[i].start || 0,\n      end: segments[i].end || 0,\n      confidence: segments[i].confidence || confidence\n    });\n  }\n\n  return {\n    text: text,\n    confidence: confidence,\n    tokens: tokens,\n    sentences: sentences.length,\n    language: language,\n    quality: quality,\n    timestamps: timestamps,\n    status: 'ok',\n    needsReview: confidence < 0.7 || tokens < 3\n  };\n}",
    "testCode": "var r = generateWhisperResponse('Hello world, how are you?', { confidence: 0.95 });\nif (r.text !== 'Hello world, how are you?') throw new Error('text');\nif (r.tokens !== 5) throw new Error('tokens: ' + r.tokens);\nif (r.quality !== 'high') throw new Error('quality should be high');\nif (r.status !== 'ok') throw new Error('status');\nif (r.needsReview) throw new Error('should not need review');\nvar low = generateWhisperResponse('um', { confidence: 0.3 });\nif (low.quality !== 'low') throw new Error('low quality');\nif (!low.needsReview) throw new Error('should need review');\nvar empty = generateWhisperResponse('');\nif (empty.status !== 'empty') throw new Error('empty status');\nvar segs = generateWhisperResponse('Hi there', {\n  confidence: 0.8,\n  segments: [{ text: 'Hi', start: 0, end: 0.5 }, { text: 'there', start: 0.5, end: 1.0 }]\n});\nif (segs.timestamps.length !== 2) throw new Error('segments');\nif (segs.quality !== 'medium') throw new Error('med quality');",
    "language": "javascript",
    "description": "Whisper speech-to-text response processor with confidence scoring, quality tiers, and timestamp segments",
    "tags": [
      "whisper",
      "speech",
      "ai",
      "transcription",
      "audio",
      "nlp",
      "confidence"
    ],
    "patternType": "utility"
  },
  {
    "name": "lsh-signature-generator",
    "code": "function generateLSHSignature(text, options) {\n  options = options || {};\n  var numHashes = options.numHashes || 128;\n  var shingleSize = options.shingleSize || 3;\n\n  if (!text || typeof text !== 'string') return { signature: [], shingles: 0, bands: 0 };\n\n  var normalized = text.toLowerCase().replace(/\\s+/g, ' ').trim();\n  var shingles = new Set();\n  for (var i = 0; i <= normalized.length - shingleSize; i++) {\n    shingles.add(normalized.substring(i, i + shingleSize));\n  }\n\n  var shingleArr = Array.from(shingles);\n  var signature = [];\n  for (var h = 0; h < numHashes; h++) {\n    var minHash = Infinity;\n    var a = (h * 1103515245 + 12345) >>> 0;\n    var b = ((h + 1) * 1103515245 + 12345) >>> 0;\n    for (var s = 0; s < shingleArr.length; s++) {\n      var charSum = 0;\n      for (var c = 0; c < shingleArr[s].length; c++) {\n        charSum += shingleArr[s].charCodeAt(c);\n      }\n      var hash = ((a * charSum + b) & 0x7FFFFFFF) % 104729;\n      if (hash < minHash) minHash = hash;\n    }\n    signature.push(minHash === Infinity ? 0 : minHash);\n  }\n\n  var numBands = options.bands || Math.floor(numHashes / 4);\n  var rowsPerBand = Math.floor(numHashes / numBands);\n  var bands = [];\n  for (var i = 0; i < numBands; i++) {\n    var band = signature.slice(i * rowsPerBand, (i + 1) * rowsPerBand);\n    var bandHash = 0;\n    for (var j = 0; j < band.length; j++) bandHash = ((bandHash * 31) + band[j]) & 0x7FFFFFFF;\n    bands.push(bandHash);\n  }\n\n  return { signature: signature, shingles: shingleArr.length, bands: bands, numHashes: numHashes };\n}\n\nfunction estimateSimilarity(sigA, sigB) {\n  if (!sigA.length || !sigB.length || sigA.length !== sigB.length) return 0;\n  var matches = 0;\n  for (var i = 0; i < sigA.length; i++) {\n    if (sigA[i] === sigB[i]) matches++;\n  }\n  return matches / sigA.length;\n}",
    "testCode": "var sig1 = generateLSHSignature('the quick brown fox jumps over the lazy dog');\nif (sig1.signature.length !== 128) throw new Error('default 128 hashes');\nif (sig1.shingles === 0) throw new Error('should have shingles');\nif (sig1.bands.length === 0) throw new Error('should have bands');\nvar sig2 = generateLSHSignature('the quick brown fox jumps over the lazy dog');\nif (JSON.stringify(sig1.signature) !== JSON.stringify(sig2.signature)) throw new Error('deterministic');\nvar sim = estimateSimilarity(sig1.signature, sig2.signature);\nif (sim !== 1) throw new Error('identical should be 1: ' + sim);\nvar sig3 = generateLSHSignature('completely different text here');\nvar sim2 = estimateSimilarity(sig1.signature, sig3.signature);\nif (sim2 >= 0.5) throw new Error('different should be low: ' + sim2);\nvar empty = generateLSHSignature('');\nif (empty.shingles !== 0) throw new Error('empty');\nvar custom = generateLSHSignature('hello world', { numHashes: 64, shingleSize: 2 });\nif (custom.signature.length !== 64) throw new Error('custom hashes');",
    "language": "javascript",
    "description": "Locality-sensitive hashing (MinHash) for near-duplicate detection with configurable shingles, bands, and similarity estimation",
    "tags": [
      "lsh",
      "minhash",
      "similarity",
      "hashing",
      "search",
      "algorithm",
      "dedup"
    ],
    "patternType": "algorithm"
  },
  {
    "name": "remembrance-scoring",
    "code": "function remembranceScore(pattern) {\n  if (!pattern || !pattern.code) return { total: 0, dimensions: {}, pass: false };\n\n  var weights = { relevance: 0.25, coherency: 0.25, usage: 0.20, freshness: 0.15, trust: 0.15 };\n\n  var relevance = Math.min(1, Math.max(0, pattern.relevance || 0));\n  var coherency = Math.min(1, Math.max(0, pattern.coherency || 0));\n\n  var uses = pattern.uses || 0;\n  var successes = pattern.successes || 0;\n  var usage = uses > 0 ? (successes / uses) * Math.min(1, Math.log2(uses + 1) / 5) : 0;\n\n  var daysSinceUse = pattern.daysSinceUse || 0;\n  var freshness = daysSinceUse <= 7 ? 1.0 : daysSinceUse <= 30 ? 0.8 : daysSinceUse <= 90 ? 0.5 : daysSinceUse <= 180 ? 0.3 : 0.1;\n\n  var hasTest = pattern.hasTest ? 1 : 0;\n  var validated = pattern.validated ? 0.5 : 0;\n  var community = Math.min(1, (pattern.votes || 0) / 10);\n  var trust = (hasTest * 0.4) + (validated * 0.3) + (community * 0.3);\n\n  var total = (relevance * weights.relevance) + (coherency * weights.coherency) +\n              (usage * weights.usage) + (freshness * weights.freshness) + (trust * weights.trust);\n\n  total = Math.round(total * 1000) / 1000;\n\n  return {\n    total: total,\n    dimensions: { relevance: relevance, coherency: coherency, usage: Math.round(usage * 1000) / 1000, freshness: freshness, trust: Math.round(trust * 1000) / 1000 },\n    pass: total >= 0.6,\n    weights: weights\n  };\n}",
    "testCode": "var perfect = remembranceScore({\n  code: 'x', relevance: 1, coherency: 1, uses: 100, successes: 95,\n  daysSinceUse: 1, hasTest: true, validated: true, votes: 20\n});\nif (perfect.total < 0.8) throw new Error('perfect should be high: ' + perfect.total);\nif (!perfect.pass) throw new Error('should pass');\nif (perfect.dimensions.freshness !== 1.0) throw new Error('fresh');\nvar empty = remembranceScore({});\nif (empty.total !== 0) throw new Error('empty should be 0');\nif (empty.pass) throw new Error('empty should not pass');\nvar stale = remembranceScore({ code: 'x', relevance: 0.8, coherency: 0.8, daysSinceUse: 200 });\nif (stale.dimensions.freshness !== 0.1) throw new Error('stale freshness');\nvar mid = remembranceScore({ code: 'x', relevance: 0.7, coherency: 0.7, uses: 5, successes: 4, daysSinceUse: 15, hasTest: true });\nif (mid.total < 0.3 || mid.total > 0.8) throw new Error('mid range: ' + mid.total);",
    "language": "javascript",
    "description": "Multi-dimensional remembrance scoring with weighted relevance, coherency, usage, freshness, and trust factors",
    "tags": [
      "scoring",
      "remembrance",
      "ranking",
      "relevance",
      "coherency",
      "algorithm"
    ],
    "patternType": "algorithm"
  },
  {
    "name": "self-reflection-loop",
    "code": "function selfReflectionLoop(code, options) {\n  options = options || {};\n  var maxIterations = options.maxIterations || 5;\n  var threshold = options.threshold || 0.8;\n  var evaluate = options.evaluate || function() { return { score: 1, issues: [] }; };\n  var refine = options.refine || function(c) { return c; };\n\n  var current = code;\n  var history = [];\n  var iteration = 0;\n  var converged = false;\n\n  while (iteration < maxIterations) {\n    var evaluation = evaluate(current, iteration);\n    var score = typeof evaluation.score === 'number' ? evaluation.score : 0;\n    var issues = evaluation.issues || [];\n\n    history.push({\n      iteration: iteration,\n      score: score,\n      issues: issues.slice(),\n      codeLength: current.length\n    });\n\n    if (score >= threshold) {\n      converged = true;\n      break;\n    }\n\n    if (iteration > 0 && history[iteration].score <= history[iteration - 1].score) {\n      break;\n    }\n\n    var refined = refine(current, issues, iteration);\n    if (refined === current) break;\n\n    current = refined;\n    iteration++;\n  }\n\n  return {\n    code: current,\n    converged: converged,\n    iterations: history.length,\n    finalScore: history.length > 0 ? history[history.length - 1].score : 0,\n    history: history,\n    improved: history.length > 1 && history[history.length - 1].score > history[0].score\n  };\n}",
    "testCode": "var result = selfReflectionLoop('bad code', {\n  maxIterations: 5,\n  threshold: 0.9,\n  evaluate: function(code, iter) {\n    return { score: 0.5 + iter * 0.15, issues: iter < 3 ? ['needs work'] : [] };\n  },\n  refine: function(code, issues, iter) {\n    return code + ' v' + (iter + 1);\n  }\n});\nif (!result.converged) throw new Error('should converge');\nif (result.iterations < 2) throw new Error('should iterate: ' + result.iterations);\nif (result.finalScore < 0.9) throw new Error('final score: ' + result.finalScore);\nif (!result.improved) throw new Error('should improve');\nvar instant = selfReflectionLoop('good code', {\n  evaluate: function() { return { score: 1.0, issues: [] }; }\n});\nif (!instant.converged) throw new Error('instant converge');\nif (instant.iterations !== 1) throw new Error('one iteration');\nvar stuck = selfReflectionLoop('stuck', {\n  threshold: 0.9,\n  evaluate: function() { return { score: 0.5, issues: ['stuck'] }; },\n  refine: function(code) { return code; }\n});\nif (stuck.converged) throw new Error('should not converge when stuck');",
    "language": "javascript",
    "description": "Self-reflection loop that iteratively evaluates and refines code until convergence threshold or max iterations",
    "tags": [
      "reflection",
      "loop",
      "refinement",
      "iteration",
      "self-improvement",
      "ai"
    ],
    "patternType": "design-pattern"
  },
  {
    "name": "no-harm-covenant-validator",
    "code": "function validateCovenant(code, options) {\n  options = options || {};\n  var lower = code.toLowerCase();\n\n  function hasKeyword(keywords, context) {\n    for (var i = 0; i < keywords.length; i++) {\n      var idx = lower.indexOf(keywords[i]);\n      if (idx === -1) continue;\n      if (!context) return true;\n      for (var j = 0; j < context.length; j++) {\n        if (lower.indexOf(context[j]) !== -1) return true;\n      }\n    }\n    return false;\n  }\n\n  var principles = [\n    { id: 1, name: 'no-malware', severity: 'critical',\n      check: function() { return hasKeyword(['eval(atob', 'eval( atob', 'document.write(unescape']); } },\n    { id: 2, name: 'no-data-exfil', severity: 'critical',\n      check: function() { return hasKeyword(['sendbeacon'], ['cookie', 'localstorage', 'token']); } },\n    { id: 3, name: 'no-injection', severity: 'critical',\n      check: function() {\n        var sqls = ['select ', 'insert ', 'update ', 'delete ', 'drop '];\n        for (var i = 0; i < sqls.length; i++) {\n          if (lower.indexOf(sqls[i]) !== -1 && (code.indexOf('+ req') !== -1 || code.indexOf('+ input') !== -1 || code.indexOf('+ param') !== -1 || code.indexOf('+ query') !== -1 || code.indexOf('+ user') !== -1)) return true;\n        }\n        return false;\n      } },\n    { id: 4, name: 'no-backdoor', severity: 'critical',\n      check: function() { return hasKeyword(['child_process'], ['exec(', 'execsync(']) || hasKeyword([\"spawn('sh\", 'spawn(\"sh', \"spawn('bash\", 'spawn(\"bash', \"spawn('cmd\", 'spawn(\"cmd']); } },\n    { id: 5, name: 'no-crypto-misuse', severity: 'high',\n      check: function() { return lower.indexOf('createcipher(') !== -1 || (lower.indexOf('md5(') !== -1 && lower.indexOf('password') !== -1); } },\n    { id: 6, name: 'no-hardcoded-secrets', severity: 'high',\n      check: function() {\n        var keys = ['password', 'secret', 'api_key', 'apikey', 'token'];\n        for (var i = 0; i < keys.length; i++) {\n          var idx = lower.indexOf(keys[i]);\n          if (idx === -1) continue;\n          var after = code.substring(idx + keys[i].length, idx + keys[i].length + 30).trim();\n          if (after[0] === '=' || after[0] === ':') {\n            var rest = after.substring(1).trim();\n            if ((rest[0] === '\"' || rest[0] === \"'\") && rest.length > 10) return true;\n          }\n        }\n        return false;\n      } },\n    { id: 7, name: 'no-unsafe-regex', severity: 'medium',\n      check: function() { return code.indexOf('(.*)+') !== -1 || code.indexOf('(.+)+') !== -1; } }\n  ];\n\n  var customPrinciples = options.principles || [];\n  var violations = [];\n\n  for (var i = 0; i < principles.length; i++) {\n    var p = principles[i];\n    if (p.check()) {\n      violations.push({ principle: p.id, name: p.name, severity: p.severity });\n    }\n  }\n\n  for (var i = 0; i < customPrinciples.length; i++) {\n    var cp = customPrinciples[i];\n    if (cp.pattern && cp.pattern.test(code)) {\n      violations.push({ principle: cp.id, name: cp.name, severity: cp.severity || 'medium' });\n    }\n  }\n\n  var criticals = violations.filter(function(v) { return v.severity === 'critical'; });\n  var highs = violations.filter(function(v) { return v.severity === 'high'; });\n\n  return {\n    valid: criticals.length === 0 && (options.strict ? highs.length === 0 : true),\n    violations: violations,\n    criticals: criticals.length,\n    highs: highs.length,\n    total: violations.length,\n    severity: criticals.length > 0 ? 'critical' : highs.length > 0 ? 'high' : violations.length > 0 ? 'medium' : 'clean'\n  };\n}",
    "testCode": "var clean = validateCovenant('function add(a, b) { return a + b; }');\nif (!clean.valid) throw new Error('clean code should be valid');\nif (clean.severity !== 'clean') throw new Error('should be clean');\nif (clean.total !== 0) throw new Error('no violations');\nvar injection = validateCovenant('db.query(\"SELECT * FROM users WHERE id=\" + req.params.id)');\nif (injection.valid) throw new Error('SQL injection should fail');\nif (injection.criticals < 1) throw new Error('should be critical');\nvar secret = validateCovenant('var apikey = \"sk_live_abc123456789\"');\nif (secret.highs < 1) throw new Error('should have high severity');\nvar strictSecret = validateCovenant('var apikey = \"sk_live_abc123456789\"', { strict: true });\nif (strictSecret.valid) throw new Error('strict should reject highs');\nvar safe = validateCovenant('function hash(pw) { return crypto.createHash(\"sha256\").update(pw).digest(\"hex\"); }');\nif (!safe.valid) throw new Error('sha256 should be valid');",
    "language": "javascript",
    "description": "No-harm covenant validator that checks code against security principles â€” injection, exfiltration, backdoors, secrets, crypto misuse",
    "tags": [
      "covenant",
      "security",
      "validation",
      "no-harm",
      "safety",
      "audit",
      "principles"
    ],
    "patternType": "validation"
  },
  {
    "name": "healing-pr-comment",
    "code": "function generateHealingPRComment(analysis) {\n  if (!analysis) throw new Error('analysis required');\n\n  var patternName = analysis.patternName || 'unknown';\n  var before = analysis.beforeScore || 0;\n  var after = analysis.afterScore || 0;\n  var delta = Math.round((after - before) * 1000) / 1000;\n  var method = analysis.method || 'iterative-refine';\n  var issues = analysis.issuesFixed || [];\n  var breaking = analysis.breakingChanges || false;\n\n  var emoji = delta > 0.15 ? '**major**' : delta > 0.05 ? 'moderate' : delta > 0 ? 'minor' : 'neutral';\n\n  var lines = [];\n  lines.push('## Pattern Healing Report');\n  lines.push('');\n  lines.push('**Pattern**: ' + patternName);\n  lines.push('**Method**: ' + method);\n  lines.push('**Score**: ' + before.toFixed(3) + ' -> ' + after.toFixed(3) + ' (delta: ' + (delta >= 0 ? '+' : '') + delta.toFixed(3) + ')');\n  lines.push('**Impact**: ' + emoji);\n  lines.push('');\n\n  if (issues.length > 0) {\n    lines.push('### Issues Fixed');\n    for (var i = 0; i < issues.length; i++) {\n      lines.push('- ' + issues[i]);\n    }\n    lines.push('');\n  }\n\n  if (breaking) {\n    lines.push('> **Warning**: This healing includes breaking changes. Review carefully.');\n    lines.push('');\n  }\n\n  lines.push('### Verification');\n  lines.push('- [ ] Tests pass');\n  lines.push('- [ ] Coherency score improved');\n  lines.push('- [ ] No regressions in dependent patterns');\n  lines.push('');\n  lines.push('---');\n  lines.push('*Auto-generated by Remembrance Oracle healing pipeline*');\n\n  return lines.join('\\n');\n}",
    "testCode": "var comment = generateHealingPRComment({\n  patternName: 'binary-search',\n  beforeScore: 0.65,\n  afterScore: 0.85,\n  method: 'iterative-refine',\n  issuesFixed: ['Fixed off-by-one', 'Improved naming'],\n  breakingChanges: false\n});\nif (!comment.includes('binary-search')) throw new Error('pattern name');\nif (!comment.includes('0.650')) throw new Error('before score');\nif (!comment.includes('0.850')) throw new Error('after score');\nif (!comment.includes('+0.200')) throw new Error('delta');\nif (!comment.includes('major')) throw new Error('impact for big delta');\nif (!comment.includes('Fixed off-by-one')) throw new Error('issues');\nif (comment.includes('Warning')) throw new Error('no breaking warning expected');\nvar breaking = generateHealingPRComment({\n  patternName: 'test',\n  beforeScore: 0.5,\n  afterScore: 0.52,\n  breakingChanges: true\n});\nif (!breaking.includes('Warning')) throw new Error('should warn about breaking');\nif (!breaking.includes('minor')) throw new Error('small delta should be minor');\ntry { generateHealingPRComment(); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }",
    "language": "javascript",
    "description": "Generates structured PR comments for reflection-based healing with score deltas, issue summaries, and verification checklists",
    "tags": [
      "healing",
      "pr",
      "comment",
      "template",
      "reflection",
      "report",
      "markdown"
    ],
    "patternType": "utility"
  },
  {
    "name": "eternal-now-intent-prompt",
    "code": "function buildIntentPrompt(intent, context) {\n  context = context || {};\n  var domain = context.domain || 'general';\n  var constraints = context.constraints || [];\n  var examples = context.examples || [];\n  var temperature = context.temperature || 0.7;\n  var maxTokens = context.maxTokens || 1024;\n\n  if (!intent || typeof intent !== 'string') throw new Error('intent string required');\n\n  var sections = [];\n\n  sections.push('# Intent: ' + intent);\n  sections.push('');\n  sections.push('## Context');\n  sections.push('Domain: ' + domain);\n  sections.push('Timestamp: present moment');\n  sections.push('Focus: immediate, actionable output');\n  sections.push('');\n\n  if (constraints.length > 0) {\n    sections.push('## Constraints');\n    for (var i = 0; i < constraints.length; i++) {\n      sections.push('- ' + constraints[i]);\n    }\n    sections.push('');\n  }\n\n  if (examples.length > 0) {\n    sections.push('## Examples');\n    for (var i = 0; i < examples.length; i++) {\n      sections.push('### Example ' + (i + 1));\n      if (examples[i].input) sections.push('Input: ' + examples[i].input);\n      if (examples[i].output) sections.push('Output: ' + examples[i].output);\n      sections.push('');\n    }\n  }\n\n  sections.push('## Instructions');\n  sections.push('Respond with clarity and precision. Stay grounded in the present context.');\n  sections.push('Do not speculate beyond what is directly requested.');\n\n  return {\n    prompt: sections.join('\\n'),\n    config: {\n      temperature: temperature,\n      maxTokens: maxTokens,\n      domain: domain,\n      constraintCount: constraints.length,\n      exampleCount: examples.length\n    },\n    intent: intent,\n    wordCount: sections.join('\\n').split(/\\s+/).length\n  };\n}",
    "testCode": "var p = buildIntentPrompt('Generate a unit test', {\n  domain: 'testing',\n  constraints: ['Use assert only', 'No external deps'],\n  examples: [{ input: 'add(1,2)', output: 'assert(add(1,2) === 3)' }],\n  temperature: 0.3\n});\nif (!p.prompt.includes('Generate a unit test')) throw new Error('intent');\nif (!p.prompt.includes('testing')) throw new Error('domain');\nif (!p.prompt.includes('Use assert only')) throw new Error('constraint');\nif (!p.prompt.includes('add(1,2)')) throw new Error('example');\nif (p.config.temperature !== 0.3) throw new Error('temperature');\nif (p.config.constraintCount !== 2) throw new Error('constraint count');\nif (p.config.exampleCount !== 1) throw new Error('example count');\nif (p.wordCount < 10) throw new Error('should have words');\nvar simple = buildIntentPrompt('Hello');\nif (simple.config.domain !== 'general') throw new Error('default domain');\nif (simple.config.temperature !== 0.7) throw new Error('default temp');\ntry { buildIntentPrompt(''); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }",
    "language": "javascript",
    "description": "Structured intent prompt builder with domain context, constraints, few-shot examples, and generation config",
    "tags": [
      "prompt",
      "intent",
      "ai",
      "llm",
      "template",
      "few-shot",
      "generation"
    ],
    "patternType": "utility"
  },
  {
    "name": "axiom-14-daily-reminder",
    "code": "function generateDailyReminder(axiomSet, options) {\n  options = options || {};\n  var today = options.date || new Date();\n  var format = options.format || 'text';\n\n  if (!axiomSet || !Array.isArray(axiomSet) || axiomSet.length === 0) {\n    throw new Error('axiomSet must be a non-empty array');\n  }\n\n  var dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 86400000);\n  var index = dayOfYear % axiomSet.length;\n  var axiom = axiomSet[index];\n\n  var name = axiom.name || 'Axiom ' + (index + 1);\n  var text = axiom.text || '';\n  var reflection = axiom.reflection || '';\n  var practice = axiom.practice || '';\n\n  var streakKey = 'axiom_streak';\n  var currentStreak = options.streak || 0;\n\n  var output = {};\n  if (format === 'markdown') {\n    var lines = [];\n    lines.push('# Daily Axiom: ' + name);\n    lines.push('');\n    lines.push('> ' + text);\n    lines.push('');\n    if (reflection) { lines.push('**Reflection**: ' + reflection); lines.push(''); }\n    if (practice) { lines.push('**Practice**: ' + practice); lines.push(''); }\n    lines.push('---');\n    lines.push('Day ' + dayOfYear + ' | Streak: ' + currentStreak + ' days');\n    output.rendered = lines.join('\\n');\n  } else {\n    output.rendered = name + ': ' + text + (reflection ? ' | Reflect: ' + reflection : '') + (practice ? ' | Do: ' + practice : '');\n  }\n\n  output.axiom = { index: index, name: name, text: text, reflection: reflection, practice: practice };\n  output.dayOfYear = dayOfYear;\n  output.streak = currentStreak;\n  output.nextIndex = (index + 1) % axiomSet.length;\n\n  return output;\n}",
    "testCode": "var axioms = [\n  { name: 'Axiom 1', text: 'Code remembers', reflection: 'What patterns persist?', practice: 'Review one old pattern' },\n  { name: 'Axiom 2', text: 'Test proves', reflection: 'What is unproven?', practice: 'Write a test' },\n  { name: 'Axiom 14', text: 'Heal, do not harm', reflection: 'Did I leave code better?', practice: 'Refactor one function' }\n];\nvar r = generateDailyReminder(axioms, { date: new Date(2025, 0, 15), streak: 7 });\nif (!r.axiom.text) throw new Error('should have axiom text');\nif (r.streak !== 7) throw new Error('streak');\nif (r.dayOfYear < 1) throw new Error('day of year');\nif (typeof r.rendered !== 'string' || r.rendered.length === 0) throw new Error('rendered');\nif (typeof r.nextIndex !== 'number') throw new Error('nextIndex');\nvar md = generateDailyReminder(axioms, { date: new Date(2025, 5, 1), format: 'markdown' });\nif (!md.rendered.includes('# Daily Axiom')) throw new Error('markdown header');\nif (!md.rendered.includes('Streak:')) throw new Error('streak in markdown');\nif (!md.rendered.includes('>')) throw new Error('blockquote');\ntry { generateDailyReminder([]); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }\ntry { generateDailyReminder(null); throw new Error('should throw'); } catch(e) { if (e.message === 'should throw') throw e; }\nvar wrap = generateDailyReminder(axioms, { date: new Date(2025, 11, 31) });\nif (wrap.axiom.index < 0 || wrap.axiom.index >= axioms.length) throw new Error('index bounds');",
    "language": "javascript",
    "description": "Daily axiom reminder generator with day-cycling, streak tracking, markdown/text rendering, and reflection prompts",
    "tags": [
      "axiom",
      "reminder",
      "daily",
      "ritual",
      "practice",
      "streak",
      "motivation"
    ],
    "patternType": "utility"
  }
]